.. index:: pair: page; How to Use Background Subtraction Methods
.. _doxid-d1/dc5/tutorial_background_subtraction:

How to Use Background Subtraction Methods
=========================================

* Background subtraction (BS) is a common and widely used technique for generating a foreground mask (namely, a binary image containing the pixels belonging to moving objects in the scene) by using static cameras.

* As the name suggests, BS calculates the foreground mask performing a subtraction between the current frame and a background model, containing the static part of the scene or, more in general, everything that can be considered as background given the characteristics of the observed scene.
  
  .. image:: Background_Subtraction_Tutorial_Scheme.png

* Background modeling consists of two main steps:
  
  #. Background Initialization;
  
  #. Background Update.
  
  In the first step, an initial model of the background is computed, while in the second step that model is updated in order to adapt to possible changes in the scene.

* In this tutorial we will learn how to perform BS by using OpenCV. As input, we will use data coming from the publicly available data set `Background Models Challenge (BMC) <http://bmc.univ-bpclermont.fr/>`__.

.. rubric:: Goals

In this tutorial you will learn how to:

#. Read data from videos by using :ref:`cv::VideoCapture <doxid-df/dcb/classcv_1_1_video_capture>` or image sequences by using :ref:`cv::imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`;

#. Create and update the background model by using :ref:`cv::BackgroundSubtractor <doxid-d5/d6d/classcv_1_1_background_subtractor>` class;

#. Get and show the foreground mask by using :ref:`cv::imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`;

#. Save the output by using :ref:`cv::imwrite <doxid-d4/da8/group__imgcodecs_1gabbc7ef1aa2edfaa87772f1202d67e0ce>` to quantitatively evaluate the results.

.. rubric:: Code

In the following you can find the source code. We will let the user chose to process either a video file or a sequence of images.

Two different methods are used to generate two foreground masks:

#. cv::bgsegm::BackgroundSubtractorMOG

#. :ref:`cv::BackgroundSubtractorMOG2 <doxid-d6/d6d/classcv_1_1_background_subtractor_m_o_g2>`

The results as well as the input data are shown on the screen. The source file can be downloaded `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/video/bg_sub.cpp>`__.

.. ref-code-block:: cpp

	
	//opencv
	#include "opencv2/imgcodecs.hpp"
	#include "opencv2/imgproc.hpp"
	#include "opencv2/videoio.hpp"
	#include <opencv2/highgui.hpp>
	#include <opencv2/video.hpp>
	//C
	#include <stdio.h>
	//C++
	#include <iostream>
	#include <sstream>
	
	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
	using namespace :ref:`std <doxid-d8/dcc/namespacestd>`;
	
	// Global variables
	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` frame; //current frame
	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	:ref:`Ptr\<BackgroundSubtractor> <doxid-d2/d56/structcv_1_1_ptr>` pMOG2; //MOG2 Background subtractor
	char keyboard; //input from keyboard
	
	void help();
	void processVideo(char* videoFilename);
	void processImages(char* firstFrameFilename);
	
	void help()
	{
	    cout
	    << "--------------------------------------------------------------------------" << endl
	    << "This program shows how to use background subtraction methods provided by "  << endl
	    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
	                                                                                    << endl
	    << "Usage:"                                                                     << endl
	    << "./bg_sub {-vid <video filename>|-img <image filename>}"                     << endl
	    << "for example: ./bg_sub -vid video.avi"                                       << endl
	    << "or: ./bg_sub -img /data/images/1.png"                                       << endl
	    << "--------------------------------------------------------------------------" << endl
	    << endl;
	}
	
	int main(int argc, char* argv[])
	{
	    //print help information
	    help();
	
	    //check for the input parameter correctness
	    if(argc != 3) {
	        cerr <<"Incorret input list" << endl;
	        cerr <<"exiting..." << endl;
	        return EXIT_FAILURE;
	    }
	
	    //create GUI windows
	    :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`("Frame");
	    :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`("FG Mask MOG 2");
	
	    //create Background Subtractor objects
	    pMOG2 = :ref:`createBackgroundSubtractorMOG2 <doxid-de/de1/group__video__motion_1ga2beb2dee7a073809ccec60f145b6b29c>`(); //MOG2 approach
	
	    if(strcmp(argv[1], "-vid") == 0) {
	        //input data coming from a video
	        processVideo(argv[2]);
	    }
	    else if(strcmp(argv[1], "-img") == 0) {
	        //input data coming from a sequence of images
	        processImages(argv[2]);
	    }
	    else {
	        //error in reading input parameters
	        cerr <<"Please, check the input parameters." << endl;
	        cerr <<"Exiting..." << endl;
	        return EXIT_FAILURE;
	    }
	    //destroy GUI windows
	    :ref:`destroyAllWindows <doxid-d7/dfc/group__highgui_1ga6b7fc1c1a8960438156912027b38f481>`();
	    return EXIT_SUCCESS;
	}
	
	void processVideo(char* videoFilename) {
	    //create the capture object
	    :ref:`VideoCapture <doxid-df/dcb/classcv_1_1_video_capture>` capture(videoFilename);
	    if(!capture.isOpened()){
	        //error in opening the video input
	        cerr << "Unable to open video file: " << videoFilename << endl;
	        exit(EXIT_FAILURE);
	    }
	    //read input data. ESC or 'q' for quitting
	    keyboard = 0;
	    while( keyboard != 'q' && keyboard != 27 ){
	        //read the current frame
	        if(!capture.read(frame)) {
	            cerr << "Unable to read next frame." << endl;
	            cerr << "Exiting..." << endl;
	            exit(EXIT_FAILURE);
	        }
	        //update the background model
	        pMOG2->:ref:`apply <doxid-d5/d6d/classcv_1_1_background_subtractor_1aa735e76f7069b3fa9c3f32395f9ccd21>`(frame, fgMaskMOG2);
	        //get the frame number and write it on the current frame
	        stringstream ss;
	        :ref:`rectangle <doxid-d6/d6e/group__imgproc__draw_1ga07d2f74cadcf8e305e810ce8eed13bc9>`(frame, :ref:`cv::Point <doxid-d9/d87/classcv_1_1_point__>`(10, 2), :ref:`cv::Point <doxid-d9/d87/classcv_1_1_point__>`(100,20),
	                  :ref:`cv::Scalar <doxid-d7/d13/classcv_1_1_scalar__>`(255,255,255), -1);
	        ss << capture.get(:ref:`CAP_PROP_POS_FRAMES <doxid-d4/d15/group__videoio__flags__base_1ggaeb8dd9c89c10a5c63c139bf7c4f5704da6223452891755166a4fd5173ea257068>`);
	        string frameNumberString = ss.str();
	        :ref:`putText <doxid-d6/d6e/group__imgproc__draw_1ga5126f47f883d730f633d74f07456c576>`(frame, frameNumberString.c_str(), :ref:`cv::Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`(15, 15),
	                :ref:`FONT_HERSHEY_SIMPLEX <doxid-d0/de1/group__core_1gga0f9314ea6e35f99bb23f29567fc16e11afff8b973668df2e4028dddc5274310c9>`, 0.5 , :ref:`cv::Scalar <doxid-dc/d84/group__core__basic_1ga599fe92e910c027be274233eccad7beb>`(0,0,0));
	        //show the current frame and the fg masks
	        :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("Frame", frame);
	        :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("FG Mask MOG 2", fgMaskMOG2);
	        //get the input from the keyboard
	        keyboard = (char):ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`( 30 );
	    }
	    //delete capture object
	    capture.release();
	}
	
	void processImages(char* fistFrameFilename) {
	    //read the first file of the sequence
	    frame = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`(fistFrameFilename);
	    if(frame.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`()){
	        //error in opening the first image
	        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
	        exit(EXIT_FAILURE);
	    }
	    //current image filename
	    string fn(fistFrameFilename);
	    //read input data. ESC or 'q' for quitting
	    keyboard = 0;
	    while( keyboard != 'q' && keyboard != 27 ){
	        //update the background model
	        pMOG2->:ref:`apply <doxid-d5/d6d/classcv_1_1_background_subtractor_1aa735e76f7069b3fa9c3f32395f9ccd21>`(frame, fgMaskMOG2);
	        //get the frame number and write it on the current frame
	        size_t index = fn.find_last_of("/");
	        if(index == string::npos) {
	            index = fn.find_last_of("\\");
	        }
	        size_t index2 = fn.find_last_of(".");
	        string prefix = fn.substr(0,index+1);
	        string suffix = fn.substr(index2);
	        string frameNumberString = fn.substr(index+1, index2-index-1);
	        istringstream iss(frameNumberString);
	        int frameNumber = 0;
	        iss >> frameNumber;
	        :ref:`rectangle <doxid-d6/d6e/group__imgproc__draw_1ga07d2f74cadcf8e305e810ce8eed13bc9>`(frame, :ref:`cv::Point <doxid-d9/d87/classcv_1_1_point__>`(10, 2), :ref:`cv::Point <doxid-d9/d87/classcv_1_1_point__>`(100,20),
	                  :ref:`cv::Scalar <doxid-d7/d13/classcv_1_1_scalar__>`(255,255,255), -1);
	        :ref:`putText <doxid-d6/d6e/group__imgproc__draw_1ga5126f47f883d730f633d74f07456c576>`(frame, frameNumberString.c_str(), :ref:`cv::Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`(15, 15),
	                :ref:`FONT_HERSHEY_SIMPLEX <doxid-d0/de1/group__core_1gga0f9314ea6e35f99bb23f29567fc16e11afff8b973668df2e4028dddc5274310c9>`, 0.5 , :ref:`cv::Scalar <doxid-dc/d84/group__core__basic_1ga599fe92e910c027be274233eccad7beb>`(0,0,0));
	        //show the current frame and the fg masks
	        :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("Frame", frame);
	        :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("FG Mask MOG 2", fgMaskMOG2);
	        //get the input from the keyboard
	        keyboard = (char):ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`( 30 );
	        //search for the next image in the sequence
	        ostringstream oss;
	        oss << (frameNumber + 1);
	        string nextFrameNumberString = oss.str();
	        string nextFrameFilename = prefix + nextFrameNumberString + suffix;
	        //read the next frame
	        frame = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`(nextFrameFilename);
	        if(frame.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`()){
	            //error in opening the next image in the sequence
	            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
	            exit(EXIT_FAILURE);
	        }
	        //update the path of the current frame
	        fn.assign(nextFrameFilename);
	    }
	}

.. rubric:: Explanation

We discuss the main parts of the above code:

#. First, three Mat objects are allocated to store the current frame and two foreground masks, obtained by using two different BS algorithms.
   
   .. ref-code-block:: cpp
   
   	Mat frame; //current frame
   	Mat fgMaskMOG; //fg mask generated by MOG method
   	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method

#. Two :ref:`cv::BackgroundSubtractor <doxid-d5/d6d/classcv_1_1_background_subtractor>` objects will be used to generate the foreground masks. In this example, default parameters are used, but it is also possible to declare specific parameters in the create function.
   
   .. ref-code-block:: cpp
   
   	Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
   	Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
   	...
   	//create Background Subtractor objects
   	pMOG = :ref:`createBackgroundSubtractorMOG <doxid-d6/d17/group__cudabgsegm_1ga6742648a654585013544eaa300f77b57>`(); //MOG approach
   	pMOG2 = :ref:`createBackgroundSubtractorMOG2 <doxid-de/de1/group__video__motion_1ga2beb2dee7a073809ccec60f145b6b29c>`(); //MOG2 approach

#. The command line arguments are analysed. The user can chose between two options:
   
   * video files (by choosing the option -vid);
   
   * image sequences (by choosing the option -img).
     
     .. ref-code-block:: cpp
     
     	if(strcmp(argv[1], "-vid") == 0) {
     	  //input data coming from a video
     	  processVideo(argv[2]);
     	}
     	else if(strcmp(argv[1], "-img") == 0) {
     	  //input data coming from a sequence of images
     	  processImages(argv[2]);
     	}

#. Suppose you want to process a video file. The video is read until the end is reached or the user presses the button 'q' or the button 'ESC'.
   
   .. ref-code-block:: cpp
   
   	while( (char)keyboard != 'q' && (char)keyboard != 27 ){
   	  //read the current frame
   	  if(!capture.read(frame)) {
   	    cerr << "Unable to read next frame." << endl;
   	    cerr << "Exiting..." << endl;
   	    exit(EXIT_FAILURE);
   	  }

#. Every frame is used both for calculating the foreground mask and for updating the background. If you want to change the learning rate used for updating the background model, it is possible to set a specific learning rate by passing a third parameter to the 'apply' method.
   
   .. ref-code-block:: cpp
   
   	//update the background model
   	pMOG->apply(frame, fgMaskMOG);
   	pMOG2->apply(frame, fgMaskMOG2);

#. The current frame number can be extracted from the :ref:`cv::VideoCapture <doxid-df/dcb/classcv_1_1_video_capture>` object and stamped in the top left corner of the current frame. A white rectangle is used to highlight the black colored frame number.
   
   .. ref-code-block:: cpp
   
   	//get the frame number and write it on the current frame
   	stringstream ss;
   	:ref:`rectangle <doxid-d6/d6e/group__imgproc__draw_1ga07d2f74cadcf8e305e810ce8eed13bc9>`(frame, :ref:`cv::Point <doxid-d9/d87/classcv_1_1_point__>`(10, 2), :ref:`cv::Point <doxid-d9/d87/classcv_1_1_point__>`(100,20),
   	          :ref:`cv::Scalar <doxid-d7/d13/classcv_1_1_scalar__>`(255,255,255), -1);
   	ss << capture.get(:ref:`CAP_PROP_POS_FRAMES <doxid-d4/d15/group__videoio__flags__base_1ggaeb8dd9c89c10a5c63c139bf7c4f5704da6223452891755166a4fd5173ea257068>`);
   	string frameNumberString = ss.str();
   	:ref:`putText <doxid-d6/d6e/group__imgproc__draw_1ga5126f47f883d730f633d74f07456c576>`(frame, frameNumberString.c_str(), :ref:`cv::Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`(15, 15),
   	        :ref:`FONT_HERSHEY_SIMPLEX <doxid-d0/de1/group__core_1gga0f9314ea6e35f99bb23f29567fc16e11afff8b973668df2e4028dddc5274310c9>`, 0.5 , :ref:`cv::Scalar <doxid-dc/d84/group__core__basic_1ga599fe92e910c027be274233eccad7beb>`(0,0,0));

#. We are ready to show the current input frame and the results.
   
   .. ref-code-block:: cpp
   
   	//show the current frame and the fg masks
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("Frame", frame);
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("FG Mask MOG", fgMaskMOG);
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`("FG Mask MOG 2", fgMaskMOG2);

#. The same operations listed above can be performed using a sequence of images as input. The processImage function is called and, instead of using a :ref:`cv::VideoCapture <doxid-df/dcb/classcv_1_1_video_capture>` object, the images are read by using :ref:`cv::imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`, after individuating the correct path for the next frame to read.
   
   .. ref-code-block:: cpp
   
   	//read the first file of the sequence
   	frame = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`(fistFrameFilename);
   	if(!frame.data){
   	  //error in opening the first image
   	  cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
   	  exit(EXIT_FAILURE);
   	}
   	...
   	//search for the next image in the sequence
   	ostringstream oss;
   	oss << (frameNumber + 1);
   	string nextFrameNumberString = oss.str();
   	string nextFrameFilename = prefix + nextFrameNumberString + suffix;
   	//read the next frame
   	frame = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`(nextFrameFilename);
   	if(!frame.data){
   	  //error in opening the next image in the sequence
   	  cerr << "Unable to open image frame: " << nextFrameFilename << endl;
   	  exit(EXIT_FAILURE);
   	}
   	//update the path of the current frame
   	fn.assign(nextFrameFilename);
   
   Note that this example works only on image sequences in which the filename format is <n>.png, where n is the frame number (e.g., 7.png).

.. rubric:: Results

* Given the following input parameters:
  
  .. ref-code-block:: cpp
  
  	-vid Video_001.avi
  
  The output of the program will look as the following:
  
  .. image:: Background_Subtraction_Tutorial_Result_1.png

* The video file Video_001.avi is part of the `Background Models Challenge (BMC) <http://bmc.univ-bpclermont.fr/>`__ data set and it can be downloaded from the following link `Video_001 <http://bmc.univ-bpclermont.fr/sites/default/files/videos/evaluation/Video_001.zip>`__ (about 32 MB).

* If you want to process a sequence of images, then the '-img' option has to be chosen:
  
  .. ref-code-block:: cpp
  
  	-img 111_png/input/1.png
  
  The output of the program will look as the following:
  
  .. image:: Background_Subtraction_Tutorial_Result_2.png

* The sequence of images used in this example is part of the `Background Models Challenge (BMC) <http://bmc.univ-bpclermont.fr/>`__ dataset and it can be downloaded from the following link `sequence 111 <http://bmc.univ-bpclermont.fr/sites/default/files/videos/learning/111_png.zip>`__ (about 708 MB). Please, note that this example works only on sequences in which the filename format is <n>.png, where n is the frame number (e.g., 7.png).

.. rubric:: Evaluation

To quantitatively evaluate the results obtained, we need to:

* Save the output images;

* Have the ground truth images for the chosen sequence.

In order to save the output images, we can use :ref:`cv::imwrite <doxid-d4/da8/group__imgcodecs_1gabbc7ef1aa2edfaa87772f1202d67e0ce>`. Adding the following code allows for saving the foreground masks.

.. ref-code-block:: cpp

	string imageToSave = "output_MOG_" + frameNumberString + ".png";
	bool saved = :ref:`imwrite <doxid-d4/da8/group__imgcodecs_1gabbc7ef1aa2edfaa87772f1202d67e0ce>`(imageToSave, fgMaskMOG);
	if(!saved) {
	  cerr << "Unable to save " << imageToSave << endl;
	}

Once we have collected the result images, we can compare them with the ground truth data. There exist several publicly available sequences for background subtraction that come with ground truth data. If you decide to use the `Background Models Challenge (BMC) <http://bmc.univ-bpclermont.fr/>`__, then the result images can be used as input for the `BMC Wizard <http://bmc.univ-bpclermont.fr/?q=node/7>`__. The wizard can compute different measures about the accuracy of the results.

.. rubric:: References

* `Background Models Challenge (BMC) website <http://bmc.univ-bpclermont.fr/>`__

* A Benchmark Dataset for Foreground/Background Extraction :ref:`[85] <doxid-d0/de3/citelist_1CITEREF_vacavant2013benchmark>`

