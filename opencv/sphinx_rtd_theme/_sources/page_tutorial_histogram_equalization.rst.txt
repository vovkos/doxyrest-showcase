.. index:: pair: page; Histogram Equalization
.. _doxid-d4/d1b/tutorial_histogram_equalization:

Histogram Equalization
======================

.. rubric:: Goal

In this tutorial you will learn:

* What an image histogram is and why it is useful

* To equalize histograms of images by using the OpenCV function :ref:`cv::equalizeHist <doxid-d6/dc7/group__imgproc__hist_1ga7e54091f0c937d49bf84152a16f76d6e>`

.. rubric:: Theory

.. rubric:: What is an Image Histogram?

* It is a graphical representation of the intensity distribution of an image.

* It quantifies the number of pixels for each intensity value considered.

.. image:: Histogram_Equalization_Theory_0.jpg

.. rubric:: What is Histogram Equalization?

* It is a method that improves the contrast in an image, in order to stretch out the intensity range.

* To make it clearer, from the image above, you can see that the pixels seem clustered around the middle of the available range of intensities. What Histogram Equalization does is to *stretch out* this range. Take a look at the figure below: The green circles indicate the *underpopulated* intensities. After applying the equalization, we get an histogram like the figure in the center. The resulting image is shown in the picture at right.

.. image:: Histogram_Equalization_Theory_1.jpg

.. rubric:: How does it work?

* Equalization implies *mapping* one distribution (the given histogram) to another distribution (a wider and more uniform distribution of intensity values) so the intensity values are spreaded over the whole range.

* To accomplish the equalization effect, the remapping should be the *cumulative distribution function (cdf)* (more details, refer to *Learning OpenCV*). For the histogram :math:`H(i)`, its *cumulative distribution* :math:`H^{'}(i)` is:
  
  .. math::
  
  	H^{'}(i) = \sum_{0 \le j < i} H(j)
  
  To use this as a remapping function, we have to normalize :math:`H^{'}(i)` such that the maximum value is 255 ( or the maximum value for the intensity of the image ). From the example above, the cumulative function is:
  
  .. image:: Histogram_Equalization_Theory_2.jpg

* Finally, we use a simple remapping procedure to obtain the intensity values of the equalized image:
  
  .. math::
  
  	equalized( x, y ) = H^{'}( src(x,y) )

.. rubric:: Code

* **What does this program do?**
  
  * Loads an image
  
  * Convert the original image to grayscale
  
  * Equalize the Histogram by using the OpenCV function :ref:`cv::equalizeHist <doxid-d6/dc7/group__imgproc__hist_1ga7e54091f0c937d49bf84152a16f76d6e>`
  
  * Display the source and equalized images in a window.

* **Downloadable code** : Click `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/Histograms_Matching/EqualizeHist_Demo.cpp>`__

* **Code at glance:**
  
  .. ref-code-block:: cpp
  
  	
  	#include "opencv2/imgcodecs.hpp"
  	#include "opencv2/highgui.hpp"
  	#include "opencv2/imgproc.hpp"
  	#include <iostream>
  	
  	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
  	using namespace :ref:`std <doxid-d8/dcc/namespacestd>`;
  	
  	int main( int, char** argv )
  	{
  	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, dst;
  	
  	  const char* source_window = "Source image";
  	  const char* equalized_window = "Equalized Image";
  	
  	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` );
  	
  	  if( src.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`() )
  	    { cout<<"Usage: ./EqualizeHist_Demo <path_to_image>"<<endl;
  	      return -1;
  	    }
  	
  	  :ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );
  	
  	  :ref:`equalizeHist <doxid-d6/dc7/group__imgproc__hist_1ga7e54091f0c937d49bf84152a16f76d6e>`( src, dst );
  	
  	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( source_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
  	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( equalized_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
  	
  	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( source_window, src );
  	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( equalized_window, dst );
  	
  	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
  	
  	  return 0;
  	
  	}

.. rubric:: Explanation

#. Declare the source and destination images as well as the windows names:
   
   .. ref-code-block:: cpp
   
   	Mat src, dst;
   	
   	char* source_window = "Source image";
   	char* equalized_window = "Equalized Image";

#. Load the source image:
   
   .. ref-code-block:: cpp
   
   	src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], 1 );
   	
   	if( !src.data )
   	  { cout<<"Usage: ./Histogram_Demo <path_to_image>"<<endl;
   	    return -1;}

#. Convert it to grayscale:
   
   .. ref-code-block:: cpp
   
   	:ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );

#. Apply histogram equalization with the function :ref:`cv::equalizeHist <doxid-d6/dc7/group__imgproc__hist_1ga7e54091f0c937d49bf84152a16f76d6e>` :
   
   .. ref-code-block:: cpp
   
   	:ref:`equalizeHist <doxid-d6/dc7/group__imgproc__hist_1ga7e54091f0c937d49bf84152a16f76d6e>`( src, dst );
   
   As it can be easily seen, the only arguments are the original image and the output (equalized) image.

#. Display both images (original and equalized) :
   
   .. ref-code-block:: cpp
   
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( source_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( equalized_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( source_window, src );
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( equalized_window, dst );

#. Wait until user exists the program
   
   .. ref-code-block:: cpp
   
   	:ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
   	return 0;

.. rubric:: Results

#. To appreciate better the results of equalization, let's introduce an image with not much contrast, such as:
   
   .. image:: Histogram_Equalization_Original_Image.jpg
   
   which, by the way, has this histogram:
   
   .. image:: Histogram_Equalization_Original_Histogram.jpg
   
   notice that the pixels are clustered around the center of the histogram.

#. After applying the equalization with our program, we get this result:
   
   .. image:: Histogram_Equalization_Equalized_Image.jpg
   
   this image has certainly more contrast. Check out its new histogram like this:
   
   .. image:: Histogram_Equalization_Equalized_Histogram.jpg
   
   Notice how the number of pixels is more distributed through the intensity range.

Are you wondering how did we draw the Histogram figures shown above? Check out the following tutorial!

