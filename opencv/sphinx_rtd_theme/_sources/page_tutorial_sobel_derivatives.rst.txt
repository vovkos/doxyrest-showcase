.. index:: pair: page; Sobel Derivatives
.. _doxid-d2/d2c/tutorial_sobel_derivatives:

Sobel Derivatives
=================

.. rubric:: Goal

In this tutorial you will learn how to:

* Use the OpenCV function :ref:`cv::Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>` to calculate the derivatives from an image.

* Use the OpenCV function :ref:`cv::Scharr <doxid-d4/d86/group__imgproc__filter_1gaa13106761eedf14798f37aa2d60404c9>` to calculate a more accurate derivative for a kernel of size :math:`3 \cdot 3`

.. rubric:: Theory

The explanation below belongs to the book **Learning OpenCV** by Bradski and Kaehler.



#. In the last two tutorials we have seen applicative examples of convolutions. One of the most important convolutions is the computation of derivatives in an image (or an approximation to them).

#. Why may be important the calculus of the derivatives in an image? Let's imagine we want to detect the *edges* present in the image. For instance:
   
   .. image:: Sobel_Derivatives_Tutorial_Theory_0.jpg
   
   You can easily notice that in an *edge*, the pixel intensity *changes* in a notorious way. A good way to express *changes* is by using *derivatives*. A high change in gradient indicates a major change in the image.

#. To be more graphical, let's assume we have a 1D-image. An edge is shown by the "jump" in intensity in the plot below:
   
   .. image:: Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg

#. The edge "jump" can be seen more easily if we take the first derivative (actually, here appears as a maximum)
   
   .. image:: Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg

#. So, from the explanation above, we can deduce that a method to detect edges in an image can be performed by locating pixel locations where the gradient is higher than its neighbors (or to generalize, higher than a threshold).

#. More detailed explanation, please refer to **Learning OpenCV** by Bradski and Kaehler

.. rubric:: Sobel Operator

#. The Sobel Operator is a discrete differentiation operator. It computes an approximation of the gradient of an image intensity function.

#. The Sobel Operator combines Gaussian smoothing and differentiation.

.. rubric:: Formulation

Assuming that the image to be operated is :math:`I` :

#. We calculate two derivatives:
   
   #. **Horizontal changes** : This is computed by convolving :math:`I` with a kernel :math:`G_{x}` with odd size. For example for a kernel size of 3, :math:`G_{x}` would be computed as:
   
   .. math::
   
   	G_{x} = \begin{bmatrix} -1 & 0 & +1 \\ -2 & 0 & +2 \\ -1 & 0 & +1 \end{bmatrix} * I
   
   
   
   #. **Vertical changes** : This is computed by convolving :math:`I` with a kernel :math:`G_{y}` with odd size. For example for a kernel size of 3, :math:`G_{y}` would be computed as:
   
   .. math::
   
   	G_{y} = \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ +1 & +2 & +1 \end{bmatrix} * I

#. At each point of the image we calculate an approximation of the *gradient* in that point by combining both results above:
   
   .. math::
   
   	G = \sqrt{ G_{x}^{2} + G_{y}^{2} }
   
   Although sometimes the following simpler equation is used:
   
   .. math::
   
   	G = |G_{x}| + |G_{y}|

When the size of the kernel is ``3``, the Sobel kernel shown above may produce noticeable inaccuracies (after all, Sobel is only an approximation of the derivative). OpenCV addresses this inaccuracy for kernels of size 3 by using the :ref:`cv::Scharr <doxid-d4/d86/group__imgproc__filter_1gaa13106761eedf14798f37aa2d60404c9>` function. This is as fast but more accurate than the standar Sobel function. It implements the following kernels:

.. math::

	G_{x} = \begin{bmatrix} -3 & 0 & +3 \\ -10 & 0 & +10 \\ -3 & 0 & +3 \end{bmatrix}



.. math::

	G_{y} = \begin{bmatrix} -3 & -10 & -3 \\ 0 & 0 & 0 \\ +3 & +10 & +3 \end{bmatrix}

You can check out more information of this function in the OpenCV reference (:ref:`cv::Scharr <doxid-d4/d86/group__imgproc__filter_1gaa13106761eedf14798f37aa2d60404c9>`). Also, in the sample code below, you will notice that above the code for :ref:`cv::Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>` function there is also code for the :ref:`cv::Scharr <doxid-d4/d86/group__imgproc__filter_1gaa13106761eedf14798f37aa2d60404c9>` function commented. Uncommenting it (and obviously commenting the Sobel stuff) should give you an idea of how this function works.



.. rubric:: Code

#. **What does this program do?**
   
   * Applies the *Sobel Operator* and generates as output an image with the detected *edges* bright on a darker background.

#. The tutorial code's is shown lines below. You can also download it from `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/ImgTrans/Sobel_Demo.cpp>`__
   
   .. ref-code-block:: cpp
   
   	
   	#include "opencv2/imgproc.hpp"
   	#include "opencv2/imgcodecs.hpp"
   	#include "opencv2/highgui.hpp"
   	
   	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
   	
   	int main( int, char** argv )
   	{
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, src_gray;
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` grad;
   	  const char* window_name = "Sobel Demo - Simple Edge Detector";
   	  int scale = 1;
   	  int delta = 0;
   	  int ddepth = :ref:`CV_16S <doxid-d1/d1b/group__core__hal__interface_1ga9d2ee1a8334733dea7482a47a88e0f87>`;
   	
   	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` ); // Load an image
   	
   	  if( src.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`() )
   	    { return -1; }
   	
   	  :ref:`GaussianBlur <doxid-d4/d86/group__imgproc__filter_1gaabe8c836e97159a9193fb0b11ac52cf1>`( src, src, :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`(3,3), 0, 0, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   	
   	  :ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src_gray, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );
   	
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` grad_x, grad_y;
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` abs_grad_x, abs_grad_y;
   	
   	  //Scharr( src_gray, grad_x, ddepth, 1, 0, scale, delta, BORDER_DEFAULT );
   	  :ref:`Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>`( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   	
   	  //Scharr( src_gray, grad_y, ddepth, 0, 1, scale, delta, BORDER_DEFAULT );
   	  :ref:`Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>`( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   	
   	  :ref:`convertScaleAbs <doxid-d2/de8/group__core__array_1ga3460e9c9f37b563ab9dd550c4d8c4e7d>`( grad_x, abs_grad_x );
   	  :ref:`convertScaleAbs <doxid-d2/de8/group__core__array_1ga3460e9c9f37b563ab9dd550c4d8c4e7d>`( grad_y, abs_grad_y );
   	
   	  :ref:`addWeighted <doxid-d2/de8/group__core__array_1gafafb2513349db3bcff51f54ee5592a19>`( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );
   	
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( window_name, grad );
   	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
   	
   	  return 0;
   	}

.. rubric:: Explanation

#. First we declare the variables we are going to use:
   
   .. ref-code-block:: cpp
   
   	Mat src, src_gray;
   	Mat grad;
   	const char* window_name = "Sobel Demo - Simple Edge Detector";
   	int scale = 1;
   	int delta = 0;
   	int ddepth = :ref:`CV_16S <doxid-d1/d1b/group__core__hal__interface_1ga9d2ee1a8334733dea7482a47a88e0f87>`;

#. As usual we load our source image *src* :
   
   .. ref-code-block:: cpp
   
   	src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` ); // Load an image
   
   	if( src.empty() )
   	  { return -1; }

#. First, we apply a :ref:`cv::GaussianBlur <doxid-d4/d86/group__imgproc__filter_1gaabe8c836e97159a9193fb0b11ac52cf1>` to our image to reduce the noise ( kernel size = 3 )
   
   .. ref-code-block:: cpp
   
   	:ref:`GaussianBlur <doxid-d4/d86/group__imgproc__filter_1gaabe8c836e97159a9193fb0b11ac52cf1>`( src, src, :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`(3,3), 0, 0, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );

#. Now we convert our filtered image to grayscale:
   
   .. ref-code-block:: cpp
   
   	:ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src_gray, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );

#. Second, we calculate the "\*derivatives\*" in *x* and *y* directions. For this, we use the function :ref:`cv::Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>` as shown below:
   
   .. ref-code-block:: cpp
   
   	Mat grad_x, grad_y;
   	Mat abs_grad_x, abs_grad_y;
   
   	//Scharr( src_gray, grad_x, ddepth, 1, 0, scale, delta, BORDER_DEFAULT );
   	:ref:`Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>`( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   
   	//Scharr( src_gray, grad_y, ddepth, 0, 1, scale, delta, BORDER_DEFAULT );
   	:ref:`Sobel <doxid-d4/d86/group__imgproc__filter_1gacea54f142e81b6758cb6f375ce782c8d>`( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   
   The function takes the following arguments:
   
   * *src_gray* : In our example, the input image. Here it is *CV_8U*
   
   * *grad_x* /\*grad_y\*: The output image.
   
   * *ddepth* : The depth of the output image. We set it to *CV_16S* to avoid overflow.
   
   * *x_order* : The order of the derivative in **x** direction.
   
   * *y_order* : The order of the derivative in **y** direction.
   
   * *scale*, *delta* and *BORDER_DEFAULT* : We use default values.
   
   Notice that to calculate the gradient in *x* direction we use: :math:`x_{order}= 1` and :math:`y_{order} = 0`. We do analogously for the *y* direction.

#. We convert our partial results back to *CV_8U* :
   
   .. ref-code-block:: cpp
   
   	:ref:`convertScaleAbs <doxid-d2/de8/group__core__array_1ga3460e9c9f37b563ab9dd550c4d8c4e7d>`( grad_x, abs_grad_x );
   	:ref:`convertScaleAbs <doxid-d2/de8/group__core__array_1ga3460e9c9f37b563ab9dd550c4d8c4e7d>`( grad_y, abs_grad_y );

#. Finally, we try to approximate the *gradient* by adding both directional gradients (note that this is not an exact calculation at all! but it is good for our purposes).
   
   .. ref-code-block:: cpp
   
   	:ref:`addWeighted <doxid-d2/de8/group__core__array_1gafafb2513349db3bcff51f54ee5592a19>`( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );

#. Finally, we show our result:
   
   .. ref-code-block:: cpp
   
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( window_name, grad );
   	:ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
   
   
   
   .. rubric:: Results

#. Here is the output of applying our basic detector to *lena.jpg* :
   
   .. image:: Sobel_Derivatives_Tutorial_Result.jpg

