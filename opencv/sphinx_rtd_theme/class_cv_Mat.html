

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>class cv::Mat &mdash; OpenCV Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/target-highlight.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/doxyrest-pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/doxyrest-sphinx_rtd_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="class cv::MatAllocator" href="class_cv_MatAllocator.html" />
    <link rel="prev" title="class cv::KeyPoint" href="class_cv_KeyPoint.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> OpenCV Documentation
          

          
          </a>

          
            
            
              <div class="version">
                3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="group_features2d.html">2D Features Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_viz.html">3D Visualizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_calib3d.html">Camera Calibration and 3D Reconstruction</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_flann.html">Clustering and Search in Multi-Dimensional Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_photo.html">Computational Photography</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="group_core.html">Core functionality</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="group_core_basic.html">Basic structures</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="enum_cv_UMatUsageFlags.html">enum cv::UMatUsageFlags</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_MatSize.html">struct cv::MatSize</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_MatStep.html">struct cv::MatStep</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_Param.html">struct cv::Param</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType.html">template struct cv::ParamType&lt;uchar&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-2.html">template struct cv::ParamType&lt;uint64&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-3.html">template struct cv::ParamType&lt;unsigned&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-4.html">template struct cv::ParamType&lt;String&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-5.html">template struct cv::ParamType&lt;std::vector&lt;Mat&gt;&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-6.html">template struct cv::ParamType&lt;Mat&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-7.html">template struct cv::ParamType&lt;float&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-8.html">template struct cv::ParamType</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-9.html">template struct cv::ParamType&lt;bool&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-10.html">template struct cv::ParamType&lt;Algorithm&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_ParamType-11.html">template struct cv::ParamType&lt;double&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_Ptr.html">template struct cv::Ptr</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_UMatData.html">struct cv::UMatData</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct_cv_UMatDataAutoLock.html">struct cv::UMatDataAutoLock</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Algorithm.html">class cv::Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Complex.html">template class cv::Complex</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_DMatch.html">class cv::DMatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_DataDepth.html">template class cv::DataDepth</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_DataType.html">template class cv::DataType</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Formatted.html">class cv::Formatted</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Formatter.html">class cv::Formatter</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_KeyPoint.html">class cv::KeyPoint</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">class cv::Mat</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#detailed-documentation">Detailed Documentation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatAllocator.html">class cv::MatAllocator</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatCommaInitializer_.html">template class cv::MatCommaInitializer_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatConstIterator.html">class cv::MatConstIterator</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatConstIterator_.html">template class cv::MatConstIterator_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatExpr.html">class cv::MatExpr</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatIterator_.html">template class cv::MatIterator_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatOp.html">class cv::MatOp</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Mat_.html">template class cv::Mat_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Matx.html">template class cv::Matx</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_MatxCommaInitializer.html">template class cv::MatxCommaInitializer</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_NAryMatIterator.html">class cv::NAryMatIterator</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Point3_.html">template class cv::Point3_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Point_.html">template class cv::Point_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Range.html">class cv::Range</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Rect_.html">template class cv::Rect_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_RotatedRect.html">class cv::RotatedRect</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Scalar_.html">template class cv::Scalar_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Size_.html">template class cv::Size_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_SparseMat.html">class cv::SparseMat</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_SparseMatConstIterator.html">class cv::SparseMatConstIterator</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_SparseMatConstIterator_.html">template class cv::SparseMatConstIterator_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_SparseMatIterator.html">class cv::SparseMatIterator</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_SparseMatIterator_.html">template class cv::SparseMatIterator_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_SparseMat_.html">template class cv::SparseMat_</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_String.html">class cv::String</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TermCriteria.html">class cv::TermCriteria</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth.html">template class cv::TypeDepth&lt;CV_16U&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-2.html">template class cv::TypeDepth&lt;CV_32F&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-3.html">template class cv::TypeDepth&lt;CV_32S&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-4.html">template class cv::TypeDepth&lt;CV_16S&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-5.html">template class cv::TypeDepth&lt;CV_64F&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-6.html">template class cv::TypeDepth&lt;CV_8U&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-7.html">template class cv::TypeDepth</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_TypeDepth-8.html">template class cv::TypeDepth&lt;CV_8S&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_UMat.html">class cv::UMat</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_Vec.html">template class cv::Vec</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv_VecCommaInitializer.html">template class cv::VecCommaInitializer</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv__InputArray.html">class cv::_InputArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv__InputOutputArray.html">class cv::_InputOutputArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="class_cv__OutputArray.html">class cv::_OutputArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="group_core_basic.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="group_core_basic.html#detailed-documentation">Detailed Documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="group_core_c.html">C structures and operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_cluster.html">Clustering</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_directx.html">DirectX interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_eigen.html">Eigen support</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_hal.html">Hardware Acceleration Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_ipp.html">Intel IPP Asynchronous C/C++ Converters</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_va_intel.html">Intel VA-API/OpenCL (CL-VA) interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_opencl.html">OpenCL support</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_opengl.html">OpenGL interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_array.html">Operations on arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_optim.html">Optimization Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_utils.html">Utility and system functions and macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core_xml.html">XML/YAML Persistence</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_cv_CovarFlags.html">enum cv::CovarFlags</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_cv_HersheyFonts.html">enum cv::HersheyFonts</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_cv_KmeansFlags.html">enum cv::KmeansFlags</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_cv_LineTypes.html">enum cv::LineTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum_cv_ReduceTypes.html">enum cv::ReduceTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_Affine3.html">template class cv::Affine3</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_BufferPoolController.html">class cv::BufferPoolController</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_WImage.html">template class cv::WImage</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_WImageBuffer.html">template class cv::WImageBuffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_WImageBufferC.html">template class cv::WImageBufferC</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_WImageC.html">template class cv::WImageC</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_WImageView.html">template class cv::WImageView</a></li>
<li class="toctree-l2"><a class="reference internal" href="class_cv_WImageViewC.html">template class cv::WImageViewC</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="group_core.html#detailed-documentation">Detailed Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="group_highgui.html">High-level GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_imgcodecs.html">Image file reading and writing</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_imgproc.html">Image processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_stitching.html">Images stitching</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_ml.html">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_objdetect.html">Object Detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_shape.html">Shape Distance and Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_superres.html">Super Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_video.html">Video Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_videoio.html">Video I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_videostab.html">Video Stabilization</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="page_citelist.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_cuda_intro.html">CUDA Module Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_imgproc_color_conversions.html">Color conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_deprecated.html">Deprecated List</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_ml_intro.html">Machine Learning Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_tutorial_root.html">OpenCV Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_index.html">OpenCV modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_tutorial_py_root.html">OpenCV-Python Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_todo.html">Todo List</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_videoio_overview.html">Video I/O with OpenCV Overview</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_contours2.cpp.html">contours2.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_convexhull.cpp.html">convexhull.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_cout_mat.cpp.html">cout_mat.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_demhist.cpp.html">demhist.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_distrans.cpp.html">distrans.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_edge.cpp.html">edge.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_ffilldemo.cpp.html">ffilldemo.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_filestorage.cpp.html">filestorage.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_fitellipse.cpp.html">fitellipse.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_grabcut.cpp.html">grabcut.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_houghcircles.cpp.html">houghcircles.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_houghlines.cpp.html">houghlines.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_kmeans.cpp.html">kmeans.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_laplace.cpp.html">laplace.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_lsd_lines.cpp.html">lsd_lines.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_minarea.cpp.html">minarea.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_morphology2.cpp.html">morphology2.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_pca.cpp.html">pca.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_polar_transforms.cpp.html">polar_transforms.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_segment_objects.cpp.html">segment_objects.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_watershed.cpp.html">watershed.cpp</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="global.html">Global Namespace</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">OpenCV Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="group_core.html">Core functionality</a> &raquo;</li>
        
          <li><a href="group_core_basic.html">Basic structures</a> &raquo;</li>
        
      <li>class cv::Mat</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="class-cv-mat">
<span id="doxid-db-de6-classcv-1-1-mat"></span><span id="index-0"></span><h1>class cv::Mat</h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h2>Overview</h2>
<p>n-dimensional dense array class <a class="reference internal" href="#details-db-de6-classcv-1-1-mat"><span class="std std-ref">Moreâ€¦</span></a></p>
<pre class="highlight doxyrest-overview-code-block literal-block">
<span></span><span class="cp">#include</span> <span class="cpf">&lt;mat.hpp&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// enums</span>

    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a2082a2faa4b65dedcc5b84433c97f817">MAGIC_VAL</span><span></span>       <span class="o">=</span> <span class="mh">0x42FF0000</span><span class="p">,</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a1c147538fd896f4f9abce9eaea9727e3">AUTO_STEP</span><span></span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a3a50403178ba15a9617f5ff341418cf9">CONTINUOUS_FLAG</span><span></span> <span class="o">=</span> <span class="n">CV_MAT_CONT_FLAG</span><span class="p">,</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a1db725f4a7efd16a41581b4fc54e7aad">SUBMATRIX_FLAG</span><span></span>  <span class="o">=</span> <span class="n">CV_SUBMAT_FLAG</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a87050bff8776162f834f850b86081a57a1b2031796886cd80edd90640bc17fb50">MAGIC_MASK</span><span></span> <span class="o">=</span> <span class="mh">0xFFFF0000</span><span class="p">,</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a87050bff8776162f834f850b86081a57a03b3e6a1defa1189b67c9f3d70b7c448">TYPE_MASK</span><span></span>  <span class="o">=</span> <span class="mh">0x00000FFF</span><span class="p">,</span>
        <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a87050bff8776162f834f850b86081a57a1454580da17d20c8ec5917170dc3da3a">DEPTH_MASK</span><span></span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// fields</span>

    <a class="reference internal" href="class_cv_MatAllocator.html#doxid-d4-dee-classcv-1-1-mat-allocator"><span class="std std-ref">MatAllocator</span></a><span></span><span class="o">*</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4d2eb7a536cd5a0f18808b6112111d6a"><span class="std std-ref">allocator</span></a><span></span><span class="p">;</span>
    <span class="kt">int</span> <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1aa3e5a47585c9ef6a0842556739155e3e">cols</span><span></span><span class="p">;</span>
    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4d33bed1c850265370d2af0ff02e1564"><span class="std std-ref">data</span></a><span></span><span class="p">;</span>
    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1ae756e84c94cbcf4c152ed0e67edb71ca">dataend</span><span></span><span class="p">;</span>
    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a21a0a0eb9814f0093452601fcbdc8a46">datalimit</span><span></span><span class="p">;</span>
    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aeda6d607bfc629a95f59e7b538832172"><span class="std std-ref">datastart</span></a><span></span><span class="p">;</span>
    <span class="kt">int</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a39cf614aa52567e9a945cd2609bd767b"><span class="std std-ref">dims</span></a><span></span><span class="p">;</span>
    <span class="kt">int</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af9333f06c84f115fda4cdf3af18c2ad0"><span class="std std-ref">flags</span></a><span></span><span class="p">;</span>
    <span class="kt">int</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abed816466c45234254d25bc59c31245e"><span class="std std-ref">rows</span></a><span></span><span class="p">;</span>
    <a class="reference internal" href="struct_cv_MatSize.html#doxid-d3-d31-structcv-1-1-mat-size"><span class="std std-ref">MatSize</span></a><span></span> <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a146f8e8dda07d1365a575ab83d9828d1">size</span><span></span><span class="p">;</span>
    <a class="reference internal" href="struct_cv_MatStep.html#doxid-dc-d72-structcv-1-1-mat-step"><span class="std std-ref">MatStep</span></a><span></span> <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1ab4b0843e64328eb2a026b5b9ede726fe">step</span><span></span><span class="p">;</span>
    <a class="reference internal" href="struct_cv_UMatData.html#doxid-dd-d13-structcv-1-1-u-mat-data"><span class="std std-ref">UMatData</span></a><span></span><span class="o">*</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2742469fe595e1b9036f60d752d08461"><span class="std std-ref">u</span></a><span></span><span class="p">;</span>

    <span class="c1">// construction</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af1d014cecd1510cdf580bf2ed7e5aafc"><span class="std std-ref">Mat</span></a><span></span><span class="p">();</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2ec3402f7d165ca34c7fd6e8498a62ca"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a75a97b1e4e55f380c172af58048a7cde"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a3620c370690b5ca4d40c767be6fb4ceb"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a286371a6196eaaaf0b86e158590460b7"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a156df5a1326dd5c30b187b0e721a5f57"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a6adc4d64db5379bcbb713e71c9292f6e"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1afbf34be80b7443123b2a032a67c3c4e3"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad20a78b5501fc39543a240142a40e234"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a294eaf8a95d2f9c7be19ff594d06278e"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a51615ebf17a64c968df0bf49b4de6a3a"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
        <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">step</span> <span class="o">=</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a1c147538fd896f4f9abce9eaea9727e3"><span class="std std-ref">AUTO_STEP</span></a><span></span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9fa74fb14362d87cb183453d2441948f"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
        <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">step</span> <span class="o">=</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a1c147538fd896f4f9abce9eaea9727e3"><span class="std std-ref">AUTO_STEP</span></a><span></span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a5fafc033e089143062fd31015b5d0f40"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span><span class="o">*</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a922de793eabcec705b3579c5f95a643e"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span><span class="o">*</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a92a3e9e5911a2eb0cf0950a0a9670c76"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">rowRange</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">colRange</span> <span class="o">=</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref">Range::all</span></a><span></span><span class="p">()</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa7ec97373406215f2d4bc72cc1d27036"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga11d95de507098e90bad732b9345402e8"><span class="std std-ref">Rect</span></a><span></span><span class="o">&amp;</span> <span class="n">roi</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1afde22a742fc73c0a150a9002310ac2eb"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">*</span> <span class="n">ranges</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa6e903a6c762478692791a33d233019b"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&gt;&amp;</span> <span class="n">ranges</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23b182c4ffd46abe38f460c1480ae887"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">false</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a507e01fb48b34a3e5c45f9f5b00725e8"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a37068a8d9acc7cc5af817eb82b2aa83b"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Matx.html#doxid-db-d15-classcv-1-1-matx"><span class="std std-ref">Matx</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">mtx</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a224477889ddc7424aaab1b76e7682ea2"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Point_.html#doxid-d9-d87-classcv-1-1-point"><span class="std std-ref">Point_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a7d72610ed5aed9117eb7933a97670309"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <a class="reference internal" href="class_cv_Point3_.html#doxid-d4-d29-classcv-1-1-point3"><span class="std std-ref">Point3_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23957ae2fed348c67952c0d69c873972"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_MatCommaInitializer_.html#doxid-d7-dfc-classcv-1-1-mat-comma-initializer"><span class="std std-ref">MatCommaInitializer_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">commaInitializer</span><span class="p">);</span>

    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa82eca82664985c81c7912b04549370d"><span class="std std-ref">Mat</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_cuda_GpuMat.html#doxid-d5-da3-classcv-1-1cuda-1-1-gpu-mat"><span class="std std-ref">cuda::GpuMat</span></a><span></span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <span class="c1">// methods</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9d3794250e3dc39714f980b4d0d45864"><span class="std std-ref">addref</span></a><span></span><span class="p">();</span>

    <span class="n">Mat</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2fece3507ee7e1284deee6da99e76b9b"><span class="std std-ref">adjustROI</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">dtop</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">dbottom</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">dleft</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">dright</span>
        <span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa8b3b4d7b9876a4726740b75daa98ddb"><span class="std std-ref">assignTo</span></a><span></span><span class="p">(</span>
        <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a330d9adb78976b6efd4116c940924294"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ac40425b84f60b39fd35e03814122661f"><span class="std std-ref">at</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">col</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a5db6b18954e334048cb35752f49c6f8c"><span class="std std-ref">at</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">col</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a305829ed5c0ecfef7b44db18953048e8"><span class="std std-ref">at</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i2</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a59c6c2d9db1cfba76d75addeeb4e6a84"><span class="std std-ref">at</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i2</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a474bd5cdcf986672cfdc304f6be1cf64"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2cbbb16670ae4d9aa747f19c24305213"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9ec1aadc17ab8c8f8334d521719c7732"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a15c649a94cf2e06240b32b025231301f"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23cd599a27c59bae64b0c40ad645ea49"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga1e83eafb2d26b3c93f09e8338bcab192"><span class="std std-ref">Point</span></a><span></span> <span class="n">pt</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a87d0b2e01b0f8686957398ecfb168a6d"><span class="std std-ref">at</span></a><span></span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga1e83eafb2d26b3c93f09e8338bcab192"><span class="std std-ref">Point</span></a><span></span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="class_cv_MatIterator_.html#doxid-da-d1f-classcv-1-1-mat-iterator"><span class="std std-ref">MatIterator_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a33ee3bc402827f587a5ad64b568d6986"><span class="std std-ref">begin</span></a><span></span><span class="p">();</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="class_cv_MatConstIterator_.html#doxid-db-dbf-classcv-1-1-mat-const-iterator"><span class="std std-ref">MatConstIterator_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1aef8f88bc1f72757b0f2ddb3041611c73">begin</span><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa11336b9ac538e0475d840657ce164be"><span class="std std-ref">channels</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a167a8e0a3a3d86e84b70e33483af4466"><span class="std std-ref">checkVector</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">elemChannels</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">requireContinuous</span> <span class="o">=</span> <span class="nb">true</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">clone</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">col</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aadc8f9210fe4dec50513746c246fa8d9"><span class="std std-ref">colRange</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">startcol</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">endcol</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1acccb63e44eba6ba81ead99881bd1997e"><span class="std std-ref">colRange</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1adf88c60c5b4980e05bb556080916978b"><span class="std std-ref">convertTo</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gaad17fda1d0f0d1ee069aebb1df2913c0"><span class="std std-ref">OutputArray</span></a><span></span> <span class="n">m</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">rtype</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">beta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a39fd9880fc55b7a0993bcfff88061ac4"><span class="std std-ref">copySize</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a33fd5d125b4c302b0c9aa86980791a77"><span class="std std-ref">copyTo</span></a><span></span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gaad17fda1d0f0d1ee069aebb1df2913c0"><span class="std std-ref">OutputArray</span></a><span></span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a626fe5f96d02525e2604d2ad46dd574f"><span class="std std-ref">copyTo</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gaad17fda1d0f0d1ee069aebb1df2913c0"><span class="std std-ref">OutputArray</span></a><span></span> <span class="n">m</span><span class="p">,</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">mask</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">create</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a48409946d0e1bebb40fe765e18ec5eea"><span class="std std-ref">create</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aee53524ac61fa2ba441c4f29c3aca93f"><span class="std std-ref">create</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a84f35d3923a92251631329eed66d2a12"><span class="std std-ref">create</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a708b761e0d15b7b8db4c8e8c95a7abe9"><span class="std std-ref">cross</span></a><span></span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ac6e9cdf9b450e360f005978b4e981b1a"><span class="std std-ref">deallocate</span></a><span></span><span class="p">();</span>

    <span class="kt">int</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a8da9f853b6f3a29d738572fd1ffc44c0"><span class="std std-ref">depth</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a024cc0510a4c61c7f266d4ab9fe13d7a"><span class="std std-ref">diag</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">double</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0f683eab191eeece33dfc64ae299a9cb"><span class="std std-ref">dot</span></a><span></span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aba7a5ef00b22b70668fba575005dfe55"><span class="std std-ref">elemSize</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9acde8f32d4b294558fb406bc05171bc"><span class="std std-ref">elemSize1</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abbec3525a852e77998aba034813fded4"><span class="std std-ref">empty</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="class_cv_MatIterator_.html#doxid-da-d1f-classcv-1-1-mat-iterator"><span class="std std-ref">MatIterator_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9dd628eeccedea6e181ca54d41830a62"><span class="std std-ref">end</span></a><span></span><span class="p">();</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <a class="reference internal" href="class_cv_MatConstIterator_.html#doxid-db-dbf-classcv-1-1-mat-const-iterator"><span class="std std-ref">MatConstIterator_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a092f54359c99e42729715024fc662182">end</span><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">Functor</span>
        <span class="o">&gt;</span>
    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a952ef1a85d70a510240cb645a90efc0d"><span class="std std-ref">forEach</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">Functor</span>
        <span class="o">&gt;</span>
    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1afcee31e71fd6991148fd3bb619971e2b"><span class="std std-ref">forEach</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="class_cv_UMat.html#doxid-d8-d82-classcv-1-1-u-mat"><span class="std std-ref">UMat</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a8676ddda9951ec3766efe0265d808a71"><span class="std std-ref">getUMat</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">accessFlags</span><span class="p">,</span>
        <a class="reference internal" href="enum_cv_UMatUsageFlags.html#doxid-dc-d84-group-core-basic-1ga5681439dda418431eb0a672697135ed2"><span class="std std-ref">UMatUsageFlags</span></a><span></span> <span class="n">usageFlags</span> <span class="o">=</span> <a class="reference internal" href="enum_cv_UMatUsageFlags.html#doxid-dc-d84-group-core-basic-1gga5681439dda418431eb0a672697135ed2ae383b08ee18b73d8c1588d968f953893"><span class="std std-ref">USAGE_DEFAULT</span></a><span></span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a039eb3c6740a850696a12519a4b8bfc6"><span class="std std-ref">inv</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">method</span> <span class="o">=</span> <a class="reference internal" href="enum_cv_DecompTypes.html#doxid-d2-de8-group-core-array-1ggaaf9ea5dcc392d5ae04eacb9920b9674ca247a3455cd64973152e17e26999dc024"><span class="std std-ref">DECOMP_LU</span></a><span></span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa90cea495029c7d1ee0a41361ccecdf3"><span class="std std-ref">isContinuous</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ab34367822008627e80e144d7bba3bd70"><span class="std std-ref">isSubmatrix</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a40b5b3371a9c2a4b2b8ce0c8068d7c96"><span class="std std-ref">locateROI</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span><span class="o">&amp;</span> <span class="n">wholeSize</span><span class="p">,</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga1e83eafb2d26b3c93f09e8338bcab192"><span class="std std-ref">Point</span></a><span></span><span class="o">&amp;</span> <span class="n">ofs</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a385c09827713dc3e6d713bfad8460706"><span class="std std-ref">mul</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">m</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a75b1b5424cf014f00d8f06ba1818a5d8">operator Matx&lt; _Tp, m, n &gt;</span><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a5d043937e7a4cad632397a9dd8dfee2e">operator std::vector&lt; _Tp &gt;</span><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1ae4766cf75071f4e4db698c4120abe57b">operator Vec&lt; _Tp, n &gt;</span><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad543b6bd296ae1247032c750af4718e1"><span class="std std-ref">operator()</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span> <span class="n">rowRange</span><span class="p">,</span>
        <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span> <span class="n">colRange</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4272fce43d7405603fbb5e5f52580e57"><span class="std std-ref">operator()</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga11d95de507098e90bad732b9345402e8"><span class="std std-ref">Rect</span></a><span></span><span class="o">&amp;</span> <span class="n">roi</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aee56475f834069b1fad3877c0747aaeb"><span class="std std-ref">operator()</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">*</span> <span class="n">ranges</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa9bf4fcbb6e854a6db7b7254a205fac9"><span class="std std-ref">operator()</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&gt;&amp;</span> <span class="n">ranges</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aed1f81fe7efaacc2bd95149cdfa34302"><span class="std std-ref">operator=</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <span class="n">Mat</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2a0798475170fb3a23b5bc63686de334"><span class="std std-ref">operator=</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span><span class="o">&amp;</span> <span class="n">expr</span><span class="p">);</span>

    <span class="n">Mat</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50"><span class="std std-ref">operator=</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a88bbb01901fdfe3f1d0592c592e8757c"><span class="std std-ref">pop_back</span></a><span></span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">nelems</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a13acd320291229615ef15f96ff1ff738"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af13f821918f452657f53bc3f750323cb"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af774caab4a38c6f7890f3254ad71eccf"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">col</span>
        <span class="p">);</span>

    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abcfcc1798528b49495e1263eab31127d"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">col</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad2bc0c6a23243540e16607868c17be92"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i2</span>
        <span class="p">);</span>

    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abfb233ffa8b26a78c36e733f61da2a3e"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i2</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ab0e3de187bb27c384269b243e8789ba9"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a3ef72b9ebc9581796ed68382df8fb064"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a7ce1d8cc9a83ae7cab79766d0eb6c0a8"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
    <span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9ea1a1bfbbb2393a4e162230dccbe1f0"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a5a9ffc908ac90604f36a8b6a1038747d"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a6a6b3696440fe48751bfe60fe2a729f3"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a6f4278ede80e7a9fe55d8b03710e2343"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">col</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abda2b96aa438a808b43425040a7da81a"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">col</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2bf43f93c5cb610b657bd6e0e091c062"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i2</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a476f18d2b8d99748005150b24752512d"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">i2</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a7cb2719706bcae72d26dbc9b2fdc02e6"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ac30da0a78cd38a72e8902f52660e2543"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a36ab9a1de78fd00a4f9acf3c8a5d4d05"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">n</span>
        <span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a15cac608c7a27fb961a81b9409aaa7e8"><span class="std std-ref">ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af4bd5c2cb936dd363816d867aab22a61"><span class="std std-ref">push_back</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a1cfeb3a75570697426971403fc1ddb0d"><span class="std std-ref">push_back</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Mat_.html#doxid-d9-de0-classcv-1-1-mat"><span class="std std-ref">Mat_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">elem</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a3676bae1741459eda3771e8653357c53"><span class="std std-ref">push_back</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a57c658e2a97dda24fef1be2e625da914"><span class="std std-ref">push_back_</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">elem</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ae48d4913285518e2c21a3457017e716e"><span class="std std-ref">release</span></a><span></span><span class="p">();</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0706ed6c42e288926c5ad415b976bbe2"><span class="std std-ref">reserve</span></a><span></span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a923eead22fe7f0c48aa000158df920f3"><span class="std std-ref">reserveBuffer</span></a><span></span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">);</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4eb96e3251417fa88b78e2abd6cfd7d8"><span class="std std-ref">reshape</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a50e606fe51f53b896b66051634a018fb"><span class="std std-ref">reshape</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">newndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">newsz</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ab2e41a510891e548f744832cf9b8ab89"><span class="std std-ref">reshape</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">newshape</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad0127b138acfcc2dcd5dafc51175b309"><span class="std std-ref">resize</span></a><span></span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abdbf4852beb3af95977fa289f6c7034c"><span class="std std-ref">resize</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">,</span>
        <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
        <span class="p">);</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">row</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa6542193430356ad631a9beabc624107"><span class="std std-ref">rowRange</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">startrow</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">endrow</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a6f5b8257ea38a26295944e9a69caf7e7"><span class="std std-ref">rowRange</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Mat</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0440e2a164c0b0d8462fb1e487be9876"><span class="std std-ref">setTo</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">value</span><span class="p">,</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">mask</span> <span class="o">=</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gad9287b23bba2fed753b36ef561ae7346"><span class="std std-ref">noArray</span></a><span></span><span class="p">()</span>
        <span class="p">);</span>

    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0066c8eee40c1706395b1e57f00e0857"><span class="std std-ref">step1</span></a><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aaa428c60ccb6d8ea5de18f63dfac8e11"><span class="std std-ref">t</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa4d317d43fb0cba9c2503f3c61b866c8"><span class="std std-ref">total</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a5c506fc8b2cf52375e0d8be26aae0df4"><span class="std std-ref">total</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">startDim</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">endDim</span> <span class="o">=</span> <span class="n">INT_MAX</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af2d2652e552d7de635988f18a84b53e5"><span class="std std-ref">type</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">static</span>
    <span class="n">Mat</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0f81856dbcb93eae6113947edb3ea068"><span class="std std-ref">diag</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2cf9b9acde7a9852542bbc20ef851ed2"><span class="std std-ref">eye</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aab87b56e1dc370ffe4afb735b6a1e5c9"><span class="std std-ref">eye</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatAllocator.html#doxid-d4-dee-classcv-1-1-mat-allocator"><span class="std std-ref">MatAllocator</span></a><span></span><span class="o">*</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a8aee95197c1ad458b37539bf9943ea80">getDefaultAllocator</span><span></span><span class="p">();</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatAllocator.html#doxid-d4-dee-classcv-1-1-mat-allocator"><span class="std std-ref">MatAllocator</span></a><span></span><span class="o">*</span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a8d5dda7d818009547d71a086d3d755a7"><span class="std std-ref">getStdAllocator</span></a><span></span><span class="p">();</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a69ae0402d116fc9c71908d8508dc2f09"><span class="std std-ref">ones</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1afc9c2c0b17ecd00932bc5fbc72f9bce0"><span class="std std-ref">ones</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a6ed33f15d7bf0172efb62d61b3751284"><span class="std std-ref">ones</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sz</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <span class="kt">void</span>
    <span class="doxyrest-code-target target" id="doxid-db-de6-classcv-1-1-mat-1a536a771cbad0b8360091e0315ebfc524">setDefaultAllocator</span><span></span><span class="p">(</span><a class="reference internal" href="class_cv_MatAllocator.html#doxid-d4-dee-classcv-1-1-mat-allocator"><span class="std std-ref">MatAllocator</span></a><span></span><span class="o">*</span> <span class="n">allocator</span><span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0b57b6a326c8876d944d188a46e0f556"><span class="std std-ref">zeros</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a095db10924bc801644a29074a755b6e9"><span class="std std-ref">zeros</span></a><span></span><span class="p">(</span>
        <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

    <span class="k">static</span>
    <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
    <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a961cf7d4f82253d93bb5b8ff54522087"><span class="std std-ref">zeros</span></a><span></span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sz</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">type</span>
        <span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="c1">// methods</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">Functor</span>
        <span class="o">&gt;</span>
    <span class="kt">void</span>
    <span class="doxyrest-code-target target" id="doxid-db-de0-group-core-utils-1gaa9eb8c7cba44b791827d0cd685206273">forEach_impl</span><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// direct descendants</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">class</span> <a class="reference internal" href="class_cv_Mat_.html#doxid-d9-de0-classcv-1-1-mat"><span class="std std-ref">Mat_</span></a><span></span><span class="p">;</span>
</pre>
</div>
<div class="section" id="detailed-documentation">
<span id="details-db-de6-classcv-1-1-mat"></span><h2>Detailed Documentation</h2>
<p>n-dimensional dense array class</p>
<p>The class <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> represents an n-dimensional dense numerical single-channel or multi-channel array. It can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms may be better stored in a <a class="reference internal" href="class_cv_SparseMat.html#doxid-d5-d29-classcv-1-1-sparse-mat"><span class="std std-ref">SparseMat</span></a>). The data layout of the array <code class="docutils literal notranslate"><span class="pre">M</span></code> is defined by the array <code class="docutils literal notranslate"><span class="pre">M.step[]</span></code>, so that the address of element <span class="math notranslate nohighlight">\((i_0,...,i_{M.dims-1})\)</span>, where <span class="math notranslate nohighlight">\(0\leq i_k&lt;M.size[k]\)</span>, is computed as:</p>
<div class="math notranslate nohighlight">
\[addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}\]</div>
<p>In case of a 2-dimensional array, the above formula is reduced to:</p>
<div class="math notranslate nohighlight">
\[addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\]</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">M.step[i]</span> <span class="pre">&gt;=</span> <span class="pre">M.step[i+1]</span></code> (in fact, <code class="docutils literal notranslate"><span class="pre">M.step[i]</span> <span class="pre">&gt;=</span> <span class="pre">M.step[i+1]*M.size[i+1]</span></code>). This means that 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane, and so on. M.step[M.dims-1] is minimal and always equal to the element size M.elemSize() .</p>
<p>So, the data layout in <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> is fully compatible with <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a>, <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a>, and <a class="reference internal" href="struct_CvMatND.html#doxid-d7-d5c-struct-cv-mat-n-d"><span class="std std-ref">CvMatND</span></a> types from OpenCV 1.x. It is also compatible with the majority of dense array types from the standard toolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others, that is, with any array that uses <em>steps</em> (or <em>strides</em>) to compute the position of a pixel. Due to this compatibility, it is possible to make a <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> header for user-allocated data and process it in-place using OpenCV functions.</p>
<p>There are many different ways to create a <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> object. The most popular options are listed below:</p>
<ul>
<li><p class="first">Use the create(nrows, ncols, type) method or the similar Mat(nrows, ncols, type[, fillValue]) constructor. A new array of the specified size and type is allocated. type has the same meaning as in the cvCreateMat method. For example, CV_8UC1 means a 8-bit single-channel array, CV_32FC2 means a 2-channel (complex) floating-point array, and so on.</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// make a 7x7 complex matrix filled with 1+3j.</span>
<span class="n">Mat</span> <span class="nf">M</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">CV_32FC2</span><span class="p">,</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">// and now turn M to a 100x60 15-channel 8-bit matrix.</span>
<span class="c1">// The old content will be deallocated</span>
<span class="n">M</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="n">CV_8UC</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
</pre>
<p>As noted in the introduction to this chapter, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">create()</span></a> allocates only a new array when the shape or type of the current array are different from the specified ones.</p>
</li>
<li><p class="first">Create a multi-dimensional array:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// create a 100x100x100 8-bit array</span>
<span class="kt">int</span> <span class="n">sz</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>
<span class="n">Mat</span> <span class="nf">bigCube</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre>
<p>It passes the number of dimensions =1 to the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> constructor but the created array will be 2-dimensional with the number of columns set to 1. So, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a39cf614aa52567e9a945cd2609bd767b"><span class="std std-ref">Mat::dims</span></a> is always &gt;= 2 (can also be 0 when the array is empty).</p>
</li>
<li><p class="first">Use a copy constructor or assignment operator where there can be an array or expression on the right side (see below). As noted in the introduction, the array assignment is an O(1) operation because it only copies the header and increases the reference counter. The <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">Mat::clone()</span></a> method can be used to get a full (deep) copy of the array when you need it.</p>
</li>
<li><p class="first">Construct a header for a part of another array. It can be a single row, single column, several rows, several columns, rectangular region in the array (called a <em>minor</em> in algebra) or a diagonal. Such operations are also O(1) because the new header references the same data. You can actually modify a part of the array using this feature, for example:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// add the 5-th row, multiplied by 3 to the 3rd row</span>
<span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span>
<span class="c1">// now copy the 7-th column to the 1-st column</span>
<span class="c1">// M.col(1) = M.col(7); // this will not work</span>
<span class="n">Mat</span> <span class="n">M1</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">7</span><span class="p">).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">M1</span><span class="p">);</span>
<span class="c1">// create a new 320x240 image</span>
<span class="n">Mat</span> <span class="nf">img</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span><span class="n">CV_8UC3</span><span class="p">);</span>
<span class="c1">// select a ROI</span>
<span class="n">Mat</span> <span class="nf">roi</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
<span class="c1">// fill the ROI with (0,255,0) (which is green in RGB space);</span>
<span class="c1">// the original 320x240 image will be modified</span>
<span class="n">roi</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre>
<p>Due to the additional datastart and dataend members, it is possible to compute a relative sub-array position in the main <em>container</em> array using <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a40b5b3371a9c2a4b2b8ce0c8068d7c96"><span class="std std-ref">locateROI()</span></a> :</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">CV_32S</span><span class="p">);</span>
<span class="c1">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span>
<span class="n">Mat</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">(),</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="c1">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span>
<span class="c1">// that is, C \~ A(Range(5, 9), Range(1, 3))</span>
<span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">());</span>
<span class="n">Size</span> <span class="n">size</span><span class="p">;</span> <span class="n">Point</span> <span class="n">ofs</span><span class="p">;</span>
<span class="n">C</span><span class="p">.</span><span class="n">locateROI</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
<span class="c1">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span>
</pre>
<p>As in case of whole matrices, if you need a deep copy, use the <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref"><span class="pre">clone()</span></span></a></code> method of the extracted sub-matrices.</p>
</li>
<li><p class="first">Make a header for user-allocated data. It can be useful to do the following:</p>
<ol class="arabic">
<li><p class="first">Process â€œforeignâ€ data using OpenCV (for example, when you implement a DirectShow* filter or a processing module for gstreamer, and so on). For example:</p>
<pre class="highlight literal-block">
<span></span><span class="kt">void</span> <span class="nf">process_video_frame</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span>
                         <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">img</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
    <span class="n">GaussianBlur</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="p">}</span>
</pre>
</li>
<li><p class="first">Quickly initialize small matrices and/or get a super-fast element access.</p>
<pre class="highlight literal-block">
<span></span><span class="kt">double</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">},</span> <span class="p">{</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">},</span> <span class="p">{</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">}};</span>
<span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">,</span> <span class="n">m</span><span class="p">).</span><span class="n">inv</span><span class="p">();</span>
</pre>
</li>
</ol>
<p>Partial yet very common cases of this <em>user-allocated data</em> case are conversions from <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> and <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a>. For this purpose, there is function <a class="reference internal" href="group_core_c_glue.html#doxid-d8-dd7-group-core-c-glue-1gafa8ade391d84ed9278c336fd0a58f4e1"><span class="std std-ref">cv::cvarrToMat</span></a> taking pointers to <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> or <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> and the optional flag indicating whether to copy the data or not.</p>
<pre class="highlight literal-block">
<span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IplImage</span><span class="o">&gt;</span> <span class="n">iplimg</span><span class="p">(</span><a class="reference internal" href="group_imgcodecs_c.html#doxid-da-d0a-group-imgcodecs-c-1ga93b9ddb9fbd8978d27f5a19c6751edcf"><span class="std std-ref">cvLoadImage</span></a><span></span><span class="p">(</span><span class="n">imagename</span><span class="p">.</span><span class="n">c_str</span><span class="p">()));</span> <span class="c1">// Ptr&lt;T&gt; is safe ref-counting pointer class</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">iplimg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Can not load image %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">imagename</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af1d014cecd1510cdf580bf2ed7e5aafc"><span class="std std-ref">Mat</span></a><span></span> <span class="n">img</span> <span class="o">=</span> <a class="reference internal" href="group_core_c_glue.html#doxid-d8-dd7-group-core-c-glue-1gafa8ade391d84ed9278c336fd0a58f4e1"><span class="std std-ref">cv::cvarrToMat</span></a><span></span><span class="p">(</span><span class="n">iplimg</span><span class="p">);</span> <span class="c1">// cv::Mat replaces the CvMat and IplImage, but it&#39;s easy to convert</span>
<span class="c1">// between the old and the new data structures (by default, only the header</span>
<span class="c1">// is converted, while the data is shared)</span>
</pre>
</li>
<li><p class="first">Use MATLAB-style array initializers, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0b57b6a326c8876d944d188a46e0f556"><span class="std std-ref">zeros()</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a69ae0402d116fc9c71908d8508dc2f09"><span class="std std-ref">ones()</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a2cf9b9acde7a9852542bbc20ef851ed2"><span class="std std-ref">eye()</span></a>, for example:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// create a double-precision identity matrix and add it to M.</span>
<span class="n">M</span> <span class="o">+=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
</pre>
</li>
<li><p class="first">Use a comma-separated initializer:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// create a 3x3 double-precision identity matrix</span>
<span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre>
<p>With this approach, you first call a constructor of the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> class with the proper parameters, and then you just put <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span> <span class="pre">operator</span></code> followed by comma-separated values that can be constants, variables, expressions, and so on. Also, note the extra parentheses required to avoid compilation errors.</p>
</li>
</ul>
<p>Once the array is created, it is automatically managed via a reference-counting mechanism. If the array header is built on top of user-allocated data, you should handle the data by yourself. The array data is deallocated when no one points to it. If you want to release the data pointed by a array header before the array destructor is called, use <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ae48d4913285518e2c21a3457017e716e"><span class="std std-ref">Mat::release()</span></a>.</p>
<p>The next important thing to learn about the array class is element access. This manual already described how to compute an address of each array element. Normally, you are not required to use the formula directly in the code. If you know the array element type (which can be retrieved using the method <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af2d2652e552d7de635988f18a84b53e5"><span class="std std-ref">Mat::type()</span></a>), you can access the element <span class="math notranslate nohighlight">\(M_{ij}\)</span> of a 2-dimensional array as:</p>
<pre class="highlight literal-block">
<span></span><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
</pre>
<p>assuming that <code class="docutils literal notranslate"><span class="pre">M</span></code> is a double-precision floating-point array. There are several variants of the method at for a different number of dimensions.</p>
<p>If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to the row first, and then just use the plain C operator [] :</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// compute sum of positive matrix elements</span>
<span class="c1">// (assuming that M is a double-precision matrix)</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Some operations, like the one above, do not actually depend on the array shape. They just process elements of an array one by one (or elements from multiple arrays that have the same coordinates, for example, array addition). Such operations are called <em>element-wise</em>. It makes sense to check whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If yes, process them as a long single row:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// compute the sum of positive matrix elements, optimized variant</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">cols</span> <span class="o">*=</span> <span class="n">rows</span><span class="p">;</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is smaller, which is especially noticeable in case of small matrices.</p>
<p>Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// compute sum of positive matrix elements, iterator-based variant</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it_end</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="mf">0.</span><span class="p">);</span>
</pre>
<p>The matrix iterators are random-access iterators, so they can be passed to any STL algorithm, including <a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1ga45dd56da289494ce874be2324856898f"><span class="std std-ref">std::sort()</span></a>.</p>
<p>Matrix Expressions and arithmetic see <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a></p>
<div class="section" id="fields">
<h3>Fields</h3>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a4d2eb7a536cd5a0f18808b6112111d6a">
<span id="index-1"></span><a class="reference internal" href="class_cv_MatAllocator.html#doxid-d4-dee-classcv-1-1-mat-allocator"><span class="std std-ref">MatAllocator</span></a><span></span><span class="o">*</span> <span class="n">allocator</span>
</pre>
<p>custom allocator</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a4d33bed1c850265370d2af0ff02e1564">
<span id="index-2"></span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <span class="n">data</span>
</pre>
<p>pointer to the data</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aeda6d607bfc629a95f59e7b538832172">
<span id="index-3"></span><span></span><span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <span class="n">datastart</span>
</pre>
<p>helper fields used in locateROI and adjustROI</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a39cf614aa52567e9a945cd2609bd767b">
<span id="index-4"></span><span></span><span class="kt">int</span> <span class="n">dims</span>
</pre>
<p>the matrix dimensionality, &gt;= 2</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1af9333f06c84f115fda4cdf3af18c2ad0">
<span id="index-5"></span><span></span><span class="kt">int</span> <span class="n">flags</span>
</pre>
<p>includes several bit-fields:</p>
<ul class="simple">
<li>the magic signature</li>
<li>continuity flag</li>
<li>depth</li>
<li>number of channels</li>
</ul>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1abed816466c45234254d25bc59c31245e">
<span id="index-6"></span><span></span><span class="kt">int</span> <span class="n">rows</span>
</pre>
<p>the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2742469fe595e1b9036f60d752d08461">
<span id="index-7"></span><a class="reference internal" href="struct_cv_UMatData.html#doxid-dd-d13-structcv-1-1-u-mat-data"><span class="std std-ref">UMatData</span></a><span></span><span class="o">*</span> <span class="n">u</span>
</pre>
<p>interaction with <a class="reference internal" href="class_cv_UMat.html#doxid-d8-d82-classcv-1-1-u-mat"><span class="std std-ref">UMat</span></a></p>
</div>
<div class="section" id="construction">
<h3>Construction</h3>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1af1d014cecd1510cdf580bf2ed7e5aafc">
<span id="index-8"></span><span></span><span class="n">Mat</span><span class="p">()</span>
</pre>
<p>These are various constructors that form a matrix. As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">Mat::create</span></a>. In the former case, the old content is de-referenced.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2ec3402f7d165ca34c7fd6e8498a62ca">
<span id="index-9"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>Number of rows in a 2D array.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>Number of columns in a 2D array.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a75a97b1e4e55f380c172af58048a7cde">
<span id="index-10"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>2D array size: Size(cols, rows) . In the <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size()</span></a> constructor, the number of rows and the number of columns go in the reverse order.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a3620c370690b5ca4d40c767be6fb4ceb">
<span id="index-11"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>Number of rows in a 2D array.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>Number of columns in a 2D array.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-even"><td>s</td>
<td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50"><span class="std std-ref">Mat::operator=(const Scalar&amp; value)</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a286371a6196eaaaf0b86e158590460b7">
<span id="index-12"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>2D array size: Size(cols, rows) . In the <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size()</span></a> constructor, the number of rows and the number of columns go in the reverse order.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-odd"><td>s</td>
<td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50"><span class="std std-ref">Mat::operator=(const Scalar&amp; value)</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a156df5a1326dd5c30b187b0e721a5f57">
<span id="index-13"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ndims</td>
<td>Array dimensionality.</td>
</tr>
<tr class="row-even"><td>sizes</td>
<td>Array of integers specifying an n-dimensional array shape.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a6adc4d64db5379bcbb713e71c9292f6e">
<span id="index-14"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sizes</td>
<td>Array of integers specifying an n-dimensional array shape.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1afbf34be80b7443123b2a032a67c3c4e3">
<span id="index-15"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ndims</td>
<td>Array dimensionality.</td>
</tr>
<tr class="row-even"><td>sizes</td>
<td>Array of integers specifying an n-dimensional array shape.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-even"><td>s</td>
<td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50"><span class="std std-ref">Mat::operator=(const Scalar&amp; value)</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ad20a78b5501fc39543a240142a40e234">
<span id="index-16"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sizes</td>
<td>Array of integers specifying an n-dimensional array shape.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-odd"><td>s</td>
<td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50"><span class="std std-ref">Mat::operator=(const Scalar&amp; value)</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a294eaf8a95d2f9c7be19ff594d06278e">
<span id="index-17"></span><span></span><span class="n">Mat</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to m data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . If you want to have an independent copy of the sub-array, use <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">Mat::clone()</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a51615ebf17a64c968df0bf49b4de6a3a">
<span id="index-18"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">step</span> <span class="o">=</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a1c147538fd896f4f9abce9eaea9727e3"><span class="std std-ref">AUTO_STEP</span></a><span></span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>Number of rows in a 2D array.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>Number of columns in a 2D array.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-even"><td>data</td>
<td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</td>
</tr>
<tr class="row-odd"><td>step</td>
<td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize(). See <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aba7a5ef00b22b70668fba575005dfe55"><span class="std std-ref">Mat::elemSize</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a9fa74fb14362d87cb183453d2441948f">
<span id="index-19"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">step</span> <span class="o">=</span> <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1acb0821facd341e5c9c94a22f6ca6acb8a1c147538fd896f4f9abce9eaea9727e3"><span class="std std-ref">AUTO_STEP</span></a><span></span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>2D array size: Size(cols, rows) . In the <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size()</span></a> constructor, the number of rows and the number of columns go in the reverse order.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-odd"><td>data</td>
<td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</td>
</tr>
<tr class="row-even"><td>step</td>
<td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize(). See <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aba7a5ef00b22b70668fba575005dfe55"><span class="std std-ref">Mat::elemSize</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a5fafc033e089143062fd31015b5d0f40">
<span id="index-20"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span><span class="o">*</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ndims</td>
<td>Array dimensionality.</td>
</tr>
<tr class="row-even"><td>sizes</td>
<td>Array of integers specifying an n-dimensional array shape.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-even"><td>data</td>
<td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</td>
</tr>
<tr class="row-odd"><td>steps</td>
<td>Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). If not specified, the matrix is assumed to be continuous.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a922de793eabcec705b3579c5f95a643e">
<span id="index-21"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span><span class="o">*</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sizes</td>
<td>Array of integers specifying an n-dimensional array shape.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Array type. Use CV_8UC1, â€¦, CV_64FC4 to create 1-4 channel matrices, or <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga78c5506f62d99edd7e83aba259250394"><span class="std std-ref">CV_8UC(n)</span></a>, â€¦, <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga4213eb262159eb6da4edf8c9255e8244"><span class="std std-ref">CV_64FC(n)</span></a> to create multi-channel (up to CV_CN_MAX channels) matrices.</td>
</tr>
<tr class="row-odd"><td>data</td>
<td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</td>
</tr>
<tr class="row-even"><td>steps</td>
<td>Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). If not specified, the matrix is assumed to be continuous.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a92a3e9e5911a2eb0cf0950a0a9670c76">
<span id="index-22"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">rowRange</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">colRange</span> <span class="o">=</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref">Range::all</span></a><span></span><span class="p">()</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to m data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . If you want to have an independent copy of the sub-array, use <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">Mat::clone()</span></a>.</td>
</tr>
<tr class="row-even"><td>rowRange</td>
<td><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. Use <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref">Range::all()</span></a> to take all the rows.</td>
</tr>
<tr class="row-odd"><td>colRange</td>
<td><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a> of the m columns to take. Use <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref">Range::all()</span></a> to take all the columns.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa7ec97373406215f2d4bc72cc1d27036">
<span id="index-23"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga11d95de507098e90bad732b9345402e8"><span class="std std-ref">Rect</span></a><span></span><span class="o">&amp;</span> <span class="n">roi</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to m data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . If you want to have an independent copy of the sub-array, use <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">Mat::clone()</span></a>.</td>
</tr>
<tr class="row-even"><td>roi</td>
<td>Region of interest.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1afde22a742fc73c0a150a9002310ac2eb">
<span id="index-24"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">*</span> <span class="n">ranges</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to m data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . If you want to have an independent copy of the sub-array, use <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">Mat::clone()</span></a>.</td>
</tr>
<tr class="row-even"><td>ranges</td>
<td>Array of selected ranges of m along each dimensionality.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa6e903a6c762478692791a33d233019b">
<span id="index-25"></span><span></span><span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&gt;&amp;</span> <span class="n">ranges</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to m data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . If you want to have an independent copy of the sub-array, use <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4"><span class="std std-ref">Mat::clone()</span></a>.</td>
</tr>
<tr class="row-even"><td>ranges</td>
<td>Array of selected ranges of m along each dimensionality.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a23b182c4ffd46abe38f460c1480ae887">
<span id="index-26"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>vec</td>
<td>STL vector whose elements form the matrix. The matrix has a single column and the number of rows equal to the number of vector elements. Type of the matrix matches the type of vector elements. The constructor can handle arbitrary types, for which there is a properly declared <a class="reference internal" href="class_cv_DataType.html#doxid-da-da2-classcv-1-1-data-type"><span class="std std-ref">DataType</span></a>. This means that the vector elements must be primitive numbers or uni-type numerical tuples of numbers. Mixed-type structures are not supported. The corresponding constructor is explicit. Since STL vectors are not automatically converted to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> instances, you should write Mat(vec) explicitly. Unless you copy the data into the matrix ( copyData=true ), no new elements will be added to the vector because it can potentially yield vector data reallocation, and, thus, the matrix data pointer will be invalid.</td>
</tr>
<tr class="row-even"><td>copyData</td>
<td>Flag to specify whether the underlying data of the STL vector should be copied to (true) or shared with (false) the newly constructed matrix. When the data is copied, the allocated buffer is managed using <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> reference counting mechanism. While the data is shared, the reference counter is NULL, and you should not deallocate the data until the matrix is not destructed.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a507e01fb48b34a3e5c45f9f5b00725e8">
<span id="index-27"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">n</span>
    <span class="o">&gt;</span>
<span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a37068a8d9acc7cc5af817eb82b2aa83b">
<span id="index-28"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">n</span>
    <span class="o">&gt;</span>
<span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Matx.html#doxid-db-d15-classcv-1-1-matx"><span class="std std-ref">Matx</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">mtx</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a224477889ddc7424aaab1b76e7682ea2">
<span id="index-29"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Point_.html#doxid-d9-d87-classcv-1-1-point"><span class="std std-ref">Point_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a7d72610ed5aed9117eb7933a97670309">
<span id="index-30"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">Mat</span><span class="p">(</span>
    <span class="k">const</span> <a class="reference internal" href="class_cv_Point3_.html#doxid-d4-d29-classcv-1-1-point3"><span class="std std-ref">Point3_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">copyData</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a23957ae2fed348c67952c0d69c873972">
<span id="index-31"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">Mat</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_MatCommaInitializer_.html#doxid-d7-dfc-classcv-1-1-mat-comma-initializer"><span class="std std-ref">MatCommaInitializer_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">commaInitializer</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa82eca82664985c81c7912b04549370d">
<span id="index-32"></span><span></span><span class="n">Mat</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_cuda_GpuMat.html#doxid-d5-da3-classcv-1-1cuda-1-1-gpu-mat"><span class="std std-ref">cuda::GpuMat</span></a><span></span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
</pre>
<p>download data from GpuMat</p>
</div>
<div class="section" id="methods">
<h3>Methods</h3>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a9d3794250e3dc39714f980b4d0d45864">
<span id="index-33"></span><span></span><span class="kt">void</span>
<span class="n">addref</span><span class="p">()</span>
</pre>
<p>Increments the reference counter.</p>
<p>The method increments the reference counter associated with the matrix data. If the matrix header points to an external data set (see <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af1d014cecd1510cdf580bf2ed7e5aafc"><span class="std std-ref">Mat::Mat</span></a>), the reference counter is NULL, and the method has no effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It is called implicitly by the matrix assignment operator. The reference counter increment is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2fece3507ee7e1284deee6da99e76b9b">
<span id="index-34"></span><span></span><span class="n">Mat</span><span class="o">&amp;</span>
<span class="n">adjustROI</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">dtop</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">dbottom</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">dleft</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">dright</span>
    <span class="p">)</span>
</pre>
<p>Adjusts a submatrix size and position within the parent matrix.</p>
<p>The method is complimentary to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a40b5b3371a9c2a4b2b8ce0c8068d7c96"><span class="std std-ref">Mat::locateROI</span></a>. The typical use of these functions is to determine the submatrix position within the parent matrix and then shift the position somehow. Typically, it can be required for filtering operations when pixels outside of the ROI should be taken into account. When all the method parameters are positive, the ROI needs to grow in all directions by the specified amount, for example:</p>
<pre class="highlight literal-block">
<span></span><span class="n">A</span><span class="p">.</span><span class="n">adjustROI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre>
<p>In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the filtering with the 5x5 kernel.</p>
<p>adjustROI forces the adjusted ROI to be inside of the parent matrix that is boundaries of the adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix A is located in the first row of a parent matrix and you called A.adjustROI(2, 2, 2, 2) then A will not be increased in the upward direction.</p>
<p>The function is used internally by the OpenCV filtering functions, like filter2D , morphological operations, and so on.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>dtop</td>
<td>Shift of the top submatrix boundary upwards.</td>
</tr>
<tr class="row-even"><td>dbottom</td>
<td>Shift of the bottom submatrix boundary downwards.</td>
</tr>
<tr class="row-odd"><td>dleft</td>
<td>Shift of the left submatrix boundary to the left.</td>
</tr>
<tr class="row-even"><td>dright</td>
<td>Shift of the right submatrix boundary to the right.</td>
</tr>
</tbody>
</table>
<p class="rubric">See also:</p>
<p><a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1ga2ac1049c2c3dd25c2b41bffe17658a36"><span class="std std-ref">copyMakeBorder</span></a></p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa8b3b4d7b9876a4726740b75daa98ddb">
<span id="index-35"></span><span></span><span class="kt">void</span>
<span class="n">assignTo</span><span class="p">(</span>
    <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Provides a functional form of convertTo.</p>
<p>This is an internally used method called by the <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr-1matrixexpressions"><span class="std std-ref">MatrixExpressions</span></a> engine.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Destination array.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Desired destination array depth (or -1 if it should be the same as the source type).</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726">
<span id="index-36"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p>Returns a reference to the specified array element.</p>
<p>The template methods return a reference to the specified array element. For the sake of higher performance, the index range checks are only performed in the Debug configuration.</p>
<p>Note that the variants with a single index (i) can be used to access elements of single-row or single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and B is an M x 1 integer matrix, you can simply write <code class="docutils literal notranslate"><span class="pre">A.at&lt;float&gt;(k+4)</span></code> and <code class="docutils literal notranslate"><span class="pre">B.at&lt;int&gt;(2*i+1)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">A.at&lt;float&gt;(0,k+4)</span></code> and <code class="docutils literal notranslate"><span class="pre">B.at&lt;int&gt;(2*i+1,0)</span></code>, respectively.</p>
<p>The example below initializes a Hilbert matrix:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="nf">H</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">H</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</pre>
<p>Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends on the image from which you are trying to retrieve the data. The table below gives a better insight in this:</p>
<ul class="simple">
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_8U</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;uchar&gt;(y,x)</span></code>.</li>
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_8S</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;schar&gt;(y,x)</span></code>.</li>
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_16U</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;ushort&gt;(y,x)</span></code>.</li>
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_16S</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;short&gt;(y,x)</span></code>.</li>
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_32S</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;int&gt;(y,x)</span></code>.</li>
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_32F</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;float&gt;(y,x)</span></code>.</li>
<li>If matrix is of type <code class="docutils literal notranslate"><span class="pre">CV_64F</span></code> then use <code class="docutils literal notranslate"><a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5d20fc86d41d59e4d71ae93daee9726"><span class="std std-ref"><span class="pre">Mat.at</span></span></a><span class="pre">&lt;double&gt;(y,x)</span></code>.</li>
</ul>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>i0</td>
<td>Index along the dimension 0</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a330d9adb78976b6efd4116c940924294">
<span id="index-37"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>i0</td>
<td>Index along the dimension 0</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ac40425b84f60b39fd35e03814122661f">
<span id="index-38"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>row</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>col</td>
<td>Index along the dimension 1</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a5db6b18954e334048cb35752f49c6f8c">
<span id="index-39"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>row</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>col</td>
<td>Index along the dimension 1</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a305829ed5c0ecfef7b44db18953048e8">
<span id="index-40"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i2</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>i0</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>i1</td>
<td>Index along the dimension 1</td>
</tr>
<tr class="row-odd"><td>i2</td>
<td>Index along the dimension 2</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a59c6c2d9db1cfba76d75addeeb4e6a84">
<span id="index-41"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i2</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>i0</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>i1</td>
<td>Index along the dimension 1</td>
</tr>
<tr class="row-odd"><td>i2</td>
<td>Index along the dimension 2</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a474bd5cdcf986672cfdc304f6be1cf64">
<span id="index-42"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>idx</td>
<td>Array of <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a39cf614aa52567e9a945cd2609bd767b"><span class="std std-ref">Mat::dims</span></a> indices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2cbbb16670ae4d9aa747f19c24305213">
<span id="index-43"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>idx</td>
<td>Array of <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a39cf614aa52567e9a945cd2609bd767b"><span class="std std-ref">Mat::dims</span></a> indices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a9ec1aadc17ab8c8f8334d521719c7732">
<span id="index-44"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">n</span>
    <span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a15c649a94cf2e06240b32b025231301f">
<span id="index-45"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">n</span>
    <span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a23cd599a27c59bae64b0c40ad645ea49">
<span id="index-46"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga1e83eafb2d26b3c93f09e8338bcab192"><span class="std std-ref">Point</span></a><span></span> <span class="n">pt</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. special versions for 2D arrays (especially convenient for referencing image pixels)</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>pt</td>
<td>Element position specified as Point(j,i) .</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a87d0b2e01b0f8686957398ecfb168a6d">
<span id="index-47"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span>
<span class="n">at</span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga1e83eafb2d26b3c93f09e8338bcab192"><span class="std std-ref">Point</span></a><span></span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. special versions for 2D arrays (especially convenient for referencing image pixels)</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>pt</td>
<td>Element position specified as Point(j,i) .</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a33ee3bc402827f587a5ad64b568d6986">
<span id="index-48"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<a class="reference internal" href="class_cv_MatIterator_.html#doxid-da-d1f-classcv-1-1-mat-iterator"><span class="std std-ref">MatIterator_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">begin</span><span class="p">()</span>
</pre>
<p>Returns the matrix iterator and sets it to the first matrix element.</p>
<p>The methods return the matrix read-only or read-write iterators. The use of matrix iterators is very similar to the use of bi-directional STL iterators. In the example below, the alpha blending function is rewritten using the matrix iterators:</p>
<pre class="highlight literal-block">
<span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">alphaBlendRGBA</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src2</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">VT</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span>
                <span class="n">inv_scale</span> <span class="o">=</span> <span class="mf">1.f</span><span class="o">/</span><span class="n">alpha_scale</span><span class="p">;</span>

    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it1_end</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MatIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">dst_it</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">it1</span> <span class="o">!=</span> <span class="n">it1_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it1</span><span class="p">,</span> <span class="o">++</span><span class="n">it2</span><span class="p">,</span> <span class="o">++</span><span class="n">dst_it</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">VT</span> <span class="n">pix1</span> <span class="o">=</span> <span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="n">pix2</span> <span class="o">=</span> <span class="o">*</span><span class="n">it2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">pix1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">;</span>
        <span class="o">*</span><span class="n">dst_it</span> <span class="o">=</span> <span class="n">VT</span><span class="p">(</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span><span class="o">*</span><span class="n">alpha_scale</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa11336b9ac538e0475d840657ce164be">
<span id="index-49"></span><span></span><span class="kt">int</span>
<span class="n">channels</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the number of matrix channels.</p>
<p>The method returns the number of matrix channels.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a167a8e0a3a3d86e84b70e33483af4466">
<span id="index-50"></span><span></span><span class="kt">int</span>
<span class="n">checkVector</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">elemChannels</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">requireContinuous</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ad1c9cc37d66c4e5bd05fae36f62d1cb4">
<span id="index-51"></span><span></span><span class="n">Mat</span>
<span class="n">clone</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Creates a full copy of the array and the underlying data.</p>
<p>The method creates a full copy of the array. The original step[] is not taken into account. So, the array copy is a continuous array occupying <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa4d317d43fb0cba9c2503f3c61b866c8"><span class="std std-ref">total()</span></a> *elemSize() bytes.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe">
<span id="index-52"></span><span></span><span class="n">Mat</span>
<span class="n">col</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Creates a matrix header for the specified matrix column.</p>
<p>The method makes a new header for the specified matrix column and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. See also the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">Mat::row</span></a> description.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>x</td>
<td>A 0-based column index.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aadc8f9210fe4dec50513746c246fa8d9">
<span id="index-53"></span><span></span><span class="n">Mat</span>
<span class="n">colRange</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">startcol</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">endcol</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Creates a matrix header for the specified column span.</p>
<p>The method makes a new header for the specified column span of the matrix. Similarly to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">Mat::row</span></a> and <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">Mat::col</span></a>, this is an O(1) operation.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>startcol</td>
<td>An inclusive 0-based start index of the column span.</td>
</tr>
<tr class="row-even"><td>endcol</td>
<td>An exclusive 0-based ending index of the column span.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1acccb63e44eba6ba81ead99881bd1997e">
<span id="index-54"></span><span></span><span class="n">Mat</span>
<span class="n">colRange</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>r</td>
<td><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a> structure containing both the start and the end indices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1adf88c60c5b4980e05bb556080916978b">
<span id="index-55"></span><span></span><span class="kt">void</span>
<span class="n">convertTo</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gaad17fda1d0f0d1ee069aebb1df2913c0"><span class="std std-ref">OutputArray</span></a><span></span> <span class="n">m</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">rtype</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">beta</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Converts an array to another data type with optional scaling.</p>
<p>The method converts source pixel values to the target data type. saturate_cast&lt;&gt; is applied at the end to avoid possible overflows:</p>
<div class="math notranslate nohighlight">
\[m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) + \beta )\]</div>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>output matrix; if it does not have a proper size or type before the operation, it is reallocated.</td>
</tr>
<tr class="row-even"><td>rtype</td>
<td>desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</td>
</tr>
<tr class="row-odd"><td>alpha</td>
<td>optional scale factor.</td>
</tr>
<tr class="row-even"><td>beta</td>
<td>optional delta added to the scaled values.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a39fd9880fc55b7a0993bcfff88061ac4">
<span id="index-56"></span><span></span><span class="kt">void</span>
<span class="n">copySize</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
</pre>
<p>internal use function; properly re-allocates _size, _step arrays</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a33fd5d125b4c302b0c9aa86980791a77">
<span id="index-57"></span><span></span><span class="kt">void</span>
<span class="n">copyTo</span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gaad17fda1d0f0d1ee069aebb1df2913c0"><span class="std std-ref">OutputArray</span></a><span></span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Copies the matrix to another one.</p>
<p>The method copies the matrix data to another matrix. Before copying the data, the method invokes :</p>
<pre class="highlight literal-block">
<span></span><span class="n">m</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
</pre>
<p>so that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices.</p>
<p>When the operation mask is specified, if the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">Mat::create</span></a> call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a626fe5f96d02525e2604d2ad46dd574f">
<span id="index-58"></span><span></span><span class="kt">void</span>
<span class="n">copyTo</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gaad17fda1d0f0d1ee069aebb1df2913c0"><span class="std std-ref">OutputArray</span></a><span></span> <span class="n">m</span><span class="p">,</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">mask</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</td>
</tr>
<tr class="row-even"><td>mask</td>
<td>Operation mask. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0">
<span id="index-59"></span><span></span><span class="kt">void</span>
<span class="n">create</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>Allocates new array data if needed.</p>
<p>This is one of the key <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol class="arabic simple">
<li>If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ae48d4913285518e2c21a3457017e716e"><span class="std std-ref">Mat::release</span></a>.</li>
<li>Initialize the new header.</li>
<li>Allocate the new data of <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa4d317d43fb0cba9c2503f3c61b866c8"><span class="std std-ref">total()</span></a> *elemSize() bytes.</li>
<li>Allocate the new, associated with the data, reference counter and set it to 1.</li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">color</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">depth</span><span class="p">());</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">COLOR_BGR2GRAY</span><span class="p">);</span>
</pre>
<p>you can simply write:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">color</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">;</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">COLOR_BGR2GRAY</span><span class="p">);</span>
</pre>
<p>because cvtColor, as well as the most of OpenCV functions, calls <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">Mat::create()</span></a> for the output array internally.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>New number of rows.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>New number of columns.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>New matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a48409946d0e1bebb40fe765e18ec5eea">
<span id="index-60"></span><span></span><span class="kt">void</span>
<span class="n">create</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>Alternative new matrix size specification: Size(cols, rows)</td>
</tr>
<tr class="row-even"><td>type</td>
<td>New matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aee53524ac61fa2ba441c4f29c3aca93f">
<span id="index-61"></span><span></span><span class="kt">void</span>
<span class="n">create</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ndims</td>
<td>New array dimensionality.</td>
</tr>
<tr class="row-even"><td>sizes</td>
<td>Array of integers specifying a new array shape.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>New matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a84f35d3923a92251631329eed66d2a12">
<span id="index-62"></span><span></span><span class="kt">void</span>
<span class="n">create</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">sizes</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sizes</td>
<td>Array of integers specifying a new array shape.</td>
</tr>
<tr class="row-even"><td>type</td>
<td>New matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a708b761e0d15b7b8db4c8e8c95a7abe9">
<span id="index-63"></span><span></span><span class="n">Mat</span>
<span class="n">cross</span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Computes a cross-product of two 3-element vectors.</p>
<p>The method computes a cross-product of two 3-element vectors. The vectors must be 3-element floating-point vectors of the same shape and size. The result is another 3-element vector of the same shape and type as operands.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Another cross-product operand.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ac6e9cdf9b450e360f005978b4e981b1a">
<span id="index-64"></span><span></span><span class="kt">void</span>
<span class="n">deallocate</span><span class="p">()</span>
</pre>
<p>deallocates the matrix data</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a8da9f853b6f3a29d738572fd1ffc44c0">
<span id="index-65"></span><span></span><span class="kt">int</span>
<span class="n">depth</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the depth of a matrix element.</p>
<p>The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed element array, the method returns CV_16S . A complete list of matrix types contains the following values:</p>
<ul class="simple">
<li>CV_8U - 8-bit unsigned integers ( 0..255 )</li>
<li>CV_8S - 8-bit signed integers ( -128..127 )</li>
<li>CV_16U - 16-bit unsigned integers ( 0..65535 )</li>
<li>CV_16S - 16-bit signed integers ( -32768..32767 )</li>
<li>CV_32S - 32-bit signed integers ( -2147483648..2147483647 )</li>
<li>CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )</li>
<li>CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )</li>
</ul>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a024cc0510a4c61c7f266d4ab9fe13d7a">
<span id="index-66"></span><span></span><span class="n">Mat</span>
<span class="n">diag</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Extracts a diagonal from a matrix.</p>
<p>The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-column matrix. Similarly to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">Mat::row</span></a> and <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">Mat::col</span></a>, this is an O(1) operation.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>d</td>
<td><p class="first">index of the diagonal, with the following values:</p>
<ul class="last">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">d=0</span></code> is the main diagonal.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">d&lt;0</span></code> is a diagonal from the lower half. For example, d=-1 means the diagonal is set immediately below the main one.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">d&gt;0</span></code> is a diagonal from the upper half. For example, d=1 means the diagonal is set immediately above the main one. For example:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
            <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span>
            <span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">d0</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">d_1</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</pre>
<p>The resulting matrices are</p>
<pre class="highlight literal-block">
<span></span><span class="n">d0</span> <span class="o">=</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">;</span>
   <span class="mi">5</span><span class="p">;</span>
   <span class="mi">9</span><span class="p">]</span>
<span class="n">d1</span> <span class="o">=</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">;</span>
   <span class="mi">6</span><span class="p">]</span>
<span class="n">d_1</span> <span class="o">=</span>
  <span class="p">[</span><span class="mi">4</span><span class="p">;</span>
   <span class="mi">8</span><span class="p">]</span>
</pre>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a0f683eab191eeece33dfc64ae299a9cb">
<span id="index-67"></span><span></span><span class="kt">double</span>
<span class="n">dot</span><span class="p">(</span><a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">m</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Computes a dot-product of two vectors.</p>
<p>The method computes a dot-product of two matrices. If the matrices are not single-column or single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D vectors. The vectors must have the same size and type. If the matrices have more than one channel, the dot products from all the channels are summed together.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>another dot-product operand.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aba7a5ef00b22b70668fba575005dfe55">
<span id="index-68"></span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
<span class="n">elemSize</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the matrix element size in bytes.</p>
<p>The method returns the matrix element size in bytes. For example, if the matrix type is CV_16SC3 , the method returns 3*sizeof(short) or 6.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a9acde8f32d4b294558fb406bc05171bc">
<span id="index-69"></span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
<span class="n">elemSize1</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the size of each matrix element channel in bytes.</p>
<p>The method returns the matrix element channel size in bytes, that is, it ignores the number of channels. For example, if the matrix type is CV_16SC3 , the method returns sizeof(short) or 2.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1abbec3525a852e77998aba034813fded4">
<span id="index-70"></span><span></span><span class="kt">bool</span>
<span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns true if the array has no elements.</p>
<p>The method returns true if <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa4d317d43fb0cba9c2503f3c61b866c8"><span class="std std-ref">Mat::total()</span></a> is 0 or if <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4d33bed1c850265370d2af0ff02e1564"><span class="std std-ref">Mat::data</span></a> is NULL. Because of <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a88bbb01901fdfe3f1d0592c592e8757c"><span class="std std-ref">pop_back()</span></a> and <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ad0127b138acfcc2dcd5dafc51175b309"><span class="std std-ref">resize()</span></a> methods <code class="docutils literal notranslate"><span class="pre">M.total()</span> <span class="pre">==</span> <span class="pre">0</span></code> does not imply that <code class="docutils literal notranslate"><span class="pre">M.data</span> <span class="pre">==</span> <span class="pre">NULL</span></code>.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a9dd628eeccedea6e181ca54d41830a62">
<span id="index-71"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<a class="reference internal" href="class_cv_MatIterator_.html#doxid-da-d1f-classcv-1-1-mat-iterator"><span class="std std-ref">MatIterator_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">end</span><span class="p">()</span>
</pre>
<p>Returns the matrix iterator and sets it to the after-last matrix element.</p>
<p>The methods return the matrix read-only or read-write iterators, set to the point following the last matrix element.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a952ef1a85d70a510240cb645a90efc0d">
<span id="index-72"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">Functor</span>
    <span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">forEach</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">)</span>
</pre>
<p>Runs the given functor over all matrix elements in parallel.</p>
<p>The operation passed as argument has to be a function pointer, a function object or a lambda(C++11).</p>
<p>Example 1. All of the operations below put 0xFF the first channel of all matrix elements:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="nf">image</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">Pixel</span><span class="p">;</span>

<span class="c1">// first. raw pointer access.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pixel</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">Pixel</span><span class="o">*</span> <span class="n">ptr_end</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">ptr_end</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Using MatIterator. (Simple but there are a Iterator&#39;s overhead)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Pixel</span> <span class="o">&amp;</span><span class="nl">p</span> <span class="p">:</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">image</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Parallel execution with function object.</span>
<span class="k">struct</span> <span class="n">Operator</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()(</span><span class="n">Pixel</span> <span class="o">&amp;</span><span class="n">pixel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">image</span><span class="p">.</span><span class="n">forEach</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Operator</span><span class="p">());</span>

<span class="c1">// Parallel execution using C++11 lambda.</span>
<span class="n">image</span><span class="p">.</span><span class="n">forEach</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">Pixel</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">position</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="p">});</span>
</pre>
<p>Example 2. Using the pixelâ€™s position:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// Creating 3D matrix (255 x 255 x 255) typed uint8_t</span>
<span class="c1">// and initialize all elements by the value which equals elements position.</span>
<span class="c1">// i.e. pixels (x,y,z) = (1,2,3) is (b,g,r) = (1,2,3).</span>

<span class="kt">int</span> <span class="n">sizes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span> <span class="p">};</span>
<span class="k">typedef</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">Pixel</span><span class="p">;</span>

<span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>

<span class="n">image</span><span class="p">.</span><span class="n">forEach</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Pixel</span><span class="o">&amp;</span> <span class="n">pixel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">position</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">});</span>
</pre>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1afcee31e71fd6991148fd3bb619971e2b">
<span id="index-73"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">Functor</span>
    <span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">forEach</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a8676ddda9951ec3766efe0265d808a71">
<span id="index-74"></span><a class="reference internal" href="class_cv_UMat.html#doxid-d8-d82-classcv-1-1-u-mat"><span class="std std-ref">UMat</span></a><span></span>
<span class="n">getUMat</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">accessFlags</span><span class="p">,</span>
    <a class="reference internal" href="enum_cv_UMatUsageFlags.html#doxid-dc-d84-group-core-basic-1ga5681439dda418431eb0a672697135ed2"><span class="std std-ref">UMatUsageFlags</span></a><span></span> <span class="n">usageFlags</span> <span class="o">=</span> <a class="reference internal" href="enum_cv_UMatUsageFlags.html#doxid-dc-d84-group-core-basic-1gga5681439dda418431eb0a672697135ed2ae383b08ee18b73d8c1588d968f953893"><span class="std std-ref">USAGE_DEFAULT</span></a><span></span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>retrieve <a class="reference internal" href="class_cv_UMat.html#doxid-d8-d82-classcv-1-1-u-mat"><span class="std std-ref">UMat</span></a> from <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a></p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a039eb3c6740a850696a12519a4b8bfc6">
<span id="index-75"></span><a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">inv</span><span class="p">(</span><span class="kt">int</span> <span class="n">method</span> <span class="o">=</span> <a class="reference internal" href="enum_cv_DecompTypes.html#doxid-d2-de8-group-core-array-1ggaaf9ea5dcc392d5ae04eacb9920b9674ca247a3455cd64973152e17e26999dc024"><span class="std std-ref">DECOMP_LU</span></a><span></span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Inverses a matrix.</p>
<p>The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>method</td>
<td>Matrix inversion method. One of <a class="reference internal" href="enum_cv_DecompTypes.html#doxid-d2-de8-group-core-array-1gaaf9ea5dcc392d5ae04eacb9920b9674c"><span class="std std-ref">cv::DecompTypes</span></a></td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa90cea495029c7d1ee0a41361ccecdf3">
<span id="index-76"></span><span></span><span class="kt">bool</span>
<span class="n">isContinuous</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Reports whether the matrix is continuous or not.</p>
<p>The method returns true if the matrix elements are stored continuously without gaps at the end of each row. Otherwise, it returns false. Obviously, 1x1 or 1xN matrices are always continuous. Matrices created with <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">Mat::create</span></a> are always continuous. But if you extract a part of the matrix using <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">Mat::col</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a024cc0510a4c61c7f266d4ab9fe13d7a"><span class="std std-ref">Mat::diag</span></a>, and so on, or constructed a matrix header for externally allocated data, such matrices may no longer have this property.</p>
<p>The continuity flag is stored as a bit in the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af9333f06c84f115fda4cdf3af18c2ad0"><span class="std std-ref">Mat::flags</span></a> field and is computed automatically when you construct a matrix header. Thus, the continuity check is a very fast operation, though theoretically it could be done as follows:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// alternative implementation of Mat::isContinuous()</span>
<span class="kt">bool</span> <span class="nf">myCheckMatContinuity</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//return (m.flags &amp; Mat::CONTINUOUS_FLAG) != 0;</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">step</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">elemSize</span><span class="p">();</span>
<span class="p">}</span>
</pre>
<p>The method is used in quite a few of OpenCV functions. The point is that element-wise operations (such as arithmetic and logical operations, math functions, alpha blending, color space transformations, and others) do not depend on the image geometry. Thus, if all the input and output arrays are continuous, the functions can process them as very long single-row vectors. The example below illustrates how an alpha-blending function can be implemented:</p>
<pre class="highlight literal-block">
<span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">alphaBlendRGBA</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src2</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span>
                <span class="n">inv_scale</span> <span class="o">=</span> <span class="mf">1.f</span><span class="o">/</span><span class="n">alpha_scale</span><span class="p">;</span>

    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">DataType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">depth</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="c1">// here is the idiom: check the arrays for continuity and,</span>
    <span class="c1">// if this is the case,</span>
    <span class="c1">// treat the arrays as 1D vectors</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">src2</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
        <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// when the arrays are continuous,</span>
        <span class="c1">// the outer loop is executed only once</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">dptr</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">;</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span><span class="o">*</span><span class="n">alpha_scale</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>This approach, while being very simple, can boost the performance of a simple element-operation by 10-20 percents, especially if the image is rather small and the operation is quite simple.</p>
<p>Another OpenCV idiom in this function, a call of <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">Mat::create</span></a> for the destination array, that allocates the destination array unless it already has the proper size and type. And while the newly allocated arrays are always continuous, you still need to check the destination array because <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a55ced2c8d844d683ea9a725c60037ad0"><span class="std std-ref">Mat::create</span></a> does not always allocate a new matrix.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ab34367822008627e80e144d7bba3bd70">
<span id="index-77"></span><span></span><span class="kt">bool</span>
<span class="n">isSubmatrix</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>returns true if the matrix is a submatrix of another matrix</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a40b5b3371a9c2a4b2b8ce0c8068d7c96">
<span id="index-78"></span><span></span><span class="kt">void</span>
<span class="n">locateROI</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span><span class="o">&amp;</span> <span class="n">wholeSize</span><span class="p">,</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga1e83eafb2d26b3c93f09e8338bcab192"><span class="std std-ref">Point</span></a><span></span><span class="o">&amp;</span> <span class="n">ofs</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Locates the matrix header within a parent matrix.</p>
<p>After you extracted a submatrix from a matrix using <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">Mat::row</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">Mat::col</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa6542193430356ad631a9beabc624107"><span class="std std-ref">Mat::rowRange</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aadc8f9210fe4dec50513746c246fa8d9"><span class="std std-ref">Mat::colRange</span></a>, and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by datastart and dataend fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method locateROI does exactly that.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>wholeSize</td>
<td>Output parameter that contains the size of the whole matrix containing <em>this</em> as a part.</td>
</tr>
<tr class="row-even"><td>ofs</td>
<td>Output parameter that contains an offset of <em>this</em> inside the whole matrix.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a385c09827713dc3e6d713bfad8460706">
<span id="index-79"></span><a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">mul</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">m</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Performs an element-wise multiplication or division of the two matrices.</p>
<p>The method returns a temporary object encoding per-element array multiplication, with optional scale. Note that this is not a matrix multiplication that corresponds to a simpler â€œ\*â€ operator.</p>
<p>Example:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="n">B</span><span class="p">);</span> <span class="c1">// equivalent to divide(A, B, C, 5)</span>
</pre>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Another array of the same type and the same size as *this, or a matrix expression.</td>
</tr>
<tr class="row-even"><td>scale</td>
<td>Optional scale factor.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ad543b6bd296ae1247032c750af4718e1">
<span id="index-80"></span><span></span><span class="n">Mat</span>
<span class="k">operator</span><span class="p">()(</span>
    <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span> <span class="n">rowRange</span><span class="p">,</span>
    <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span> <span class="n">colRange</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Extracts a rectangular submatrix.</p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">Mat::row</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">Mat::col</span></a>, <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa6542193430356ad631a9beabc624107"><span class="std std-ref">Mat::rowRange</span></a>, and <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aadc8f9210fe4dec50513746c246fa8d9"><span class="std std-ref">Mat::colRange</span></a>. For example, <code class="docutils literal notranslate"><span class="pre">A(Range(0,</span> <span class="pre">10),</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref"><span class="pre">Range::all()</span></span></a><span class="pre">)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">A.rowRange(0,</span> <span class="pre">10)</span></code>. Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rowRange</td>
<td>Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref">Range::all()</span></a>.</td>
</tr>
<tr class="row-even"><td>colRange</td>
<td>Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range-1af5a0207f6f98a69077db8e77898abc0f"><span class="std std-ref">Range::all()</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a4272fce43d7405603fbb5e5f52580e57">
<span id="index-81"></span><span></span><span class="n">Mat</span>
<span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga11d95de507098e90bad732b9345402e8"><span class="std std-ref">Rect</span></a><span></span><span class="o">&amp;</span> <span class="n">roi</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>roi</td>
<td>Extracted submatrix specified as a rectangle.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aee56475f834069b1fad3877c0747aaeb">
<span id="index-82"></span><span></span><span class="n">Mat</span>
<span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">*</span> <span class="n">ranges</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ranges</td>
<td>Array of selected ranges along each array dimension.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa9bf4fcbb6e854a6db7b7254a205fac9">
<span id="index-83"></span><span></span><span class="n">Mat</span>
<span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&gt;&amp;</span> <span class="n">ranges</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ranges</td>
<td>Array of selected ranges along each array dimension.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aed1f81fe7efaacc2bd95149cdfa34302">
<span id="index-84"></span><span></span><span class="n">Mat</span><span class="o">&amp;</span>
<span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
</pre>
<p>assignment operators</p>
<p>These are available assignment operators. Since they all are very different, make sure to read the operator parameters description.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Assigned, right-hand-side matrix. Matrix assignment is an O(1) operation. This means that no data is copied but the data is shared and the reference counter, if any, is incremented. Before assigning new data, the old data is de-referenced via <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1ae48d4913285518e2c21a3457017e716e"><span class="std std-ref">Mat::release</span></a>.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2a0798475170fb3a23b5bc63686de334">
<span id="index-85"></span><span></span><span class="n">Mat</span><span class="o">&amp;</span>
<span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span><span class="o">&amp;</span> <span class="n">expr</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>expr</td>
<td>Assigned matrix expression object. As opposite to the first form of the assignment operation, the second form can reuse already allocated matrix if it has the right size and type to fit the matrix expression result. It is automatically handled by the real function that the matrix expressions is expanded to. For example, C=A+B is expanded to add(A, B, C), and add takes care of automatic C reallocation.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50">
<span id="index-86"></span><span></span><span class="n">Mat</span><span class="o">&amp;</span>
<span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
</pre>
<p>Sets all or some of the array elements to the specified value.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>s</td>
<td>Assigned scalar converted to the actual array type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a88bbb01901fdfe3f1d0592c592e8757c">
<span id="index-87"></span><span></span><span class="kt">void</span>
<span class="n">pop_back</span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">nelems</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre>
<p>Removes elements from the bottom of the matrix.</p>
<p>The method removes one or more rows from the bottom of the matrix.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>nelems</td>
<td>Number of removed rows. If it is greater than the total number of rows, an exception is thrown.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a13acd320291229615ef15f96ff1ff738">
<span id="index-88"></span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p>Returns a pointer to the specified matrix row.</p>
<p>The methods return <code class="docutils literal notranslate"><span class="pre">uchar*</span></code> or typed pointer to the specified matrix row. See the sample in <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa90cea495029c7d1ee0a41361ccecdf3"><span class="std std-ref">Mat::isContinuous</span></a> to know how to use these methods.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>i0</td>
<td>A 0-based row index.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1af13f821918f452657f53bc3f750323cb">
<span id="index-89"></span><span></span><span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1af774caab4a38c6f7890f3254ad71eccf">
<span id="index-90"></span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>row</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>col</td>
<td>Index along the dimension 1</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1abcfcc1798528b49495e1263eab31127d">
<span id="index-91"></span><span></span><span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>row</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>col</td>
<td>Index along the dimension 1</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ad2bc0c6a23243540e16607868c17be92">
<span id="index-92"></span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i2</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1abfb233ffa8b26a78c36e733f61da2a3e">
<span id="index-93"></span><span></span><span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i2</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ab0e3de187bb27c384269b243e8789ba9">
<span id="index-94"></span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a3ef72b9ebc9581796ed68382df8fb064">
<span id="index-95"></span><span></span><span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a7ce1d8cc9a83ae7cab79766d0eb6c0a8">
<span id="index-96"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
<a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a9ea1a1bfbbb2393a4e162230dccbe1f0">
<span id="index-97"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">const</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a5a9ffc908ac90604f36a8b6a1038747d">
<span id="index-98"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a6a6b3696440fe48751bfe60fe2a729f3">
<span id="index-99"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a6f4278ede80e7a9fe55d8b03710e2343">
<span id="index-100"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>row</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>col</td>
<td>Index along the dimension 1</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1abda2b96aa438a808b43425040a7da81a">
<span id="index-101"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>row</td>
<td>Index along the dimension 0</td>
</tr>
<tr class="row-even"><td>col</td>
<td>Index along the dimension 1</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2bf43f93c5cb610b657bd6e0e091c062">
<span id="index-102"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i2</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a476f18d2b8d99748005150b24752512d">
<span id="index-103"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">i0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">i2</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a7cb2719706bcae72d26dbc9b2fdc02e6">
<span id="index-104"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ac30da0a78cd38a72e8902f52660e2543">
<span id="index-105"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a36ab9a1de78fd00a4f9acf3c8a5d4d05">
<span id="index-106"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">n</span>
    <span class="o">&gt;</span>
<span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a15cac608c7a27fb961a81b9409aaa7e8">
<span id="index-107"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">n</span>
    <span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span>
<span class="n">ptr</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Vec.html#doxid-db-d93-classcv-1-1-vec"><span class="std std-ref">Vec</span></a><span></span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1af4bd5c2cb936dd363816d867aab22a61">
<span id="index-108"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
</pre>
<p>Adds elements to the bottom of the matrix.</p>
<p>The methods add one or more elements to the bottom of the matrix. They emulate the corresponding method of the STL vector class. When elem is <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a>, its type and the number of columns must be the same as in the container matrix.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>elem</td>
<td>Added element(s).</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a1cfeb3a75570697426971403fc1ddb0d">
<span id="index-109"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Mat_.html#doxid-d9-de0-classcv-1-1-mat"><span class="std std-ref">Mat_</span></a><span></span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">elem</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>elem</td>
<td>Added element(s).</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a3676bae1741459eda3771e8653357c53">
<span id="index-110"></span><span></span><span class="kt">void</span>
<span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>Added line(s).</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a57c658e2a97dda24fef1be2e625da914">
<span id="index-111"></span><span></span><span class="kt">void</span>
<span class="n">push_back_</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">elem</span><span class="p">)</span>
</pre>
<p>internal function</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ae48d4913285518e2c21a3457017e716e">
<span id="index-112"></span><span></span><span class="kt">void</span>
<span class="n">release</span><span class="p">()</span>
</pre>
<p>Decrements the reference counter and deallocates the matrix if needed.</p>
<p>The method decrements the reference counter associated with the matrix data. When the reference counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers are set to NULLâ€™s. If the matrix header points to an external data set (see <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1af1d014cecd1510cdf580bf2ed7e5aafc"><span class="std std-ref">Mat::Mat</span></a>), the reference counter is NULL, and the method has no effect in this case.</p>
<p>This method can be called manually to force the matrix data deallocation. But since this method is automatically called in the destructor, or by any other method that changes the data pointer, it is usually not needed. The reference counter decrement and check for 0 is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a0706ed6c42e288926c5ad415b976bbe2">
<span id="index-113"></span><span></span><span class="kt">void</span>
<span class="n">reserve</span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">)</span>
</pre>
<p>Reserves space for the certain number of rows.</p>
<p>The method reserves space for sz rows. If the matrix already has enough space to store sz rows, nothing happens. If the matrix is reallocated, the first <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1abed816466c45234254d25bc59c31245e"><span class="std std-ref">Mat::rows</span></a> rows are preserved. The method emulates the corresponding method of the STL vector class.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sz</td>
<td>Number of rows.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a923eead22fe7f0c48aa000158df920f3">
<span id="index-114"></span><span></span><span class="kt">void</span>
<span class="n">reserveBuffer</span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">)</span>
</pre>
<p>Reserves space for the certain number of bytes.</p>
<p>The method reserves space for sz bytes. If the matrix already has enough space to store sz bytes, nothing happens. If matrix has to be reallocated its previous content could be lost.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sz</td>
<td>Number of bytes.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a4eb96e3251417fa88b78e2abd6cfd7d8">
<span id="index-115"></span><span></span><span class="n">Mat</span>
<span class="n">reshape</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Changes the shape and/or the number of channels of a 2D matrix without copying the data.</p>
<p>The method makes a new matrix header for *this elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if:</p>
<ul class="simple">
<li>No extra elements are included into the new matrix and no elements are excluded. Consequently, the product rows*cols*channels() must stay the same after the transformation.</li>
<li>No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row in some other way, the matrix must be continuous. See <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa90cea495029c7d1ee0a41361ccecdf3"><span class="std std-ref">Mat::isContinuous</span></a>.</li>
</ul>
<p>For example, if there is a set of 3D points stored as an STL vector, and you want to represent the points as a 3xN matrix, do the following:</p>
<pre class="highlight literal-block">
<span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3f</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">pointMat</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">vec</span><span class="p">).</span> <span class="c1">// convert vector to Mat, O(1) operation</span>
                  <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span> <span class="c1">// make Nx3 1-channel matrix out of Nx1 3-channel.</span>
                              <span class="c1">// Also, an O(1) operation</span>
                     <span class="n">t</span><span class="p">();</span> <span class="c1">// finally, transpose the Nx3 matrix.</span>
                          <span class="c1">// This involves copying all the elements</span>
</pre>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cn</td>
<td>New number of channels. If the parameter is 0, the number of channels remains the same.</td>
</tr>
<tr class="row-even"><td>rows</td>
<td>New number of rows. If the parameter is 0, the number of rows remains the same.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a50e606fe51f53b896b66051634a018fb">
<span id="index-116"></span><span></span><span class="n">Mat</span>
<span class="n">reshape</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">newndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">newsz</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ab2e41a510891e548f744832cf9b8ab89">
<span id="index-117"></span><span></span><span class="n">Mat</span>
<span class="n">reshape</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">cn</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">newshape</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1ad0127b138acfcc2dcd5dafc51175b309">
<span id="index-118"></span><span></span><span class="kt">void</span>
<span class="n">resize</span><span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">)</span>
</pre>
<p>Changes the number of matrix rows.</p>
<p>The methods change the number of matrix rows. If the matrix is reallocated, the first min(Mat::rows, sz) rows are preserved. The methods emulate the corresponding methods of the STL vector class.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sz</td>
<td>New number of rows.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1abdbf4852beb3af95977fa289f6c7034c">
<span id="index-119"></span><span></span><span class="kt">void</span>
<span class="n">resize</span><span class="p">(</span>
    <a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span> <span class="n">sz</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga599fe92e910c027be274233eccad7beb"><span class="std std-ref">Scalar</span></a><span></span><span class="o">&amp;</span> <span class="n">s</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sz</td>
<td>New number of rows.</td>
</tr>
<tr class="row-even"><td>s</td>
<td>Value assigned to the newly added elements.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434">
<span id="index-120"></span><span></span><span class="n">Mat</span>
<span class="n">row</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Creates a matrix header for the specified matrix row.</p>
<p>The method makes a new header for the specified matrix row and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. Here is the example of one of the classical basic matrix processing operations, axpy, used by LU and many other algorithms:</p>
<pre class="highlight literal-block">
<span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">matrix_axpy</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>In the current implementation, the following code does not work as expected:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// will not work</span>
</pre>
<p>This happens because A.row(i) forms a temporary header that is further assigned to another header. Remember that each of these operations is O(1), that is, no data is copied. Thus, the above assignment is not true if you may have expected the j-th row to be copied to the i-th row. To achieve that, you should either turn this simple assignment into an expression or use the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a33fd5d125b4c302b0c9aa86980791a77"><span class="std std-ref">Mat::copyTo</span></a> method:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// works, but looks a bit obscure.</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// this is a bit longer, but the recommended method.</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>y</td>
<td>A 0-based row index.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa6542193430356ad631a9beabc624107">
<span id="index-121"></span><span></span><span class="n">Mat</span>
<span class="n">rowRange</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">startrow</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">endrow</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Creates a matrix header for the specified row span.</p>
<p>The method makes a new header for the specified row span of the matrix. Similarly to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a4b22e1c23af7a7f2eef8fa478cfa7434"><span class="std std-ref">Mat::row</span></a> and <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a23df02a07ffbfa4aa59c19bc003919fe"><span class="std std-ref">Mat::col</span></a>, this is an O(1) operation.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>startrow</td>
<td>An inclusive 0-based start index of the row span.</td>
</tr>
<tr class="row-even"><td>endrow</td>
<td>An exclusive 0-based ending index of the row span.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a6f5b8257ea38a26295944e9a69caf7e7">
<span id="index-122"></span><span></span><span class="n">Mat</span>
<span class="n">rowRange</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a><span></span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>r</td>
<td><a class="reference internal" href="class_cv_Range.html#doxid-d7-d65-classcv-1-1-range"><span class="std std-ref">Range</span></a> structure containing both the start and the end indices.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a0440e2a164c0b0d8462fb1e487be9876">
<span id="index-123"></span><span></span><span class="n">Mat</span><span class="o">&amp;</span>
<span class="n">setTo</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">value</span><span class="p">,</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga353a9de602fe76c709e12074a6f362ba"><span class="std std-ref">InputArray</span></a><span></span> <span class="n">mask</span> <span class="o">=</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1gad9287b23bba2fed753b36ef561ae7346"><span class="std std-ref">noArray</span></a><span></span><span class="p">()</span>
    <span class="p">)</span>
</pre>
<p>Sets all or some of the array elements to the specified value.</p>
<p>This is an advanced variant of the <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1aa5c947f7e449a4d856a4f3a87fcebd50"><span class="std std-ref">Mat::operator=(const Scalar&amp; s)</span></a> operator.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>value</td>
<td>Assigned scalar converted to the actual array type.</td>
</tr>
<tr class="row-even"><td>mask</td>
<td>Operation mask of the same size as *this.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a0066c8eee40c1706395b1e57f00e0857">
<span id="index-124"></span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
<span class="n">step1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span>
</pre>
<p>Returns a normalized step.</p>
<p>The method returns a matrix step divided by <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a9acde8f32d4b294558fb406bc05171bc"><span class="std std-ref">Mat::elemSize1()</span></a>. It can be useful to quickly access an arbitrary matrix element.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aaa428c60ccb6d8ea5de18f63dfac8e11">
<span id="index-125"></span><a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">t</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Transposes a matrix.</p>
<p>The method performs matrix transposition by means of matrix expressions. It does not perform the actual transposition but returns a temporary matrix transposition object that can be further used as a part of more complex matrix expressions or can be assigned to a matrix:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">A1</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">())</span><span class="o">*</span><span class="n">lambda</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A1</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">A1</span><span class="p">;</span> <span class="c1">// compute (A + lambda*I)^t * (A + lamda*I)</span>
</pre>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aa4d317d43fb0cba9c2503f3c61b866c8">
<span id="index-126"></span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
<span class="n">total</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the total number of array elements.</p>
<p>The method returns the number of array elements (a number of pixels if the array represents an image).</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a5c506fc8b2cf52375e0d8be26aae0df4">
<span id="index-127"></span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span>
<span class="n">total</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">startDim</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">endDim</span> <span class="o">=</span> <span class="n">INT_MAX</span>
    <span class="p">)</span> <span class="k">const</span>
</pre>
<p>Returns the total number of array elements.</p>
<p>The method returns the number of elements within a certain sub-array slice with startDim &lt;= dim &lt; endDim</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1af2d2652e552d7de635988f18a84b53e5">
<span id="index-128"></span><span></span><span class="kt">int</span>
<span class="n">type</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the type of a matrix element.</p>
<p>The method returns a matrix element type. This is an identifier compatible with the <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> type system, like CV_16SC3 or 16-bit signed 3-channel array, and so on.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a0f81856dbcb93eae6113947edb3ea068">
<span id="index-129"></span><span></span><span class="k">static</span>
<span class="n">Mat</span>
<span class="n">diag</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span>
</pre>
<p>creates a diagonal matrix</p>
<p>The method creates a square diagonal matrix from specified main diagonal.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>d</td>
<td>One-dimensional matrix that represents the main diagonal.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a2cf9b9acde7a9852542bbc20ef851ed2">
<span id="index-130"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">eye</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>Returns an identity matrix of the specified size and type.</p>
<p>The method returns a Matlab-style identity matrix initializer, similarly to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0b57b6a326c8876d944d188a46e0f556"><span class="std std-ref">Mat::zeros</span></a>. Similarly to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a69ae0402d116fc9c71908d8508dc2f09"><span class="std std-ref">Mat::ones</span></a>, you can use a scale operation to create a scaled identity matrix efficiently:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// make a 4x4 diagonal matrix with 0.1&#39;s on the diagonal.</span>
<span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">;</span>
</pre>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>Number of rows.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>Number of columns.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1aab87b56e1dc370ffe4afb735b6a1e5c9">
<span id="index-131"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">eye</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>Alternative matrix size specification as Size(cols, rows) .</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a8d5dda7d818009547d71a086d3d755a7">
<span id="index-132"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatAllocator.html#doxid-d4-dee-classcv-1-1-mat-allocator"><span class="std std-ref">MatAllocator</span></a><span></span><span class="o">*</span>
<span class="n">getStdAllocator</span><span class="p">()</span>
</pre>
<p>and the standard allocator</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a69ae0402d116fc9c71908d8508dc2f09">
<span id="index-133"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">ones</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>Returns an array of all 1â€™s of the specified size and type.</p>
<p>The method returns a Matlab-style 1â€™s array initializer, similarly to <a class="reference internal" href="#doxid-db-de6-classcv-1-1-mat-1a0b57b6a326c8876d944d188a46e0f556"><span class="std std-ref">Mat::zeros</span></a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// make 100x100 matrix filled with 3.</span>
</pre>
<p>The above operation does not form a 100x100 matrix of 1â€™s and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>Number of rows.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>Number of columns.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1afc9c2c0b17ecd00932bc5fbc72f9bce0">
<span id="index-134"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">ones</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>Alternative to the matrix size specification Size(cols, rows) .</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a6ed33f15d7bf0172efb62d61b3751284">
<span id="index-135"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">ones</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sz</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ndims</td>
<td>Array dimensionality.</td>
</tr>
<tr class="row-even"><td>sz</td>
<td>Array of integers specifying the array shape.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a0b57b6a326c8876d944d188a46e0f556">
<span id="index-136"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">zeros</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>Returns a zero array of the specified size and type.</p>
<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer. :</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
</pre>
<p>In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix. Otherwise, the existing matrix A is filled with zeros.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>rows</td>
<td>Number of rows.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>Number of columns.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a095db10924bc801644a29074a755b6e9">
<span id="index-137"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">zeros</span><span class="p">(</span>
    <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span> <span class="n">size</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>size</td>
<td>Alternative to the matrix size specification Size(cols, rows) .</td>
</tr>
<tr class="row-even"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-db-de6-classcv-1-1-mat-1a961cf7d4f82253d93bb5b8ff54522087">
<span id="index-138"></span><span></span><span class="k">static</span>
<a class="reference internal" href="class_cv_MatExpr.html#doxid-d9-ddc-classcv-1-1-mat-expr"><span class="std std-ref">MatExpr</span></a><span></span>
<span class="n">zeros</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sz</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">type</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ndims</td>
<td>Array dimensionality.</td>
</tr>
<tr class="row-even"><td>sz</td>
<td>Array of integers specifying the array shape.</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>Created matrix type.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="class_cv_MatAllocator.html" class="btn btn-neutral float-right" title="class cv::MatAllocator" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="class_cv_KeyPoint.html" class="btn btn-neutral float-left" title="class cv::KeyPoint" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2017, OpenCV Maintainers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>