

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Interoperability with OpenCV 1 &mdash; OpenCV Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/target-highlight.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/doxyrest-pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/doxyrest-sphinx_rtd_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Mask operations on matrices" href="page_tutorial_mat_mask_operations.html" />
    <link rel="prev" title="Intel® IPP Asynchronous C/C++ library in OpenCV" href="page_tutorial_how_to_use_ippa_conversion.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> OpenCV Documentation
          

          
          </a>

          
            
            
              <div class="version">
                3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="group_features2d.html">2D Features Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_viz.html">3D Visualizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_calib3d.html">Camera Calibration and 3D Reconstruction</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_flann.html">Clustering and Search in Multi-Dimensional Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_photo.html">Computational Photography</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_core.html">Core functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_highgui.html">High-level GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_imgcodecs.html">Image file reading and writing</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_imgproc.html">Image processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_stitching.html">Images stitching</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_ml.html">Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_objdetect.html">Object Detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_shape.html">Shape Distance and Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_superres.html">Super Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_video.html">Video Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_videoio.html">Video I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="group_videostab.html">Video Stabilization</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="page_citelist.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_cuda_intro.html">CUDA Module Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_imgproc_color_conversions.html">Color conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_deprecated.html">Deprecated List</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_ml_intro.html">Machine Learning Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="page_tutorial_root.html">OpenCV Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_features2d.html">2D Features framework (feature2d module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_calib3d.html">Camera calibration and 3D reconstruction (calib3d module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_photo.html">Computational photography (photo module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_gpu.html">GPU-Accelerated Computer Vision (cuda module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_highgui.html">High Level GUI and Media (highgui module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_imgcodecs.html">Image Input and Output (imgcodecs module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_imgproc.html">Image Processing (imgproc module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_stitching.html">Images stitching (stitching module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_introduction.html">Introduction to OpenCV</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_ml.html">Machine Learning (ml module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_objdetect.html">Object Detection (objdetect module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_viz.html">OpenCV Viz</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_ios.html">OpenCV iOS</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="page_tutorial_table_of_content_core.html">The Core Functionality (core module)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_adding_images.html">Adding (blending) two images using OpenCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_basic_geometric_drawing.html">Basic Drawing</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_basic_linear_transform.html">Changing the contrast and brightness of an image!</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_discrete_fourier_transform.html">Discrete Fourier Transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_file_input_output_with_xml_yml.html">File Input and Output using XML and YAML files</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_how_to_scan_images.html">How to scan images, lookup tables and time measurement with OpenCV</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_how_to_use_OpenCV_parallel_for_.html">How to use the OpenCV parallel_for_ to parallelize your code</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_how_to_use_ippa_conversion.html">Intel® IPP Asynchronous C/C++ library in OpenCV</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Interoperability with OpenCV 1</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_mat_mask_operations.html">Mask operations on matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_mat_the_basic_image_container.html">Mat - The Basic Image Container</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_mat_operations.html">Operations with images</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_tutorial_random_generator_and_text.html">Random generator and text with OpenCV</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_videoio.html">Video Input and Output (videoio module)</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_tutorial_table_of_content_video.html">Video analysis (video module)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="page_index.html">OpenCV modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_tutorial_py_root.html">OpenCV-Python Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_todo.html">Todo List</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_videoio_overview.html">Video I/O with OpenCV Overview</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example_contours2.cpp.html">contours2.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_convexhull.cpp.html">convexhull.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_cout_mat.cpp.html">cout_mat.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_demhist.cpp.html">demhist.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_distrans.cpp.html">distrans.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_edge.cpp.html">edge.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_ffilldemo.cpp.html">ffilldemo.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_filestorage.cpp.html">filestorage.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_fitellipse.cpp.html">fitellipse.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_grabcut.cpp.html">grabcut.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_houghcircles.cpp.html">houghcircles.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_houghlines.cpp.html">houghlines.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_kmeans.cpp.html">kmeans.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_laplace.cpp.html">laplace.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_lsd_lines.cpp.html">lsd_lines.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_minarea.cpp.html">minarea.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_morphology2.cpp.html">morphology2.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_pca.cpp.html">pca.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_polar_transforms.cpp.html">polar_transforms.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_segment_objects.cpp.html">segment_objects.cpp</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_watershed.cpp.html">watershed.cpp</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="global.html">Global Namespace</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">OpenCV Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="page_tutorial_root.html">OpenCV Tutorials</a> &raquo;</li>
        
          <li><a href="page_tutorial_table_of_content_core.html">The Core Functionality (core module)</a> &raquo;</li>
        
      <li>Interoperability with OpenCV 1</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="interoperability-with-opencv-1">
<span id="doxid-dd-d90-tutorial-interoperability-with-open-c-v-1"></span><span id="index-0"></span><h1>Interoperability with OpenCV 1</h1>
<p class="rubric">Goal</p>
<p>For the OpenCV developer team it’s important to constantly improve the library. We are constantly thinking about methods that will ease your work process, while still maintain the libraries flexibility. The new C++ interface is a development of us that serves this goal. Nevertheless, backward compatibility remains important. We do not want to break your code written for earlier version of the OpenCV library. Therefore, we made sure that we add some functions that deal with this. In the following you’ll learn:</p>
<ul class="simple">
<li>What changed with the version 2 of OpenCV in the way you use the library compared to its first version</li>
<li>How to add some Gaussian noise to an image</li>
<li>What are lookup tables and why use them?</li>
</ul>
<p class="rubric">General</p>
<p>When making the switch you first need to learn some about the new data structure for images: <a class="reference internal" href="page_tutorial_mat_the_basic_image_container.html#doxid-d6-d6d-tutorial-mat-the-basic-image-container"><span class="std std-ref">Mat - The Basic Image Container</span></a>, this replaces the old <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> and <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> ones. Switching to the new functions is easier. You just need to remember a couple of new things.</p>
<p>OpenCV 2 received reorganization. No longer are all the functions crammed into a single library. We have many modules, each of them containing data structures and functions relevant to certain tasks. This way you do not need to ship a large library if you use just a subset of OpenCV. This means that you should also include only those headers you will use. For example:</p>
<pre class="highlight literal-block">
<span></span><span class="cp">#include</span> <span class="cpf">&lt;opencv2/core.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;opencv2/imgproc.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;opencv2/highgui.hpp&gt;</span>
</pre>
<p>All the OpenCV related stuff is put into the <em>cv</em> namespace to avoid name conflicts with other libraries data structures and functions. Therefore, either you need to prepend the <em>cv::</em> keyword before everything that comes from OpenCV or after the includes, you just add a directive to use this:</p>
<pre class="highlight literal-block">
<span></span><span class="k">using</span> <span class="k">namespace</span> <a class="reference internal" href="namespace_cv.html#doxid-d2-d75-namespacecv"><span class="std std-ref">cv</span></a><span></span><span class="p">;</span>  <span class="c1">// The new C++ interface API is inside this namespace. Import it.</span>
</pre>
<p>Because the functions are already in a namespace there is no need for them to contain the <em>cv</em> prefix in their name. As such all the new C++ compatible functions don’t have this and they follow the camel case naming rule. This means the first letter is small (unless it’s a name, like Canny) and the subsequent words start with a capital letter (like <em>copyMakeBorder</em>).</p>
<p>Now, remember that you need to link to your application all the modules you use, and in case you are on Windows using the <em>DLL</em> system you will need to add, again, to the path all the binaries. For more in-depth information if you’re on Windows read <a class="reference internal" href="page_tutorial_windows_visual_studio_Opencv.html#doxid-d6-d81-tutorial-windows-visual-studio-opencv"><span class="std std-ref">How to build applications with OpenCV inside the “Microsoft Visual Studio”</span></a> and for Linux an example usage is explained in <a class="reference internal" href="page_tutorial_linux_eclipse.html#doxid-d7-d16-tutorial-linux-eclipse"><span class="std std-ref">Using OpenCV with Eclipse (plugin CDT)</span></a>.</p>
<p>Now for converting the <em>Mat</em> object you can use either the <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> or the <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> operators. While in the C interface you used to work with pointers here it’s no longer the case. In the C++ interface we have mostly <em>Mat</em> objects. These objects may be freely converted to both <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> and <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> with simple assignment. For example:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">I</span><span class="p">;</span>
<a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a><span></span> <span class="n">pI</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
<a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a><span></span>    <span class="n">mI</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
</pre>
<p>Now if you want pointers the conversion gets just a little more complicated. The compilers can no longer automatically determinate what you want and as you need to explicitly specify your goal. This is to call the <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> and <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a> operators and then get their pointers. For getting the pointer we use the &amp; sign:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="n">I</span><span class="p">;</span>
<a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a><span></span><span class="o">*</span> <span class="n">pI</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">I</span><span class="p">.</span><span class="k">operator</span> <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a><span></span><span class="p">();</span>
<a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a><span></span><span class="o">*</span> <span class="n">mI</span>        <span class="o">=</span>  <span class="o">&amp;</span><span class="n">I</span><span class="p">.</span><span class="k">operator</span> <a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a><span></span><span class="p">();</span>
</pre>
<p>One of the biggest complaints of the C interface is that it leaves all the memory management to you. You need to figure out when it is safe to release your unused objects and make sure you do so before the program finishes or you could have troublesome memory leeks. To work around this issue in OpenCV there is introduced a sort of smart pointer. This will automatically release the object when it’s no longer in use. To use this declare the pointers as a specialization of the <em>Ptr</em> :</p>
<pre class="highlight literal-block">
<span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IplImage</span><span class="o">&gt;</span> <span class="n">piI</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">I</span><span class="p">.</span><span class="k">operator</span> <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a><span></span><span class="p">();</span>
</pre>
<p>Converting from the C data structures to the <em>Mat</em> is done by passing these inside its constructor. For example:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Mat</span> <span class="nf">K</span><span class="p">(</span><span class="n">piL</span><span class="p">),</span> <span class="n">L</span><span class="p">;</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">pI</span><span class="p">);</span>
</pre>
<p class="rubric">A case study</p>
<p>Now that you have the basics done <a class="reference external" href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp">here’s</a> an example that mixes the usage of the C interface with the C++ one. You will also find it in the sample directory of the OpenCV source code library at the <code class="docutils literal notranslate"><span class="pre">samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp</span></code>. To further help on seeing the difference the programs supports two modes: one mixed C and C++ and one pure C++. If you define the <em>DEMO_MIXED_API_USE</em> you’ll end up using the first. The program separates the color planes, does some modifications on them and in the end merge them back together.</p>
<pre class="highlight literal-block">
<span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;opencv2/imgproc.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;opencv2/imgcodecs.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;opencv2/highgui.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <a class="reference internal" href="namespace_cv.html#doxid-d2-d75-namespacecv"><span class="std std-ref">cv</span></a><span></span><span class="p">;</span>  <span class="c1">// The new C++ interface API is inside this namespace. Import it.</span>
<span class="k">using</span> <span class="k">namespace</span> <a class="reference internal" href="namespace_std.html#doxid-d8-dcc-namespacestd"><span class="std std-ref">std</span></a><span></span><span class="p">;</span>
</pre>
<pre class="highlight literal-block">
<span></span><span class="c1">// comment out the define to use only the latest C++ API</span>
<span class="cp">#define DEMO_MIXED_API_USE</span>

<span class="cp">#ifdef DEMO_MIXED_API_USE</span>
<span class="cp">#  include &lt;opencv2/highgui/highgui_c.h&gt;</span>
<span class="cp">#  include &lt;opencv2/imgcodecs/imgcodecs_c.h&gt;</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">help</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">imagename</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;../data/lena.jpg&quot;</span><span class="p">;</span>

<span class="cp">#ifdef DEMO_MIXED_API_USE</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IplImage</span><span class="o">&gt;</span> <span class="n">IplI</span><span class="p">(</span><a class="reference internal" href="group_imgcodecs_c.html#doxid-da-d0a-group-imgcodecs-c-1ga93b9ddb9fbd8978d27f5a19c6751edcf"><span class="std std-ref">cvLoadImage</span></a><span></span><span class="p">(</span><span class="n">imagename</span><span class="p">));</span>      <span class="c1">// Ptr&lt;T&gt; is a safe ref-counting pointer class</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">IplI</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Can not load image &quot;</span> <span class="o">&lt;&lt;</span>  <span class="n">imagename</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Mat</span> <span class="n">I</span> <span class="o">=</span> <a class="reference internal" href="group_core_c_glue.html#doxid-d8-dd7-group-core-c-glue-1gafa8ade391d84ed9278c336fd0a58f4e1"><span class="std std-ref">cv::cvarrToMat</span></a><span></span><span class="p">(</span><span class="n">IplI</span><span class="p">);</span> <span class="c1">// Convert to the new style container. Only header created. Image not copied.</span>
<span class="cp">#else</span>
    <span class="n">Mat</span> <span class="n">I</span> <span class="o">=</span> <a class="reference internal" href="group_imgcodecs.html#doxid-d4-da8-group-imgcodecs-1ga288b8b3da0892bd651fce07b3bbd3a56"><span class="std std-ref">imread</span></a><span></span><span class="p">(</span><span class="n">imagename</span><span class="p">);</span>        <span class="c1">// the newer cvLoadImage alternative, MATLAB-style function</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">I</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>                   <span class="c1">// same as if( !I.data )</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Can not load image &quot;</span> <span class="o">&lt;&lt;</span>  <span class="n">imagename</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>
</pre>
<p>Here you can observe that with the new structure we have no pointer problems, although it is possible to use the old functions and in the end just transform the result to a <em>Mat</em> object.</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// convert image to YUV color space. The output image will be created automatically.</span>
<span class="n">Mat</span> <span class="n">I_YUV</span><span class="p">;</span>
<a class="reference internal" href="group_imgproc_misc.html#doxid-d7-d1b-group-imgproc-misc-1ga397ae87e1288a81d2363b61574eb8cab"><span class="std std-ref">cvtColor</span></a><span></span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">I_YUV</span><span class="p">,</span> <a class="reference internal" href="enum_cv_ColorConversionCodes.html#doxid-d7-d1b-group-imgproc-misc-1gga4e0972be5de079fed4e3a10e24ef5ef0a63f063ef276a066c4e122997cfd55d6e"><span class="std std-ref">COLOR_BGR2YCrCb</span></a><span></span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">planes</span><span class="p">;</span>    <span class="c1">// Use the STL&#39;s vector structure to store multiple Mat objects</span>
<a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1ga0547c7fed86152d7e9d0096029c8518a"><span class="std std-ref">split</span></a><span></span><span class="p">(</span><span class="n">I_YUV</span><span class="p">,</span> <span class="n">planes</span><span class="p">);</span>  <span class="c1">// split the image into separate color planes (Y U V)</span>
</pre>
<p>Because, we want to mess around with the images luma component we first convert from the default BGR to the YUV color space and then split the result up into separate planes. Here the program splits: in the first example it processes each plane using one of the three major image scanning algorithms in OpenCV (C [] operator, iterator, individual element access). In a second variant we add to the image some Gaussian noise and then mix together the channels according to some formula.</p>
<p>The scanning version looks like:</p>
<pre class="highlight literal-block">
<span></span><span class="c1">// Mat scanning</span>
<span class="c1">// Method 1. process Y plane using an iterator</span>
<span class="n">MatIterator_</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">begin</span><span class="o">&lt;</span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it_end</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span> <span class="o">*</span> <span class="mf">1.7</span> <span class="o">+</span> <a class="reference internal" href="namespace_cvflann.html#doxid-dc-d8c-namespacecvflann-1a3518d4d5ff61789af64c0a5b12e9f44e"><span class="std std-ref">rand</span></a><span></span><span class="p">()</span><span class="o">%</span><span class="mi">21</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
    <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <a class="reference internal" href="group_core_utils.html#doxid-db-de0-group-core-utils-1gab93126370b85fda2c8bfaf8c811faeaf"><span class="std std-ref">saturate_cast</span></a><span></span><span class="o">&lt;</span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="o">/</span><span class="mi">255</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">I_YUV</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Method 2. process the first chroma plane using pre-stored row pointer.</span>
    <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">*</span> <span class="n">Uptr</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ptr</span><span class="o">&lt;</span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">I_YUV</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Uptr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <a class="reference internal" href="group_core_utils.html#doxid-db-de0-group-core-utils-1gab93126370b85fda2c8bfaf8c811faeaf"><span class="std std-ref">saturate_cast</span></a><span></span><span class="o">&lt;</span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&gt;</span><span class="p">((</span><span class="n">Uptr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">128</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">128</span><span class="p">);</span>

        <span class="c1">// Method 3. process the second chroma plane using individual element access</span>
        <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&amp;</span> <span class="n">Vxy</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">at</span><span class="o">&lt;</span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">Vxy</span> <span class="o">=</span>        <a class="reference internal" href="group_core_utils.html#doxid-db-de0-group-core-utils-1gab93126370b85fda2c8bfaf8c811faeaf"><span class="std std-ref">saturate_cast</span></a><span></span><span class="o">&lt;</span><a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga65f85814a8290f9797005d3b28e7e5fc"><span class="std std-ref">uchar</span></a><span></span><span class="o">&gt;</span><span class="p">((</span><span class="n">Vxy</span><span class="o">-</span><span class="mi">128</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">128</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>Here you can observe that we may go through all the pixels of an image in three fashions: an iterator, a C pointer and an individual element access style. You can read a more in-depth description of these in the <a class="reference internal" href="page_tutorial_how_to_scan_images.html#doxid-db-da5-tutorial-how-to-scan-images"><span class="std std-ref">How to scan images, lookup tables and time measurement with OpenCV</span></a> tutorial. Converting from the old function names is easy. Just remove the cv prefix and use the new <em>Mat</em> data structure. Here’s an example of this by using the weighted addition function:</p>
<pre class="highlight literal-block">
<span></span>    <span class="n">Mat</span> <span class="n">noisyI</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga32b18d904ee2b1731a9416a8eef67d06"><span class="std std-ref">CV_8U</span></a><span></span><span class="p">);</span>           <span class="c1">// Create a matrix of the specified size and type</span>

    <span class="c1">// Fills the matrix with normally distributed random values (around number with deviation off).</span>
    <span class="c1">// There is also randu() for uniformly distributed random number generation</span>
    <a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1gaeff1f61e972d133a04ce3a5f81cf6808"><span class="std std-ref">randn</span></a><span></span><span class="p">(</span><span class="n">noisyI</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>

    <span class="c1">// blur the noisyI a bit, kernel size is 3x3 and both sigma&#39;s are set to 0.5</span>
    <a class="reference internal" href="group_imgproc_filter.html#doxid-d4-d86-group-imgproc-filter-1gaabe8c836e97159a9193fb0b11ac52cf1"><span class="std std-ref">GaussianBlur</span></a><span></span><span class="p">(</span><span class="n">noisyI</span><span class="p">,</span> <span class="n">noisyI</span><span class="p">,</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">double</span> <span class="n">brightness_gain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">contrast_gain</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">;</span>

<span class="cp">#ifdef DEMO_MIXED_API_USE</span>
    <span class="c1">// To pass the new matrices to the functions that only work with IplImage or CvMat do:</span>
    <span class="c1">// step 1) Convert the headers (tip: data will not be copied).</span>
    <span class="c1">// step 2) call the function   (tip: to pass a pointer do not forget unary &quot;&amp;&quot; to form pointers)</span>

    <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a><span></span> <span class="n">cv_planes_0</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cv_noise</span> <span class="o">=</span> <span class="n">noisyI</span><span class="p">;</span>
    <a class="reference internal" href="group_core_c.html#doxid-d2-df8-group-core-c-1ga2681d8c88c806553824b6338a4c26790"><span class="std std-ref">cvAddWeighted</span></a><span></span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv_planes_0</span><span class="p">,</span> <span class="n">contrast_gain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cv_noise</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span> <span class="o">+</span> <span class="n">brightness_gain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cv_planes_0</span><span class="p">);</span>
<span class="cp">#else</span>
    <a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1gafafb2513349db3bcff51f54ee5592a19"><span class="std std-ref">addWeighted</span></a><span></span><span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">contrast_gain</span><span class="p">,</span> <span class="n">noisyI</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span> <span class="o">+</span> <span class="n">brightness_gain</span><span class="p">,</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="cp">#endif</span>

    <span class="k">const</span> <span class="kt">double</span> <span class="n">color_scale</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="c1">// Mat::convertTo() replaces cvConvertScale.</span>
    <span class="c1">// One must explicitly specify the output matrix type (we keep it intact - planes[1].type())</span>
    <span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">convertTo</span><span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span><span class="p">(),</span> <span class="n">color_scale</span><span class="p">,</span> <span class="mi">128</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">color_scale</span><span class="p">));</span>

    <span class="c1">// alternative form of cv::convertScale if we know the datatype at compile time (&quot;uchar&quot; here).</span>
    <span class="c1">// This expression will not create any temporary arrays ( so should be almost as fast as above)</span>
    <span class="n">planes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mat_</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">color_scale</span> <span class="o">+</span> <span class="mi">128</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">color_scale</span><span class="p">));</span>

    <span class="c1">// Mat::mul replaces cvMul(). Again, no temporary arrays are created in case of simple expressions.</span>
    <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mul</span><span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">);</span>
</pre>
<p>As you may observe the <em>planes</em> variable is of type <em>Mat</em>. However, converting from <em>Mat</em> to <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> is easy and made automatically with a simple assignment operator.</p>
<pre class="highlight literal-block">
<span></span>    <a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1ga7d7b4d6c6ee504b30a20b1680029c7b4"><span class="std std-ref">merge</span></a><span></span><span class="p">(</span><span class="n">planes</span><span class="p">,</span> <span class="n">I_YUV</span><span class="p">);</span>                <span class="c1">// now merge the results back</span>
    <a class="reference internal" href="group_imgproc_misc.html#doxid-d7-d1b-group-imgproc-misc-1ga397ae87e1288a81d2363b61574eb8cab"><span class="std std-ref">cvtColor</span></a><span></span><span class="p">(</span><span class="n">I_YUV</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <a class="reference internal" href="enum_cv_ColorConversionCodes.html#doxid-d7-d1b-group-imgproc-misc-1gga4e0972be5de079fed4e3a10e24ef5ef0aa6d4108b0f3d5e21dc246a0c59592b38"><span class="std std-ref">COLOR_YCrCb2BGR</span></a><span></span><span class="p">);</span>  <span class="c1">// and produce the output RGB image</span>

    <a class="reference internal" href="group_highgui.html#doxid-d7-dfc-group-highgui-1ga5afdf8410934fd099df85c75b2e0888b"><span class="std std-ref">namedWindow</span></a><span></span><span class="p">(</span><span class="s">&quot;image with grain&quot;</span><span class="p">,</span> <a class="reference internal" href="enum_cv_WindowFlags.html#doxid-d7-dfc-group-highgui-1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f"><span class="std std-ref">WINDOW_AUTOSIZE</span></a><span></span><span class="p">);</span>   <span class="c1">// use this to create images</span>

<span class="cp">#ifdef DEMO_MIXED_API_USE</span>
    <span class="c1">// this is to demonstrate that I and IplI really share the data - the result of the above</span>
    <span class="c1">// processing is stored in I and thus in IplI too.</span>
    <a class="reference internal" href="group_highgui_c.html#doxid-d0-d28-group-highgui-c-1gaaf04b3191c92b242f53940ec447facea"><span class="std std-ref">cvShowImage</span></a><span></span><span class="p">(</span><span class="s">&quot;image with grain&quot;</span><span class="p">,</span> <span class="n">IplI</span><span class="p">);</span>
<span class="cp">#else</span>
    <a class="reference internal" href="group_highgui.html#doxid-d7-dfc-group-highgui-1ga453d42fe4cb60e5723281a89973ee563"><span class="std std-ref">imshow</span></a><span></span><span class="p">(</span><span class="s">&quot;image with grain&quot;</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span> <span class="c1">// the new MATLAB style function show</span>
<span class="cp">#endif</span>
</pre>
<p>The new <em>imshow</em> highgui function accepts both the <em>Mat</em> and <a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> data structures. Compile and run the program and if the first image below is your input you may get either the first or second as output:</p>
<img alt="_images/outputInteropOpenCV1.jpg" src="_images/outputInteropOpenCV1.jpg" />
<p>You may observe a runtime instance of this on the <a class="reference external" href="https://www.youtube.com/watch?v=qckm-zvo31w">YouTube here</a> and you can <a class="reference external" href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp">download the source code from here</a> or find it in the <code class="docutils literal notranslate"><span class="pre">samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp</span></code> of the OpenCV source code library.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="page_tutorial_mat_mask_operations.html" class="btn btn-neutral float-right" title="Mask operations on matrices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="page_tutorial_how_to_use_ippa_conversion.html" class="btn btn-neutral float-left" title="Intel® IPP Asynchronous C/C++ library in OpenCV" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2017, OpenCV Maintainers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>