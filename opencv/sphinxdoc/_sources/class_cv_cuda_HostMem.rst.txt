.. index:: pair: class; cv::cuda::HostMem
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem:

class cv::cuda::HostMem
=======================

.. toctree::
	:hidden:

	enum_cv_cuda_HostMem_AllocType.rst

Overview
~~~~~~~~

Class with reference counting wrapping special memory type allocation functions from CUDA. :ref:`More...<details-da/d5b/classcv_1_1cuda_1_1_host_mem>`


.. ref-code-block:: cpp
	:class: doxyrest-overview-code-block

	#include <cuda.hpp>
	
	class HostMem
	{
	public:
		// enums
	
		enum :ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>`;

		// fields
	
		:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` :target:`alloc_type<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1adafb6e996e9e7a0d6c4696b6a186600e>`;
		int :target:`cols<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a637b04a3a6e107d9bdb16eba7ca238eb>`;
		:ref:`uchar<doxid-d1/d1b/group__core__hal__interface_1ga65f85814a8290f9797005d3b28e7e5fc>`* :target:`data<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a22e267551b43057c9371aa927cc34ee9>`;
		const :ref:`uchar<doxid-d1/d1b/group__core__hal__interface_1ga65f85814a8290f9797005d3b28e7e5fc>`* :target:`dataend<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a895b08a1958e4d6a73bd5410a7b86c3b>`;
		:ref:`uchar<doxid-d1/d1b/group__core__hal__interface_1ga65f85814a8290f9797005d3b28e7e5fc>`* :target:`datastart<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a5e62aeda0a11c82ed104ad2c0475e1fb>`;
		int :target:`flags<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1af81a4ce11a420f2905f7666d5545c674>`;
		int* :target:`refcount<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1ae3e7ec959e9a6a3142d55f1896be1b6e>`;
		int :target:`rows<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a454a7773e1423302f35819ea7720303f>`;
		:ref:`size_t<doxid-da/d06/autogenerated_2opencl__core_8hpp_1a6ff403ead16f7faa1f7228274eb6b01d>` :target:`step<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a7a34062e40db102086a987edc7f5858c>`;

		// construction
	
		:target:`HostMem<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1afa1312b9ee7032cec9a50fe81b57466d>`(:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` alloc_type = :ref:`PAGE_LOCKED<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16a968d788513648797c888aa13e056d6a4>`);
		:target:`HostMem<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1abddf8d1a9db3b9369841e2bf40e4b210>`(const HostMem& m);
	
		:target:`HostMem<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1ae60e0489e5ddadb3c66462ed0adf704e>`(
			int rows,
			int cols,
			int type,
			:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` alloc_type = :ref:`PAGE_LOCKED<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16a968d788513648797c888aa13e056d6a4>`
			);
	
		:target:`HostMem<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a6103bdd8de915a55ccfe03c8740ce9c1>`(
			:ref:`Size<doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>` size,
			int type,
			:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` alloc_type = :ref:`PAGE_LOCKED<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16a968d788513648797c888aa13e056d6a4>`
			);
	
		:ref:`HostMem<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a5a4f81b179472ac6407e0baa92cd36d7>`(
			:ref:`InputArray<doxid-dc/d84/group__core__basic_1ga353a9de602fe76c709e12074a6f362ba>` arr,
			:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` alloc_type = :ref:`PAGE_LOCKED<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16a968d788513648797c888aa13e056d6a4>`
			);

		// methods
	
		static
		:ref:`MatAllocator<doxid-d4/dee/classcv_1_1_mat_allocator>`*
		:target:`getAllocator<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a9453a200959d95a97de53a0318e3d842>`(:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` alloc_type = :ref:`PAGE_LOCKED<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16a968d788513648797c888aa13e056d6a4>`);
	
		int
		:target:`channels<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a0de01702b003773e10207c0de0bf2730>`() const;
	
		HostMem
		:ref:`clone<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a29b76f344d85d77b4c51478cfebbbd28>`() const;
	
		void
		:ref:`create<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a62eea66ac1a181eeeb10a2335f3bd4bd>`(
			int rows,
			int cols,
			int type
			);
	
		void
		:target:`create<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a451a57a38885d605a95b4c965dd17ea7>`(
			:ref:`Size<doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>` size,
			int type
			);
	
		:ref:`GpuMat<doxid-d5/da3/classcv_1_1cuda_1_1_gpu_mat>`
		:ref:`createGpuMatHeader<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a6444e4aa55f0c4cd6fcba072763106ff>`() const;
	
		:ref:`Mat<doxid-db/de6/classcv_1_1_mat>`
		:ref:`createMatHeader<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a017b175a89135b3dd04c5825913e6b87>`() const;
	
		int
		:target:`depth<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a1cb85c2b9f858bbc892b1dd282eba3c4>`() const;
	
		:ref:`size_t<doxid-da/d06/autogenerated_2opencl__core_8hpp_1a6ff403ead16f7faa1f7228274eb6b01d>`
		:target:`elemSize<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1af4d2f52deeacd51b5ccd07759123e0f0>`() const;
	
		:ref:`size_t<doxid-da/d06/autogenerated_2opencl__core_8hpp_1a6ff403ead16f7faa1f7228274eb6b01d>`
		:target:`elemSize1<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a350f03863027be4851f1b21ae8514bab>`() const;
	
		bool
		:target:`empty<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1afe92b26dbd1a2a1d718504dfb24c1866>`() const;
	
		bool
		:target:`isContinuous<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1ad091db7d7ddc0e484d2556cf36b8e0af>`() const;
	
		HostMem&
		:target:`operator=<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a086c7947f5c106c9b238ba9dcbcb2f1c>`(const HostMem& m);
	
		void
		:ref:`release<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a924b94dc7a70dd17d8c38e0de48ab827>`();
	
		HostMem
		:ref:`reshape<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a31e3165f8fc1a4863d7a67a973f5bd68>`(
			int cn,
			int rows = 0
			) const;
	
		:ref:`Size<doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`
		:target:`size<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa61acd6d1db2ec950221831dc3fe1ca9>`() const;
	
		:ref:`size_t<doxid-da/d06/autogenerated_2opencl__core_8hpp_1a6ff403ead16f7faa1f7228274eb6b01d>`
		:target:`step1<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1ab51be367c23f9976389efd3eccbded97>`() const;
	
		void
		:ref:`swap<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a6eabc73d59936b87292125e17415b053>`(HostMem& b);
	
		int
		:target:`type<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1ac55673be0aa82cc6dbe7b17cf2c480ce>`() const;
	};
.. _details-da/d5b/classcv_1_1cuda_1_1_host_mem:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

Class with reference counting wrapping special memory type allocation functions from CUDA.

Its interface is also Mat-like but with additional memory type parameters.

* **PAGE_LOCKED** sets a page locked memory type used commonly for fast and asynchronous uploading/downloading data from/to GPU.

* **SHARED** specifies a zero copy memory allocation that enables mapping the host memory to GPU address space, if supported.

* **WRITE_COMBINED** sets the write combined buffer that is not cached by CPU. Such buffers are used to supply GPU with data when GPU only reads it. The advantage is a better CPU cache utilization.

Allocation size of such memory types is usually limited. For more details, see *CUDA 2.2 Pinned Memory APIs* document or *CUDA C Programming Guide*.

Construction
------------

.. index:: pair: function; HostMem
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a5a4f81b179472ac6407e0baa92cd36d7:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	HostMem(
		:ref:`InputArray<doxid-dc/d84/group__core__basic_1ga353a9de602fe76c709e12074a6f362ba>` arr,
		:ref:`AllocType<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16>` alloc_type = :ref:`PAGE_LOCKED<doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1aa0d69b2aa95680a6b2af6dc4dda44e16a968d788513648797c888aa13e056d6a4>`
		)

creates from host memory with coping data

Methods
-------

.. index:: pair: function; clone
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a29b76f344d85d77b4c51478cfebbbd28:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	HostMem
	clone() const

returns deep copy of the matrix, i.e. the data is copied

.. index:: pair: function; create
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a62eea66ac1a181eeeb10a2335f3bd4bd:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	void
	create(
		int rows,
		int cols,
		int type
		)

allocates new matrix data unless the matrix already has specified size and type.

.. index:: pair: function; createGpuMatHeader
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a6444e4aa55f0c4cd6fcba072763106ff:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`GpuMat<doxid-d5/da3/classcv_1_1cuda_1_1_gpu_mat>`
	createGpuMatHeader() const

Maps CPU memory to GPU address space and creates the :ref:`cuda::GpuMat <doxid-d5/da3/classcv_1_1cuda_1_1_gpu_mat>` header without reference counting for it.

This can be done only if memory was allocated with the SHARED flag and if it is supported by the hardware. Laptops often share video and CPU memory, so address spaces can be mapped, which eliminates an extra copy.

.. index:: pair: function; createMatHeader
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a017b175a89135b3dd04c5825913e6b87:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	:ref:`Mat<doxid-db/de6/classcv_1_1_mat>`
	createMatHeader() const

returns matrix header with disabled reference counting for :ref:`HostMem <doxid-da/d5b/classcv_1_1cuda_1_1_host_mem>` data.

.. index:: pair: function; release
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a924b94dc7a70dd17d8c38e0de48ab827:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	void
	release()

decrements reference counter and released memory if needed.

.. index:: pair: function; reshape
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a31e3165f8fc1a4863d7a67a973f5bd68:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	HostMem
	reshape(
		int cn,
		int rows = 0
		) const

creates alternative :ref:`HostMem <doxid-da/d5b/classcv_1_1cuda_1_1_host_mem>` header for the same data, with different number of channels and/or different number of rows

.. index:: pair: function; swap
.. _doxid-da/d5b/classcv_1_1cuda_1_1_host_mem_1a6eabc73d59936b87292125e17415b053:

.. ref-code-block:: cpp
	:class: doxyrest-title-code-block

	void
	swap(HostMem& b)

swaps with other smart pointer

