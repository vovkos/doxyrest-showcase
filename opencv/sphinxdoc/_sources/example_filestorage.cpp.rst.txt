.. index:: pair: example; filestorage.cpp
.. _doxid-d6/d03/filestorage_8cpp-example:

filestorage.cpp
===============

A complete example using the FileStorage interface

.. ref-code-block:: cpp

	/*
	 * filestorage_sample demonstrate the usage of the opencv serialization functionality
	 */
	
	#include "opencv2/core.hpp"
	#include <iostream>
	#include <string>
	
	using std::string;
	using std::cout;
	using std::endl;
	using std::cerr;
	using std::ostream;
	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
	
	static void help(char** av)
	{
	  cout << "\nfilestorage_sample demonstrate the usage of the opencv serialization functionality.\n"
	      << "usage:\n"
	      <<  av[0] << " outputfile.yml.gz\n"
	      << "\n   outputfile above can have many different extenstions, see below."
	      << "\nThis program demonstrates the use of FileStorage for serialization, that is use << and >>  in OpenCV\n"
	      << "For example, how to create a class and have it serialize, but also how to use it to read and write matrices.\n"
	      << "FileStorage allows you to serialize to various formats specified by the file end type."
	          << "\nYou should try using different file extensions.(e.g. yaml yml xml xml.gz yaml.gz etc...)\n" << endl;
	}
	
	struct MyData
	{
	  MyData() :
	    A(0), X(0), id()
	  {
	  }
	  explicit MyData(int) :
	    A(97), X(CV_PI), id("mydata1234")
	  {
	  }
	  int A;
	  double X;
	  string id;
	  void write(:ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>`& fs) const //Write serialization for this class
	  {
	    fs << "{" << "A" << A << "X" << X << "id" << id << "}";
	  }
	  void read(const :ref:`FileNode <doxid-dc/d21/classcv_1_1_file_node>`& node)  //Read serialization for this class
	  {
	
	    A = (int)node["A"];
	    X = (double)node["X"];
	    id = (string)node["id"];
	  }
	};
	
	//These write and read functions must exist as per the inline functions in operations.hpp
	static void write(:ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>`& fs, const std::string&, const MyData& x){
	  x.write(fs);
	}
	static void read(const :ref:`FileNode <doxid-dc/d21/classcv_1_1_file_node>`& node, MyData& x, const MyData& default_value = MyData()){
	  if(node.:ref:`empty <doxid-dc/d21/classcv_1_1_file_node_1a82d59aab4765da6140c238c54aadfa92>`())
	    x = default_value;
	  else
	    x.read(node);
	}
	
	static ostream& :ref:`operator\<\< <doxid-df/d91/group__core__hal__intrin_1gacef821c50106276406bf4bc1cd7a059a>`(ostream& out, const MyData& m){
	  out << "{ id = " << m.id << ", ";
	  out << "X = " << m.X << ", ";
	  out << "A = " << m.A << "}";
	  return out;
	}
	int main(int ac, char** av)
	{
	  :ref:`cv::CommandLineParser <doxid-da/dd8/classcv_1_1_command_line_parser>` parser(ac, av,
	    "{@input||}{help h ||}"
	  );
	  if (parser.has("help"))
	  {
	    help(av);
	    return 0;
	  }
	  string filename = parser.get<string>("@input");
	  if (filename.empty())
	  {
	    help(av);
	    return 1;
	  }
	
	  //write
	  {
	    :ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` fs(filename, :ref:`FileStorage::WRITE <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482da747a241cefee7b8af34c3d804c864ad6>`);
	
	    cout << "writing images\n";
	    fs << "images" << "[";
	
	    fs << "image1.jpg" << "myfi.png" << "../data/baboon.jpg";
	    cout << "image1.jpg" << " myfi.png" << " ../data/baboon.jpg" << endl;
	
	    fs << "]";
	
	    cout << "writing mats\n";
	    :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` R =:ref:`Mat_\<double>::eye <doxid-d9/de0/classcv_1_1_mat___1a992daefd1a256fbd40423a2cf77f42a1>`(3, 3),T = :ref:`Mat_\<double>::zeros <doxid-d9/de0/classcv_1_1_mat___1ab68de1358f5aedd6028269f77a9e841b>`(3, 1);
	    cout << "R = " << R << "\n";
	    cout << "T = " << T << "\n";
	    fs << "R" << R;
	    fs << "T" << T;
	
	    cout << "writing MyData struct\n";
	    MyData m(1);
	    fs << "mdata" << m;
	    cout << m << endl;
	  }
	
	  //read
	  {
	    :ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` fs(filename, :ref:`FileStorage::READ <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482daa0dcc459c4d100c35ccfa9a643827bed>`);
	
	    if (!fs.:ref:`isOpened <doxid-d9/df9/classcv_1_1_file_storage_1aa952c31f4e632595cd5ac107913f4fd1>`())
	    {
	      cerr << "failed to open " << filename << endl;
	      help(av);
	      return 1;
	    }
	
	    :ref:`FileNode <doxid-dc/d21/classcv_1_1_file_node>` n = fs["images"];
	    if (n.:ref:`type <doxid-dc/d21/classcv_1_1_file_node_1ad0fd448e25719a94320ebe574b87f997>`() != :ref:`FileNode::SEQ <doxid-dc/d21/classcv_1_1_file_node_1a8fe1d2aa050e6909b978f4df3529066eaa359c2282183738d11a665035a1a67bb>`)
	    {
	      cerr << "images is not a sequence! FAIL" << endl;
	      return 1;
	    }
	
	    cout << "reading images\n";
	    :ref:`FileNodeIterator <doxid-d8/d08/classcv_1_1_file_node_iterator>` it = n.:ref:`begin <doxid-dc/d21/classcv_1_1_file_node_1a0f299820227506079f5b9013dd8c3558>`(), it_end = n.:ref:`end <doxid-dc/d21/classcv_1_1_file_node_1a58b033e34726eb73f0238a1bfbe0c8e9>`();
	    for (; it != it_end; ++it)
	    {
	      cout << (string)*it << "\n";
	    }
	
	    :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` R, T;
	    cout << "reading R and T" << endl;
	
	    fs["R"] >> R;
	    fs["T"] >> T;
	
	    cout << "R = " << R << "\n";
	    cout << "T = " << T << endl;
	
	    MyData m;
	    fs["mdata"] >> m;
	
	    cout << "read mdata\n";
	    cout << m << endl;
	
	    cout << "attempting to read mdata_b\n";   //Show default behavior for empty matrix
	    fs["mdata_b"] >> m;
	    cout << "read mdata_b\n";
	    cout << m << endl;
	
	  }
	
	  cout << "Try opening " << filename << " to see the serialized data." << endl << endl;
	
	  //read from string
	  {
	    cout << "Read data from string\n";
	    string dataString =
	        "%YAML:1.0\n"
	        "mdata:\n"
	        "   A: 97\n"
	        "   X: 3.1415926535897931e+00\n"
	        "   id: mydata1234\n";
	    MyData m;
	    :ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` fs(dataString, :ref:`FileStorage::READ <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482daa0dcc459c4d100c35ccfa9a643827bed>` | :ref:`FileStorage::MEMORY <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482dabdde7670c9c7e472f8445932ea7cbbf7>`);
	    cout << "attempting to read mdata_b from string\n";   //Show default behavior for empty matrix
	    fs["mdata"] >> m;
	    cout << "read mdata\n";
	    cout << m << endl;
	  }
	
	  //write to string
	  {
	    cout << "Write data to string\n";
	    :ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` fs(filename, :ref:`FileStorage::WRITE <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482da747a241cefee7b8af34c3d804c864ad6>` | :ref:`FileStorage::MEMORY <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482dabdde7670c9c7e472f8445932ea7cbbf7>` | :ref:`FileStorage::FORMAT_YAML <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482da63e7a7dcb2d68359210dc5fc8c83e92d>`);
	
	    cout << "writing MyData struct\n";
	    MyData m(1);
	    fs << "mdata" << m;
	    cout << m << endl;
	    string createdString = fs.:ref:`releaseAndGetString <doxid-d9/df9/classcv_1_1_file_storage_1a5341a9e09e1b797faf6b7ec40bd558fd>`();
	    cout << "Created string:\n" << createdString << "\n";
	  }
	
	  return 0;
	}
