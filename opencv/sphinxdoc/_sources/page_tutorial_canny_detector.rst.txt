.. index:: pair: page; Canny Edge Detector
.. _doxid-da/d5c/tutorial_canny_detector:

Canny Edge Detector
===================

.. rubric:: Goal

In this tutorial you will learn how to:

* Use the OpenCV function :ref:`cv::Canny <doxid-dd/d1a/group__imgproc__feature_1ga04723e007ed888ddf11d9ba04e2232de>` to implement the Canny Edge Detector.

.. rubric:: Theory

The *Canny Edge detector* was developed by John F. Canny in 1986. Also known to many as the *optimal detector*, the Canny algorithm aims to satisfy three main criteria:

* **Low error rate:** Meaning a good detection of only existent edges.

* **Good localization:** The distance between edge pixels detected and real edge pixels have to be minimized.

* **Minimal response:** Only one detector response per edge.

.. rubric:: Steps

#. Filter out any noise. The Gaussian filter is used for this purpose. An example of a Gaussian kernel of :math:`size = 5` that might be used is shown below:
   
   .. math::
   
   	K = \dfrac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2 \\ 4 & 9 & 12 & 9 & 4 \\ 5 & 12 & 15 & 12 & 5 \\ 4 & 9 & 12 & 9 & 4 \\ 2 & 4 & 5 & 4 & 2 \end{bmatrix}

#. Find the intensity gradient of the image. For this, we follow a procedure analogous to Sobel:
   
   #. Apply a pair of convolution masks (in :math:`x` and :math:`y` directions:
      
      .. math::
      
      	G_{x} = \begin{bmatrix} -1 & 0 & +1 \\ -2 & 0 & +2 \\ -1 & 0 & +1 \end{bmatrix}
      
      
      
      .. math::
      
      	G_{y} = \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ +1 & +2 & +1 \end{bmatrix}
   
   #. Find the gradient strength and direction with:
      
      .. math::
      
      	\begin{array}{l} G = \sqrt{ G_{x}^{2} + G_{y}^{2} } \\ \theta = \arctan(\dfrac{ G_{y} }{ G_{x} }) \end{array}
      
      The direction is rounded to one of four possible angles (namely 0, 45, 90 or 135)

#. *Non-maximum* suppression is applied. This removes pixels that are not considered to be part of an edge. Hence, only thin lines (candidate edges) will remain.

#. *Hysteresis* : The final step. Canny does use two thresholds (upper and lower):
   
   #. If a pixel gradient is higher than the *upper* threshold, the pixel is accepted as an edge
   
   #. If a pixel gradient value is below the *lower* threshold, then it is rejected.
   
   #. If the pixel gradient is between the two thresholds, then it will be accepted only if it is connected to a pixel that is above the *upper* threshold.
   
   Canny recommended a *upper* : *lower* ratio between 2:1 and 3:1.

#. For more details, you can always consult your favorite Computer Vision book.

.. rubric:: Code

#. **What does this program do?**
   
   * Asks the user to enter a numerical value to set the lower threshold for our *Canny Edge Detector* (by means of a Trackbar).
   
   * Applies the *Canny Detector* and generates a **mask** (bright lines representing the edges on a black background).
   
   * Applies the mask obtained on the original image and display it in a window.

#. The tutorial code's is shown lines below. You can also download it from `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/ImgTrans/CannyDetector_Demo.cpp>`__
   
   .. ref-code-block:: cpp
   
   	
   	#include "opencv2/imgproc.hpp"
   	#include "opencv2/imgcodecs.hpp"
   	#include "opencv2/highgui.hpp"
   	
   	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
   	
   	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, src_gray;
   	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` dst, detected_edges;
   	
   	int edgeThresh = 1;
   	int lowThreshold;
   	int const max_lowThreshold = 100;
   	int ratio = 3;
   	int kernel_size = 3;
   	const char* window_name = "Edge Map";
   	
   	static void CannyThreshold(int, void*)
   	{
   	    :ref:`blur <doxid-d4/d86/group__imgproc__filter_1ga8c45db9afe636703801b0b2e440fce37>`( src_gray, detected_edges, :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`(3,3) );
   	
   	    :ref:`Canny <doxid-dd/d1a/group__imgproc__feature_1ga04723e007ed888ddf11d9ba04e2232de>`( detected_edges, detected_edges, lowThreshold, lowThreshold*ratio, kernel_size );
   	
   	    dst = :ref:`Scalar::all <doxid-d7/d13/classcv_1_1_scalar___1ac1509a4b8454fe7fe29db069e13a2e6f>`(0);
   	
   	    src.:ref:`copyTo <doxid-db/de6/classcv_1_1_mat_1a33fd5d125b4c302b0c9aa86980791a77>`( dst, detected_edges);
   	
   	    :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( window_name, dst );
   	}
   	
   	
   	int main( int, char** argv )
   	{
   	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` ); // Load an image
   	
   	  if( src.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`() )
   	    { return -1; }
   	
   	  dst.:ref:`create <doxid-db/de6/classcv_1_1_mat_1a55ced2c8d844d683ea9a725c60037ad0>`( src.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`(), src.:ref:`type <doxid-db/de6/classcv_1_1_mat_1af2d2652e552d7de635988f18a84b53e5>`() );
   	
   	  :ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src_gray, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );
   	
   	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( window_name, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	
   	  :ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Min Threshold:", window_name, &lowThreshold, max_lowThreshold, CannyThreshold );
   	
   	  CannyThreshold(0, 0);
   	
   	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
   	
   	  return 0;
   	}

.. rubric:: Explanation

#. Create some needed variables:
   
   .. ref-code-block:: cpp
   
   	Mat src, src_gray;
   	Mat dst, detected_edges;
   	
   	int edgeThresh = 1;
   	int lowThreshold;
   	int const max_lowThreshold = 100;
   	int ratio = 3;
   	int kernel_size = 3;
   	const char* window_name = "Edge Map";
   
   Note the following:
   
   #. We establish a ratio of lower:upper threshold of 3:1 (with the variable *ratio*).
   
   #. We set the kernel size of :math:`3` (for the Sobel operations to be performed internally by the Canny function).
   
   #. We set a maximum value for the lower Threshold of :math:`100`.

#. Loads the source image:
   
   .. ref-code-block:: cpp
   
   	src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` ); // Load an image
   
   	if( src.empty() )
   	  { return -1; }

#. Create a matrix of the same type and size of *src* (to be *dst*):
   
   .. ref-code-block:: cpp
   
   	dst.create( src.size(), src.type() );

#. Convert the image to grayscale (using the function :ref:`cv::cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`):
   
   .. ref-code-block:: cpp
   
   	:ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src_gray, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );

#. Create a window to display the results:
   
   .. ref-code-block:: cpp
   
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( window_name, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );

#. Create a Trackbar for the user to enter the lower threshold for our Canny detector:
   
   .. ref-code-block:: cpp
   
   	:ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Min Threshold:", window_name, &lowThreshold, max_lowThreshold, CannyThreshold );
   
   Observe the following:
   
   #. The variable to be controlled by the Trackbar is *lowThreshold* with a limit of *max_lowThreshold* (which we set to 100 previously)
   
   #. Each time the Trackbar registers an action, the callback function *CannyThreshold* will be invoked.

#. Let's check the *CannyThreshold* function, step by step:
   
   #. First, we blur the image with a filter of kernel size 3:
      
      .. ref-code-block:: cpp
      
      	:ref:`blur <doxid-d4/d86/group__imgproc__filter_1ga8c45db9afe636703801b0b2e440fce37>`( src_gray, detected_edges, :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`(3,3) );
   
   #. Second, we apply the OpenCV function :ref:`cv::Canny <doxid-dd/d1a/group__imgproc__feature_1ga04723e007ed888ddf11d9ba04e2232de>` :
      
      .. ref-code-block:: cpp
      
      	:ref:`Canny <doxid-dd/d1a/group__imgproc__feature_1ga04723e007ed888ddf11d9ba04e2232de>`( detected_edges, detected_edges, lowThreshold, lowThreshold*ratio, kernel_size );
      
      where the arguments are:
      
      * *detected_edges* : Source image, grayscale
      
      * *detected_edges* : Output of the detector (can be the same as the input)
      
      * *lowThreshold* : The value entered by the user moving the Trackbar
      
      * *highThreshold* : Set in the program as three times the lower threshold (following Canny's recommendation)
      
      * *kernel_size* : We defined it to be 3 (the size of the Sobel kernel to be used internally)

#. We fill a *dst* image with zeros (meaning the image is completely black).
   
   .. ref-code-block:: cpp
   
   	dst = Scalar::all(0);

#. Finally, we will use the function :ref:`cv::Mat::copyTo <doxid-db/de6/classcv_1_1_mat_1a33fd5d125b4c302b0c9aa86980791a77>` to map only the areas of the image that are identified as edges (on a black background). :ref:`cv::Mat::copyTo <doxid-db/de6/classcv_1_1_mat_1a33fd5d125b4c302b0c9aa86980791a77>` copy the *src* image onto *dst*. However, it will only copy the pixels in the locations where they have non-zero values. Since the output of the Canny detector is the edge contours on a black background, the resulting *dst* will be black in all the area but the detected edges.
   
   .. ref-code-block:: cpp
   
   	src.copyTo( dst, detected_edges);

#. We display our result:
   
   .. ref-code-block:: cpp
   
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( window_name, dst );
   
   
   
   .. rubric:: Result

* After compiling the code above, we can run it giving as argument the path to an image. For example, using as an input the following image:
  
  .. image:: Canny_Detector_Tutorial_Original_Image.jpg

* Moving the slider, trying different threshold, we obtain the following result:
  
  .. image:: Canny_Detector_Tutorial_Result.jpg

* Notice how the image is superposed to the black background on the edge regions.

