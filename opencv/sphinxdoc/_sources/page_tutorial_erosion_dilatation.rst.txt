.. index:: pair: page; Eroding and Dilating
.. _doxid-db/df6/tutorial_erosion_dilatation:

Eroding and Dilating
====================

.. rubric:: Goal

In this tutorial you will learn how to:

* Apply two very common morphological operators: Erosion and Dilation. For this purpose, you will use the following OpenCV functions:
  
  * :ref:`cv::erode <doxid-d4/d86/group__imgproc__filter_1gaeb1e0c1033e3f6b891a25d0511362aeb>`
  
  * :ref:`cv::dilate <doxid-d4/d86/group__imgproc__filter_1ga4ff0f3318642c4f469d0e11f242f3b6c>`

.. rubric:: Interesting fact

The explanation below belongs to the book **Learning OpenCV** by Bradski and Kaehler.



.. rubric:: Morphological Operations

* In short: A set of operations that process images based on shapes. Morphological operations apply a *structuring element* to an input image and generate an output image.

* The most basic morphological operations are: Erosion and Dilation. They have a wide array of uses, i.e. :
  
  * Removing noise
  
  * Isolation of individual elements and joining disparate elements in an image.
  
  * Finding of intensity bumps or holes in an image

* We will explain dilation and erosion briefly, using the following image as an example:
  
  .. image:: Morphology_1_Tutorial_Theory_Original_Image.png

.. rubric:: Dilation

* This operations consists of convolving an image :math:`A` with some kernel (:math:`B`), which can have any shape or size, usually a square or circle.

* The kernel :math:`B` has a defined *anchor point*, usually being the center of the kernel.

* As the kernel :math:`B` is scanned over the image, we compute the maximal pixel value overlapped by :math:`B` and replace the image pixel in the anchor point position with that maximal value. As you can deduce, this maximizing operation causes bright regions within an image to "grow" (therefore the name *dilation*). Take the above image as an example. Applying dilation we can get:
  
  .. image:: Morphology_1_Tutorial_Theory_Dilation.png

The background (bright) dilates around the black regions of the letter.

To better grasp the idea and avoid possible confusion, in this other example we have inverted the original image such as the object in white is now the letter. We have performed two dilatations with a rectangular structuring element of size ``3x3``.

.. image:: Morphology_1_Tutorial_Theory_Dilatation_2.png
	:alt: Left image: original image inverted, right image: resulting dilatation

The dilatation makes the object in white bigger.

.. rubric:: Erosion

* This operation is the sister of dilation. It computes a local minimum over the area of given kernel.

* As the kernel :math:`B` is scanned over the image, we compute the minimal pixel value overlapped by :math:`B` and replace the image pixel under the anchor point with that minimal value.

* Analagously to the example for dilation, we can apply the erosion operator to the original image (shown above). You can see in the result below that the bright areas of the image (the background, apparently), get thinner, whereas the dark zones (the "writing") gets bigger.
  
  .. image:: Morphology_1_Tutorial_Theory_Erosion.png

In similar manner, the corresponding image results by applying erosion operation on the inverted original image (two erosions with a rectangular structuring element of size ``3x3``):

.. image:: Morphology_1_Tutorial_Theory_Erosion_2.png
	:alt: Left image: original image inverted, right image: resulting erosion

The erosion makes the object in white smaller.

.. rubric:: Code

This tutorial's code is shown below. You can also download it `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/ImgProc/Morphology_1.cpp>`__

.. ref-code-block:: cpp

	
	#include "opencv2/imgproc.hpp"
	#include "opencv2/imgcodecs.hpp"
	#include "opencv2/highgui.hpp"
	
	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
	
	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, erosion_dst, dilation_dst;
	
	int erosion_elem = 0;
	int erosion_size = 0;
	int dilation_elem = 0;
	int dilation_size = 0;
	int const max_elem = 2;
	int const max_kernel_size = 21;
	
	void Erosion( int, void* );
	void Dilation( int, void* );
	
	int main( int, char** argv )
	{
	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` );
	
	  if( src.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`() )
	    { return -1; }
	
	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( "Erosion Demo", :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( "Dilation Demo", :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
	  :ref:`moveWindow <doxid-d7/dfc/group__highgui_1ga8d86b207f7211250dbe6e28f76307ffb>`( "Dilation Demo", src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`, 0 );
	
	  :ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Erosion Demo",
	          &erosion_elem, max_elem,
	          Erosion );
	
	  :ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Kernel size:\n 2n +1", "Erosion Demo",
	          &erosion_size, max_kernel_size,
	          Erosion );
	
	  :ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Dilation Demo",
	          &dilation_elem, max_elem,
	          Dilation );
	
	  :ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Kernel size:\n 2n +1", "Dilation Demo",
	          &dilation_size, max_kernel_size,
	          Dilation );
	
	  Erosion( 0, 0 );
	  Dilation( 0, 0 );
	
	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
	  return 0;
	}
	
	
	void Erosion( int, void* )
	{
	  int erosion_type = 0;
	  if( erosion_elem == 0 ){ erosion_type = :ref:`MORPH_RECT <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada260c4cbde19a749726763c01a074c60f>`; }
	  else if( erosion_elem == 1 ){ erosion_type = :ref:`MORPH_CROSS <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada318435753d0b9f7faa241a658ec2e191>`; }
	  else if( erosion_elem == 2) { erosion_type = :ref:`MORPH_ELLIPSE <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada33a3c67a61f349d21c507d05c53a755f>`; }
	
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` element = :ref:`getStructuringElement <doxid-d4/d86/group__imgproc__filter_1gac342a1bb6eabf6f55c803b09268e36dc>`( erosion_type,
	                       :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`( 2*erosion_size + 1, 2*erosion_size+1 ),
	                       :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( erosion_size, erosion_size ) );
	
	  :ref:`erode <doxid-d4/d86/group__imgproc__filter_1gaeb1e0c1033e3f6b891a25d0511362aeb>`( src, erosion_dst, element );
	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( "Erosion Demo", erosion_dst );
	}
	
	
	void Dilation( int, void* )
	{
	  int dilation_type = 0;
	  if( dilation_elem == 0 ){ dilation_type = :ref:`MORPH_RECT <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada260c4cbde19a749726763c01a074c60f>`; }
	  else if( dilation_elem == 1 ){ dilation_type = :ref:`MORPH_CROSS <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada318435753d0b9f7faa241a658ec2e191>`; }
	  else if( dilation_elem == 2) { dilation_type = :ref:`MORPH_ELLIPSE <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada33a3c67a61f349d21c507d05c53a755f>`; }
	
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` element = :ref:`getStructuringElement <doxid-d4/d86/group__imgproc__filter_1gac342a1bb6eabf6f55c803b09268e36dc>`( dilation_type,
	                       :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`( 2*dilation_size + 1, 2*dilation_size+1 ),
	                       :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( dilation_size, dilation_size ) );
	
	  :ref:`dilate <doxid-d4/d86/group__imgproc__filter_1ga4ff0f3318642c4f469d0e11f242f3b6c>`( src, dilation_dst, element );
	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( "Dilation Demo", dilation_dst );
	}

.. rubric:: Explanation

#. Most of the material shown here is trivial (if you have any doubt, please refer to the tutorials in previous sections). Let's check the general structure of the program:
   
   * Load an image (can be BGR or grayscale)
   
   * Create two windows (one for dilation output, the other for erosion)
   
   * Create a set of two Trackbars for each operation:
     
     * The first trackbar "Element" returns either **erosion_elem** or **dilation_elem**
     
     * The second trackbar "Kernel size" return **erosion_size** or **dilation_size** for the corresponding operation.
   
   * Every time we move any slider, the user's function **Erosion** or **Dilation** will be called and it will update the output image based on the current trackbar values.
   
   Let's analyze these two functions:

#. **erosion:**
   
   .. ref-code-block:: cpp
   
   	
   	void Erosion( int, void* )
   	{
   	  int erosion_type = 0;
   	  if( erosion_elem == 0 ){ erosion_type = :ref:`MORPH_RECT <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada260c4cbde19a749726763c01a074c60f>`; }
   	  else if( erosion_elem == 1 ){ erosion_type = :ref:`MORPH_CROSS <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada318435753d0b9f7faa241a658ec2e191>`; }
   	  else if( erosion_elem == 2) { erosion_type = :ref:`MORPH_ELLIPSE <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada33a3c67a61f349d21c507d05c53a755f>`; }
   	
   	  Mat element = :ref:`getStructuringElement <doxid-d4/d86/group__imgproc__filter_1gac342a1bb6eabf6f55c803b09268e36dc>`( erosion_type,
   	                       :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`( 2*erosion_size + 1, 2*erosion_size+1 ),
   	                       :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( erosion_size, erosion_size ) );
   	
   	  :ref:`erode <doxid-d4/d86/group__imgproc__filter_1gaeb1e0c1033e3f6b891a25d0511362aeb>`( src, erosion_dst, element );
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( "Erosion Demo", erosion_dst );
   	}
   
   
   
   * The function that performs the *erosion* operation is :ref:`cv::erode <doxid-d4/d86/group__imgproc__filter_1gaeb1e0c1033e3f6b891a25d0511362aeb>`. As we can see, it receives three arguments:
     
     * *src* : The source image
     
     * *erosion_dst* : The output image
     
     * *element* : This is the kernel we will use to perform the operation. If we do not specify, the default is a simple ``3x3`` matrix. Otherwise, we can specify its shape. For this, we need to use the function :ref:`cv::getStructuringElement <doxid-d4/d86/group__imgproc__filter_1gac342a1bb6eabf6f55c803b09268e36dc>` :
       
       .. ref-code-block:: cpp
       
       	Mat element = :ref:`getStructuringElement <doxid-d4/d86/group__imgproc__filter_1gac342a1bb6eabf6f55c803b09268e36dc>`( erosion_type,
       	                     :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`( 2*erosion_size + 1, 2*erosion_size+1 ),
       	                     :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( erosion_size, erosion_size ) );
       
       We can choose any of three shapes for our kernel:
       
       * Rectangular box: MORPH_RECT
       
       * Cross: MORPH_CROSS
       
       * Ellipse: MORPH_ELLIPSE
       
       Then, we just have to specify the size of our kernel and the *anchor point*. If not specified, it is assumed to be in the center.
   
   * That is all. We are ready to perform the erosion of our image. Additionally, there is another parameter that allows you to perform multiple erosions (iterations) at once. However, We haven't used it in this simple tutorial. You can check out the reference for more details.

#. **dilation:**
   
   The code is below. As you can see, it is completely similar to the snippet of code for **erosion**. Here we also have the option of defining our kernel, its anchor point and the size of the operator to be used.
   
   .. ref-code-block:: cpp
   
   	
   	void Dilation( int, void* )
   	{
   	  int dilation_type = 0;
   	  if( dilation_elem == 0 ){ dilation_type = :ref:`MORPH_RECT <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada260c4cbde19a749726763c01a074c60f>`; }
   	  else if( dilation_elem == 1 ){ dilation_type = :ref:`MORPH_CROSS <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada318435753d0b9f7faa241a658ec2e191>`; }
   	  else if( dilation_elem == 2) { dilation_type = :ref:`MORPH_ELLIPSE <doxid-d4/d86/group__imgproc__filter_1ggac2db39b56866583a95a5680313c314ada33a3c67a61f349d21c507d05c53a755f>`; }
   	
   	  Mat element = :ref:`getStructuringElement <doxid-d4/d86/group__imgproc__filter_1gac342a1bb6eabf6f55c803b09268e36dc>`( dilation_type,
   	                       :ref:`Size <doxid-dc/d84/group__core__basic_1ga346f563897249351a34549137c8532a0>`( 2*dilation_size + 1, 2*dilation_size+1 ),
   	                       :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( dilation_size, dilation_size ) );
   	
   	  :ref:`dilate <doxid-d4/d86/group__imgproc__filter_1ga4ff0f3318642c4f469d0e11f242f3b6c>`( src, dilation_dst, element );
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( "Dilation Demo", dilation_dst );
   	}
   
   
   
   .. rubric:: Results

Compile the code above and execute it with an image as argument. For instance, using this image:

.. image:: Morphology_1_Tutorial_Original_Image.jpg

We get the results below. Varying the indices in the Trackbars give different output images, naturally. Try them out! You can even try to add a third Trackbar to control the number of iterations.

.. image:: Morphology_1_Result.jpg

