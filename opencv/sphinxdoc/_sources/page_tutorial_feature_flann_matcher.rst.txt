.. index:: pair: page; Feature Matching with FLANN
.. _doxid-d5/d6f/tutorial_feature_flann_matcher:

Feature Matching with FLANN
===========================

.. rubric:: Goal

In this tutorial you will learn how to:

* Use the :ref:`cv::FlannBasedMatcher <doxid-de/d48/classcv_1_1_flann_based_matcher>` interface in order to perform a quick and efficient matching by using the :ref:`Clustering and Search in Multi-Dimensional Spaces <doxid-dc/de5/group__flann>` module

.. rubric:: Theory

.. rubric:: Code

This tutorial code's is shown lines below.

.. ref-code-block:: cpp

	/*
	 * @file SURF_FlannMatcher
	 * @brief SURF detector + descriptor + FLANN Matcher
	 * @author A. Huaman
	 */
	
	#include <stdio.h>
	#include <iostream>
	#include <stdio.h>
	#include <iostream>
	#include "opencv2/core.hpp"
	#include "opencv2/features2d.hpp"
	#include "opencv2/imgcodecs.hpp"
	#include "opencv2/highgui.hpp"
	#include "opencv2/xfeatures2d.hpp"
	
	using namespace :ref:`std <doxid-d8/dcc/namespacestd>`;
	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
	using namespace cv::xfeatures2d;
	
	void readme();
	
	/*
	 * @function main
	 * @brief Main function
	 */
	int main( int argc, char** argv )
	{
	  if( argc != 3 )
	  { readme(); return -1; }
	
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` img_1 = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_GRAYSCALE <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80ae29981cfc153d3b0cef5c0daeedd2125>` );
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` img_2 = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[2], :ref:`IMREAD_GRAYSCALE <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80ae29981cfc153d3b0cef5c0daeedd2125>` );
	
	  if( !img_1.:ref:`data <doxid-db/de6/classcv_1_1_mat_1a4d33bed1c850265370d2af0ff02e1564>` || !img_2.:ref:`data <doxid-db/de6/classcv_1_1_mat_1a4d33bed1c850265370d2af0ff02e1564>` )
	  { std::cout<< " --(!) Error reading images " << std::endl; return -1; }
	
	  //-- Step 1: Detect the keypoints using SURF Detector, compute the descriptors
	  int minHessian = 400;
	
	  :ref:`Ptr\<SURF> <doxid-d2/d56/structcv_1_1_ptr>` detector = SURF::create();
	  detector->setHessianThreshold(minHessian);
	
	  std::vector<KeyPoint> keypoints_1, keypoints_2;
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` descriptors_1, descriptors_2;
	
	  detector->detectAndCompute( img_1, :ref:`Mat <doxid-db/de6/classcv_1_1_mat>`(), keypoints_1, descriptors_1 );
	  detector->detectAndCompute( img_2, :ref:`Mat <doxid-db/de6/classcv_1_1_mat>`(), keypoints_2, descriptors_2 );
	
	  //-- Step 2: Matching descriptor vectors using FLANN matcher
	  :ref:`FlannBasedMatcher <doxid-de/d48/classcv_1_1_flann_based_matcher>` matcher;
	  std::vector< DMatch > matches;
	  matcher.:ref:`match <doxid-d4/d64/classcv_1_1_descriptor_matcher_1a0f046f47b68ec7074391e1e85c750cba>`( descriptors_1, descriptors_2, matches );
	
	  double max_dist = 0; double min_dist = 100;
	
	  //-- Quick calculation of max and min distances between keypoints
	  for( int i = 0; i < descriptors_1.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`; i++ )
	  { double dist = matches[i].distance;
	    if( dist < min_dist ) min_dist = dist;
	    if( dist > max_dist ) max_dist = dist;
	  }
	
	  printf("-- Max dist : %f \n", max_dist );
	  printf("-- Min dist : %f \n", min_dist );
	
	  //-- Draw only "good" matches (i.e. whose distance is less than 2*min_dist,
	  //-- or a small arbitary value ( 0.02 ) in the event that min_dist is very
	  //-- small)
	  //-- PS.- radiusMatch can also be used here.
	  std::vector< DMatch > good_matches;
	
	  for( int i = 0; i < descriptors_1.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`; i++ )
	  { if( matches[i].distance <= :ref:`max <doxid-d2/d75/namespacecv_1a78f988f6cfa6223610298cbd4f86ec66>`(2*min_dist, 0.02) )
	    { good_matches.push_back( matches[i]); }
	  }
	
	  //-- Draw only "good" matches
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` img_matches;
	  :ref:`drawMatches <doxid-d4/d5d/group__features2d__draw_1ga7421b3941617d7267e3f2311582f49e1>`( img_1, keypoints_1, img_2, keypoints_2,
	               good_matches, img_matches, Scalar::all(-1), Scalar::all(-1),
	               vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );
	
	  //-- Show detected matches
	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( "Good Matches", img_matches );
	
	  for( int i = 0; i < (int)good_matches.size(); i++ )
	  { printf( "-- Good Match [%d] Keypoint 1: %d  -- Keypoint 2: %d  \n", i, good_matches[i].queryIdx, good_matches[i].trainIdx ); }
	
	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
	
	  return 0;
	}
	
	/*
	 * @function readme
	 */
	void readme()
	{ std::cout << " Usage: ./SURF_FlannMatcher <img1> <img2>" << std::endl; }

.. rubric:: Explanation

.. rubric:: Result

#. Here is the result of the feature detection applied to the first image:
   
   .. image:: Featur_FlannMatcher_Result.jpg

#. Additionally, we get as console output the keypoints filtered:
   
   .. image:: Feature_FlannMatcher_Keypoints_Result.jpg

