.. index:: pair: page; File Input and Output using XML and YAML files
.. _doxid-dd/d74/tutorial_file_input_output_with_xml_yml:

File Input and Output using XML and YAML files
==============================================

.. rubric:: Goal

You'll find answers for the following questions:

* How to print and read text entries to a file and OpenCV using YAML or XML files?

* How to do the same for OpenCV data structures?

* How to do this for your data structures?

* Usage of OpenCV data structures such as :ref:`cv::FileStorage <doxid-d9/df9/classcv_1_1_file_storage>`, :ref:`cv::FileNode <doxid-dc/d21/classcv_1_1_file_node>` or :ref:`cv::FileNodeIterator <doxid-d8/d08/classcv_1_1_file_node_iterator>`.

.. rubric:: Source code

You can `download this from here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/core/file_input_output/file_input_output.cpp>`__ or find it in the ``samples/cpp/tutorial_code/core/file_input_output/file_input_output.cpp`` of the OpenCV source code library.

Here's a sample code of how to achieve all the stuff enumerated at the goal list.

.. ref-code-block:: cpp

	#include <opencv2/core.hpp>
	#include <iostream>
	#include <string>
	
	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
	using namespace :ref:`std <doxid-d8/dcc/namespacestd>`;
	
	static void help(char** av)
	{
	    cout << endl
	        << av[0] << " shows the usage of the OpenCV serialization functionality."         << endl
	        << "usage: "                                                                      << endl
	        <<  av[0] << " outputfile.yml.gz"                                                 << endl
	        << "The output file may be either XML (xml) or YAML (yml/yaml). You can even compress it by "
	        << "specifying this in its extension like xml.gz yaml.gz etc... "                  << endl
	        << "With FileStorage you can serialize objects in OpenCV by using the << and >> operators" << endl
	        << "For example: - create a class and have it serialized"                         << endl
	        << "             - use it to read and write matrices."                            << endl;
	}
	
	class MyData
	{
	public:
	    MyData() : A(0), X(0), id()
	    {}
	    explicit MyData(int) : A(97), X(:ref:`CV_PI <doxid-db/de0/group__core__utils_1ga677b89fae9308b340ddaebf0dba8455f>`), id("mydata1234") // explicit to avoid implicit conversion
	    {}
	    void write(:ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>`& fs) const                        //Write serialization for this class
	    {
	        fs << "{" << "A" << A << "X" << X << "id" << id << "}";
	    }
	    void read(const :ref:`FileNode <doxid-dc/d21/classcv_1_1_file_node>`& node)                          //Read serialization for this class
	    {
	        A = (int)node["A"];
	        X = (double)node["X"];
	        id = (string)node["id"];
	    }
	public:   // Data Members
	    int A;
	    double X;
	    string id;
	};
	
	//These write and read functions must be defined for the serialization in FileStorage to work
	static void write(:ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>`& fs, const std::string&, const MyData& x)
	{
	    x.write(fs);
	}
	static void read(const :ref:`FileNode <doxid-dc/d21/classcv_1_1_file_node>`& node, MyData& x, const MyData& default_value = MyData()){
	    if(node.:ref:`empty <doxid-dc/d21/classcv_1_1_file_node_1a82d59aab4765da6140c238c54aadfa92>`())
	        x = default_value;
	    else
	        x.read(node);
	}
	
	// This function will print our custom class to the console
	static ostream& :ref:`operator\<\< <doxid-df/d91/group__core__hal__intrin_1gacef821c50106276406bf4bc1cd7a059a>`(ostream& out, const MyData& m)
	{
	    out << "{ id = " << m.id << ", ";
	    out << "X = " << m.X << ", ";
	    out << "A = " << m.A << "}";
	    return out;
	}
	
	int main(int ac, char** av)
	{
	    if (ac != 2)
	    {
	        help(av);
	        return 1;
	    }
	
	    string filename = av[1];
	    { //write
	        :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` R = :ref:`Mat_\<uchar>::eye <doxid-d9/de0/classcv_1_1_mat___1a992daefd1a256fbd40423a2cf77f42a1>`(3, 3),
	            T = :ref:`Mat_\<double>::zeros <doxid-d9/de0/classcv_1_1_mat___1ab68de1358f5aedd6028269f77a9e841b>`(3, 1);
	        MyData m(1);
	
	        :ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` fs(filename, :ref:`FileStorage::WRITE <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482da747a241cefee7b8af34c3d804c864ad6>`);
	
	        fs << "iterationNr" << 100;
	        fs << "strings" << "[";                              // text - string sequence
	        fs << "image1.jpg" << "Awesomeness" << "../data/baboon.jpg";
	        fs << "]";                                           // close sequence
	
	        fs << "Mapping";                              // text - mapping
	        fs << "{" << "One" << 1;
	        fs <<        "Two" << 2 << "}";
	
	        fs << "R" << R;                                      // cv::Mat
	        fs << "T" << T;
	
	        fs << "MyData" << m;                                // your own data structures
	
	        fs.:ref:`release <doxid-d9/df9/classcv_1_1_file_storage_1ad23d5415a06fb4bc97bfa034589b376e>`();                                       // explicit close
	        cout << "Write Done." << endl;
	    }
	
	    {//read
	        cout << endl << "Reading: " << endl;
	        :ref:`FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` fs;
	        fs.:ref:`open <doxid-d9/df9/classcv_1_1_file_storage_1a14c2c18dc2e29999d03d52a0c24bd91c>`(filename, :ref:`FileStorage::READ <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482daa0dcc459c4d100c35ccfa9a643827bed>`);
	
	        int itNr;
	        //fs["iterationNr"] >> itNr;
	        itNr = (int) fs["iterationNr"];
	        cout << itNr;
	        if (!fs.:ref:`isOpened <doxid-d9/df9/classcv_1_1_file_storage_1aa952c31f4e632595cd5ac107913f4fd1>`())
	        {
	            cerr << "Failed to open " << filename << endl;
	            help(av);
	            return 1;
	        }
	
	        :ref:`FileNode <doxid-dc/d21/classcv_1_1_file_node>` n = fs["strings"];                         // Read string sequence - Get node
	        if (n.:ref:`type <doxid-dc/d21/classcv_1_1_file_node_1ad0fd448e25719a94320ebe574b87f997>`() != :ref:`FileNode::SEQ <doxid-dc/d21/classcv_1_1_file_node_1a8fe1d2aa050e6909b978f4df3529066eaa359c2282183738d11a665035a1a67bb>`)
	        {
	            cerr << "strings is not a sequence! FAIL" << endl;
	            return 1;
	        }
	
	        :ref:`FileNodeIterator <doxid-d8/d08/classcv_1_1_file_node_iterator>` it = n.:ref:`begin <doxid-dc/d21/classcv_1_1_file_node_1a0f299820227506079f5b9013dd8c3558>`(), it_end = n.:ref:`end <doxid-dc/d21/classcv_1_1_file_node_1a58b033e34726eb73f0238a1bfbe0c8e9>`(); // Go through the node
	        for (; it != it_end; ++it)
	            cout << (string)*it << endl;
	
	
	        n = fs["Mapping"];                                // Read mappings from a sequence
	        cout << "Two  " << (int)(n["Two"]) << "; ";
	        cout << "One  " << (int)(n["One"]) << endl << endl;
	
	
	        MyData m;
	        :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` R, T;
	
	        fs["R"] >> R;                                      // Read cv::Mat
	        fs["T"] >> T;
	        fs["MyData"] >> m;                                 // Read your own structure_
	
	        cout << endl
	            << "R = " << R << endl;
	        cout << "T = " << T << endl << endl;
	        cout << "MyData = " << endl << m << endl << endl;
	
	        //Show default behavior for non existing nodes
	        cout << "Attempt to read NonExisting (should initialize the data structure with its default).";
	        fs["NonExisting"] >> m;
	        cout << endl << "NonExisting = " << endl << m << endl;
	    }
	
	    cout << endl
	        << "Tip: Open up " << filename << " with a text editor to see the serialized data." << endl;
	
	    return 0;
	}

.. rubric:: Explanation

Here we talk only about XML and YAML file inputs. Your output (and its respective input) file may have only one of these extensions and the structure coming from this. They are two kinds of data structures you may serialize: *mappings* (like the STL map) and *element sequence* (like the STL vector). The difference between these is that in a map every element has a unique name through what you may access it. For sequences you need to go through them to query a specific item.

#. **XML/YAML File Open and Close.** Before you write any content to such file you need to open it and at the end to close it. The XML/YAML data structure in OpenCV is :ref:`cv::FileStorage <doxid-d9/df9/classcv_1_1_file_storage>`. To specify that this structure to which file binds on your hard drive you can use either its constructor or the *open()* function of this:
   
   .. ref-code-block:: cpp
   
   	string filename = "I.xml";
   	FileStorage fs(filename, FileStorage::WRITE);
   	//...
   	fs.:ref:`open <doxid-d9/df9/classcv_1_1_file_storage_1a14c2c18dc2e29999d03d52a0c24bd91c>`(filename, FileStorage::READ);
   
   Either one of this you use the second argument is a constant specifying the type of operations you'll be able to on them: WRITE, READ or APPEND. The extension specified in the file name also determinates the output format that will be used. The output may be even compressed if you specify an extension such as \*.xml.gz\*.
   
   The file automatically closes when the :ref:`cv::FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` objects is destroyed. However, you may explicitly call for this by using the *release* function:
   
   .. ref-code-block:: cpp
   
   	fs.:ref:`release <doxid-d9/df9/classcv_1_1_file_storage_1ad23d5415a06fb4bc97bfa034589b376e>`();                                       // explicit close

#. **Input and Output of text and numbers.** The data structure uses the same << output operator that the STL library. For outputting any type of data structure we need first to specify its name. We do this by just simply printing out the name of this. For basic types you may follow this with the print of the value :
   
   .. ref-code-block:: cpp
   
   	fs << "iterationNr" << 100;
   
   Reading in is a simple addressing (via the [] operator) and casting operation or a read via the >> operator :
   
   .. ref-code-block:: cpp
   
   	int itNr;
   	fs["iterationNr"] >> itNr;
   	itNr = (int) fs["iterationNr"];

#. **Input/Output of OpenCV Data structures.** Well these behave exactly just as the basic C++ types:
   
   .. ref-code-block:: cpp
   
   	Mat R = :ref:`Mat_\<uchar >::eye <doxid-d9/de0/classcv_1_1_mat___1a992daefd1a256fbd40423a2cf77f42a1>`  (3, 3),
   	    T = :ref:`Mat_\<double>::zeros <doxid-d9/de0/classcv_1_1_mat___1ab68de1358f5aedd6028269f77a9e841b>`(3, 1);
   	
   	fs << "R" << R;                                      // Write cv::Mat
   	fs << "T" << T;
   	
   	fs["R"] >> R;                                      // Read cv::Mat
   	fs["T"] >> T;

#. **Input/Output of vectors (arrays) and associative maps.** As I mentioned beforehand, we can output maps and sequences (array, vector) too. Again we first print the name of the variable and then we have to specify if our output is either a sequence or map.
   
   For sequence before the first element print the "[" character and after the last one the "]" character:
   
   .. ref-code-block:: cpp
   
   	fs << "strings" << "[";                              // text - string sequence
   	fs << "image1.jpg" << "Awesomeness" << "baboon.jpg";
   	fs << "]";                                           // close sequence
   
   For maps the drill is the same however now we use the "{" and "}" delimiter characters:
   
   .. ref-code-block:: cpp
   
   	fs << "Mapping";                              // text - mapping
   	fs << "{" << "One" << 1;
   	fs <<        "Two" << 2 << "}";
   
   To read from these we use the :ref:`cv::FileNode <doxid-dc/d21/classcv_1_1_file_node>` and the :ref:`cv::FileNodeIterator <doxid-d8/d08/classcv_1_1_file_node_iterator>` data structures. The [] operator of the :ref:`cv::FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` class returns a :ref:`cv::FileNode <doxid-dc/d21/classcv_1_1_file_node>` data type. If the node is sequential we can use the :ref:`cv::FileNodeIterator <doxid-d8/d08/classcv_1_1_file_node_iterator>` to iterate through the items:
   
   .. ref-code-block:: cpp
   
   	FileNode n = fs["strings"];                         // Read string sequence - Get node
   	if (n.type() != FileNode::SEQ)
   	{
   	    cerr << "strings is not a sequence! FAIL" << endl;
   	    return 1;
   	}
   	
   	FileNodeIterator it = n.begin(), it_end = n.end(); // Go through the node
   	for (; it != it_end; ++it)
   	    cout << (string)*it << endl;
   
   For maps you can use the [] operator again to acces the given item (or the >> operator too):
   
   .. ref-code-block:: cpp
   
   	n = fs["Mapping"];                                // Read mappings from a sequence
   	cout << "Two  " << (int)(n["Two"]) << "; ";
   	cout << "One  " << (int)(n["One"]) << endl << endl;

#. **Read and write your own data structures.** Suppose you have a data structure such as:
   
   .. ref-code-block:: cpp
   
   	class MyData
   	{
   	public:
   	      MyData() : A(0), X(0), id() {}
   	public:   // Data Members
   	   int A;
   	   double X;
   	   string id;
   	};
   
   It's possible to serialize this through the OpenCV I/O XML/YAML interface (just as in case of the OpenCV data structures) by adding a read and a write function inside and outside of your class. For the inside part:
   
   .. ref-code-block:: cpp
   
   	void :ref:`write <doxid-d9/df9/classcv_1_1_file_storage_1a26447446dd3fa0644684a045e16399fe>`(FileStorage& fs) const                        //Write serialization for this class
   	{
   	  fs << "{" << "A" << A << "X" << X << "id" << id << "}";
   	}
   	
   	void :ref:`read <doxid-dc/d21/classcv_1_1_file_node_1ab24433dde37f770766481a91983e5f44>`(const FileNode& node)                          //Read serialization for this class
   	{
   	  A = (int)node["A"];
   	  X = (double)node["X"];
   	  id = (string)node["id"];
   	}
   
   Then you need to add the following functions definitions outside the class:
   
   .. ref-code-block:: cpp
   
   	void :ref:`write <doxid-d9/df9/classcv_1_1_file_storage_1a26447446dd3fa0644684a045e16399fe>`(FileStorage& fs, const std::string&, const MyData& x)
   	{
   	x.write(fs);
   	}
   	
   	void :ref:`read <doxid-dc/d21/classcv_1_1_file_node_1ab24433dde37f770766481a91983e5f44>`(const FileNode& node, MyData& x, const MyData& default_value = MyData())
   	{
   	if(node.empty())
   	    x = default_value;
   	else
   	    x.read(node);
   	}
   
   Here you can observe that in the read section we defined what happens if the user tries to read a non-existing node. In this case we just return the default initialization value, however a more verbose solution would be to return for instance a minus one value for an object ID.
   
   Once you added these four functions use the >> operator for write and the << operator for read:
   
   .. ref-code-block:: cpp
   
   	MyData m(1);
   	fs << "MyData" << m;                                // your own data structures
   	fs["MyData"] >> m;                                 // Read your own structure_
   
   Or to try out reading a non-existing read:
   
   .. ref-code-block:: cpp
   
   	fs["NonExisting"] >> m;   // Do not add a fs << "NonExisting" << m command for this to work
   	cout << endl << "NonExisting = " << endl << m << endl;

.. rubric:: Result

Well mostly we just print out the defined numbers. On the screen of your console you could see:

.. ref-code-block:: cpp

	Write Done.
	
	Reading:
	100image1.jpg
	Awesomeness
	baboon.jpg
	Two  2; One  1
	
	
	R = [1, 0, 0;
	  0, 1, 0;
	  0, 0, 1]
	T = [0; 0; 0]
	
	MyData =
	{ id = mydata1234, X = 3.14159, A = 97}
	
	Attempt to read NonExisting (should initialize the data structure with its default).
	NonExisting =
	{ id = , X = 0, A = 0}
	
	Tip: Open up output.xml with a text editor to see the serialized data.

Nevertheless, it's much more interesting what you may see in the output xml file:

.. ref-code-block:: cpp

	<?xml version="1.0"?>
	<opencv_storage>
	<iterationNr>100</iterationNr>
	<strings>
	  image1.jpg Awesomeness baboon.jpg</strings>
	<Mapping>
	  <One>1</One>
	  <Two>2</Two></Mapping>
	<R type_id="opencv-matrix">
	  <rows>3</rows>
	  <cols>3</cols>
	  <dt>u</dt>
	  <data>
	    1 0 0 0 1 0 0 0 1</data></R>
	<T type_id="opencv-matrix">
	  <rows>3</rows>
	  <cols>1</cols>
	  <dt>d</dt>
	  <data>
	    0. 0. 0.</data></T>
	<MyData>
	  <A>97</A>
	  <X>3.1415926535897931e+000</X>
	  <id>mydata1234</id></MyData>
	</opencv_storage>

Or the YAML file:

.. ref-code-block:: cpp

	%YAML:1.0
	iterationNr: 100
	strings:
	   - "image1.jpg"
	   - Awesomeness
	   - "baboon.jpg"
	Mapping:
	   One: 1
	   Two: 2
	R: !!opencv-matrix
	   rows: 3
	   cols: 3
	   dt: u
	   data: [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]
	T: !!opencv-matrix
	   rows: 3
	   cols: 1
	   dt: d
	   data: [ 0., 0., 0. ]
	MyData:
	   A: 97
	   X: 3.1415926535897931e+000
	   id: mydata1234

You may observe a runtime instance of this on the `YouTube here <https://www.youtube.com/watch?v=A4yqVnByMMM>`__.

