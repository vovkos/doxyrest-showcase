.. index:: pair: page; Making your own linear filters!
.. _doxid-d4/dbd/tutorial_filter_2d:

Making your own linear filters!
===============================

.. rubric:: Goal

In this tutorial you will learn how to:

* Use the OpenCV function :ref:`cv::filter2D <doxid-d4/d86/group__imgproc__filter_1ga27c049795ce870216ddfb366086b5a04>` to create your own linear filters.

.. rubric:: Theory

The explanation below belongs to the book **Learning OpenCV** by Bradski and Kaehler.



.. rubric:: Convolution

In a very general sense, convolution is an operation between every part of an image and an operator (kernel).

.. rubric:: What is a kernel?

A kernel is essentially a fixed size array of numerical coefficients along with an *anchor point* in that array, which is typically located at the center.

.. image:: filter_2d_tutorial_kernel_theory.png

.. rubric:: How does convolution with a kernel work?

Assume you want to know the resulting value of a particular location in the image. The value of the convolution is calculated in the following way:

#. Place the kernel anchor on top of a determined pixel, with the rest of the kernel overlaying the corresponding local pixels in the image.

#. Multiply the kernel coefficients by the corresponding image pixel values and sum the result.

#. Place the result to the location of the *anchor* in the input image.

#. Repeat the process for all pixels by scanning the kernel over the entire image.

Expressing the procedure above in the form of an equation we would have:

.. math::

	H(x,y) = \sum_{i=0}^{M_{i} - 1} \sum_{j=0}^{M_{j}-1} I(x+i - a_{i}, y + j - a_{j})K(i,j)

Fortunately, OpenCV provides you with the function :ref:`cv::filter2D <doxid-d4/d86/group__imgproc__filter_1ga27c049795ce870216ddfb366086b5a04>` so you do not have to code all these operations.

.. rubric:: Code

#. **What does this program do?**
   
   * Loads an image
   
   * Performs a *normalized box filter*. For instance, for a kernel of size :math:`size = 3`, the kernel would be:
   
   .. math::
   
   	K = \dfrac{1}{3 \cdot 3} \begin{bmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix}
   
   
   
   .. code-block:: cpp
   
   	The program will perform the filter operation with kernels of sizes 3, 5, 7, 9 and 11.
   
   
   
   * The filter output (with each kernel) will be shown during 500 milliseconds

#. The tutorial code's is shown lines below. You can also download it from `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/ImgTrans/filter2D_demo.cpp>`__
   
   .. ref-code-block:: cpp
   
   	
   	#include "opencv2/imgproc.hpp"
   	#include "opencv2/imgcodecs.hpp"
   	#include "opencv2/highgui.hpp"
   	
   	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
   	
   	int main ( int, char** argv )
   	{
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, dst;
   	
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` kernel;
   	  Point anchor;
   	  double delta;
   	  int ddepth;
   	  int kernel_size;
   	  const char* window_name = "filter2D Demo";
   	
   	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` ); // Load an image
   	
   	  if( src.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`() )
   	    { return -1; }
   	
   	  anchor = :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( -1, -1 );
   	  delta = 0;
   	  ddepth = -1;
   	
   	  int ind = 0;
   	  for(;;)
   	       {
   	         char c = (char):ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(500);
   	         if( c == 27 )
   	           { break; }
   	
   	         kernel_size = 3 + 2*( ind%5 );
   	         kernel = :ref:`Mat::ones <doxid-db/de6/classcv_1_1_mat_1a69ae0402d116fc9c71908d8508dc2f09>`( kernel_size, kernel_size, :ref:`CV_32F <doxid-d1/d1b/group__core__hal__interface_1ga4a3def5d72b74bed31f5f8ab7676099c>` )/ (float)(kernel_size*kernel_size);
   	
   	         :ref:`filter2D <doxid-d4/d86/group__imgproc__filter_1ga27c049795ce870216ddfb366086b5a04>`(src, dst, ddepth , kernel, anchor, delta, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   	         :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( window_name, dst );
   	         ind++;
   	       }
   	
   	  return 0;
   	}

.. rubric:: Explanation

#. Load an image
   
   .. ref-code-block:: cpp
   
   	src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` ); // Load an image
   
   	if( src.:ref:`empty <doxid-db/de6/classcv_1_1_mat_1abbec3525a852e77998aba034813fded4>`() )
   	  { return -1; }

#. Initialize the arguments for the linear filter
   
   .. ref-code-block:: cpp
   
   	anchor = :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( -1, -1 );
   	delta = 0;
   	ddepth = -1;

#. Perform an infinite loop updating the kernel size and applying our linear filter to the input image. Let's analyze that more in detail:

#. First we define the kernel our filter is going to use. Here it is:
   
   .. ref-code-block:: cpp
   
   	kernel_size = 3 + 2*( ind%5 );
   	kernel = Mat::ones( kernel_size, kernel_size, :ref:`CV_32F <doxid-d1/d1b/group__core__hal__interface_1ga4a3def5d72b74bed31f5f8ab7676099c>` )/ (float)(kernel_size*kernel_size);
   
   The first line is to update the *kernel_size* to odd values in the range: :math:`[3,11]`. The second line actually builds the kernel by setting its value to a matrix filled with :math:`1's` and normalizing it by dividing it between the number of elements.

#. After setting the kernel, we can generate the filter by using the function :ref:`cv::filter2D <doxid-d4/d86/group__imgproc__filter_1ga27c049795ce870216ddfb366086b5a04>` :
   
   .. ref-code-block:: cpp
   
   	:ref:`filter2D <doxid-d5/df1/group__imgproc__hal__functions_1ga42c2468ab3a1238fbf48458c57169081>`(src, dst, ddepth , kernel, anchor, delta, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
   
   The arguments denote:
   
   #. *src* : Source image
   
   #. *dst* : Destination image
   
   #. *ddepth* : The depth of *dst*. A negative value (such as :math:`-1`) indicates that the depth is the same as the source.
   
   #. *kernel* : The kernel to be scanned through the image
   
   #. *anchor* : The position of the anchor relative to its kernel. The location *Point(-1, -1)* indicates the center by default.
   
   #. *delta* : A value to be added to each pixel during the convolution. By default it is :math:`0`
   
   #. *BORDER_DEFAULT* : We let this value by default (more details in the following tutorial)

#. Our program will effectuate a *while* loop, each 500 ms the kernel size of our filter will be updated in the range indicated.

.. rubric:: Results

#. After compiling the code above, you can execute it giving as argument the path of an image. The result should be a window that shows an image blurred by a normalized filter. Each 0.5 seconds the kernel size should change, as can be seen in the series of snapshots below:
   
   .. image:: filter_2d_tutorial_result.jpg

