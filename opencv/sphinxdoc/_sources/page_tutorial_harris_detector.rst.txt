.. index:: pair: page; Harris corner detector
.. _doxid-d4/d7d/tutorial_harris_detector:

Harris corner detector
======================

.. rubric:: Goal

In this tutorial you will learn:

* What features are and why they are important

* Use the function :ref:`cv::cornerHarris <doxid-dd/d1a/group__imgproc__feature_1gac1fc3598018010880e370e2f709b4345>` to detect corners using the Harris-Stephens method.

.. rubric:: Theory

.. rubric:: What is a feature?

* In computer vision, usually we need to find matching points between different frames of an environment. Why? If we know how two images relate to each other, we can use *both* images to extract information of them.

* When we say **matching points** we are referring, in a general sense, to *characteristics* in the scene that we can recognize easily. We call these characteristics **features**.

* **So, what characteristics should a feature have?**
  
  * It must be *uniquely recognizable*

.. rubric:: Types of Image Features

To mention a few:

* Edges

* **Corners** (also known as interest points)

* Blobs (also known as regions of interest )

In this tutorial we will study the *corner* features, specifically.

.. rubric:: Why is a corner so special?

* Because, since it is the intersection of two edges, it represents a point in which the directions of these two edges *change*. Hence, the gradient of the image (in both directions) have a high variation, which can be used to detect it.

.. rubric:: How does it work?

* Let's look for corners. Since corners represents a variation in the gradient in the image, we will look for this "variation".

* Consider a grayscale image :math:`I`. We are going to sweep a window :math:`w(x,y)` (with displacements :math:`u` in the x direction and :math:`v` in the right direction) :math:`I` and will calculate the variation of intensity.
  
  .. math::
  
  	E(u,v) = \sum _{x,y} w(x,y)[ I(x+u,y+v) - I(x,y)]^{2}
  
  where:
  
  * :math:`w(x,y)` is the window at position :math:`(x,y)`
  
  * :math:`I(x,y)` is the intensity at :math:`(x,y)`
  
  * :math:`I(x+u,y+v)` is the intensity at the moved window :math:`(x+u,y+v)`

* Since we are looking for windows with corners, we are looking for windows with a large variation in intensity. Hence, we have to maximize the equation above, specifically the term:
  
  .. math::
  
  	\sum _{x,y}[ I(x+u,y+v) - I(x,y)]^{2}

* Using *Taylor expansion* :
  
  .. math::
  
  	E(u,v) \approx \sum _{x,y}[ I(x,y) + u I_{x} + vI_{y} - I(x,y)]^{2}

* Expanding the equation and cancelling properly:
  
  .. math::
  
  	E(u,v) \approx \sum _{x,y} u^{2}I_{x}^{2} + 2uvI_{x}I_{y} + v^{2}I_{y}^{2}

* Which can be expressed in a matrix form as:
  
  .. math::
  
  	E(u,v) \approx \begin{bmatrix} u & v \end{bmatrix} \left ( \displaystyle \sum_{x,y} w(x,y) \begin{bmatrix} I_x^{2} & I_{x}I_{y} \\ I_xI_{y} & I_{y}^{2} \end{bmatrix} \right ) \begin{bmatrix} u \\ v \end{bmatrix}

* Let's denote:
  
  .. math::
  
  	M = \displaystyle \sum_{x,y} w(x,y) \begin{bmatrix} I_x^{2} & I_{x}I_{y} \\ I_xI_{y} & I_{y}^{2} \end{bmatrix}

* So, our equation now is:
  
  .. math::
  
  	E(u,v) \approx \begin{bmatrix} u & v \end{bmatrix} M \begin{bmatrix} u \\ v \end{bmatrix}

* A score is calculated for each window, to determine if it can possibly contain a corner:
  
  .. math::
  
  	R = det(M) - k(trace(M))^{2}
  
  where:
  
  * det(M) = :math:`\lambda_{1}\lambda_{2}`
  
  * trace(M) = :math:`\lambda_{1}+\lambda_{2}`
  
  a window with a score :math:`R` greater than a certain value is considered a "corner"

.. rubric:: Code

This tutorial code's is shown lines below. You can also download it from `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/TrackingMotion/cornerHarris_Demo.cpp>`__

.. ref-code-block:: cpp

	
	#include "opencv2/imgcodecs.hpp"
	#include "opencv2/highgui.hpp"
	#include "opencv2/imgproc.hpp"
	#include <iostream>
	
	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
	using namespace :ref:`std <doxid-d8/dcc/namespacestd>`;
	
	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, src_gray;
	int thresh = 200;
	int max_thresh = 255;
	
	const char* source_window = "Source image";
	const char* corners_window = "Corners detected";
	
	void cornerHarris_demo( int, void* );
	
	int main( int, char** argv )
	{
	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` );
	  :ref:`cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`( src, src_gray, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>` );
	
	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( source_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
	  :ref:`createTrackbar <doxid-d7/dfc/group__highgui_1gaf78d2155d30b728fc413803745b67a9b>`( "Threshold: ", source_window, &thresh, max_thresh, cornerHarris_demo );
	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( source_window, src );
	
	  cornerHarris_demo( 0, 0 );
	
	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
	  return(0);
	}
	
	void cornerHarris_demo( int, void* )
	{
	
	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` dst, dst_norm, dst_norm_scaled;
	  dst = :ref:`Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`( src.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`(), :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
	
	  int blockSize = 2;
	  int apertureSize = 3;
	  double k = 0.04;
	
	  :ref:`cornerHarris <doxid-dd/d1a/group__imgproc__feature_1gac1fc3598018010880e370e2f709b4345>`( src_gray, dst, blockSize, apertureSize, k, :ref:`BORDER_DEFAULT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01>` );
	
	  :ref:`normalize <doxid-dc/d84/group__core__basic_1ga1b6a396a456c8b6c6e4afd8591560d80>`( dst, dst_norm, 0, 255, :ref:`NORM_MINMAX <doxid-d2/de8/group__core__array_1ggad12cefbcb5291cf958a85b4b67b6149fa9f0c1c342a18114d47b516a88e29822e>`, :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>`, :ref:`Mat <doxid-db/de6/classcv_1_1_mat>`() );
	  :ref:`convertScaleAbs <doxid-d2/de8/group__core__array_1ga3460e9c9f37b563ab9dd550c4d8c4e7d>`( dst_norm, dst_norm_scaled );
	
	  for( int j = 0; j < dst_norm.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>` ; j++ )
	     { for( int i = 0; i < dst_norm.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`; i++ )
	          {
	            if( (int) dst_norm.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) > thresh )
	              {
	               :ref:`circle <doxid-d6/d6e/group__imgproc__draw_1gaf10604b069374903dbd0f0488cb43670>`( dst_norm_scaled, :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( i, j ), 5,  :ref:`Scalar <doxid-dc/d84/group__core__basic_1ga599fe92e910c027be274233eccad7beb>`(0), 2, 8, 0 );
	              }
	          }
	     }
	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( corners_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( corners_window, dst_norm_scaled );
	}

.. rubric:: Explanation

.. rubric:: Result

The original image:

.. image:: Harris_Detector_Original_Image.jpg

The detected corners are surrounded by a small black circle

.. image:: Harris_Detector_Result.jpg

