.. index:: pair: page; OpenCV iOS - Image Processing
.. _doxid-d3/def/tutorial_image_manipulation:

OpenCV iOS - Image Processing
=============================

.. rubric:: Goal

In this tutorial we will learn how to do basic image processing using OpenCV in iOS.

.. rubric:: Introduction

In *OpenCV* all the image processing operations are usually carried out on the *Mat* structure. In iOS however, to render an image on screen it have to be an instance of the *UIImage* class. To convert an *OpenCV Mat* to an *UIImage* we use the *Core Graphics* framework available in iOS. Below is the code needed to covert back and forth between Mat's and UIImage's.

.. ref-code-block:: cpp

	- (:ref:`cv <doxid-d2/d75/namespacecv>`::Mat)cvMatFromUIImage:(UIImage *)image
	{
	  CGColorSpaceRef colorSpace = CGImageGetColorSpace(image.CGImage);
	  CGFloat cols = image.size.width;
	  CGFloat rows = image.size.height;
	
	  :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` :ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`(rows, cols, :ref:`CV_8UC4 <doxid-d1/d1b/group__core__hal__interface_1ga4519ad2827f771db8260c61207b782df>`); // 8 bits per component, 4 channels (color channels + alpha)
	
	  CGContextRef contextRef = CGBitmapContextCreate(:ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`.:ref:`data <doxid-d6/dda/struct_cv_mat_1ac7caba321cf1d2512b0d11ccc6bd3df4>`,                 // Pointer to  data
	                                                 cols,                       // Width of bitmap
	                                                 rows,                       // Height of bitmap
	                                                 8,                          // Bits per component
	                                                 :ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`.:ref:`step <doxid-d6/dda/struct_cv_mat_1a79ac05ef6fed1529e6d4b444c7c5234c>`[0],              // Bytes per row
	                                                 colorSpace,                 // Colorspace
	                                                 kCGImageAlphaNoneSkipLast |
	                                                 kCGBitmapByteOrderDefault); // Bitmap info flags
	
	  CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage);
	  CGContextRelease(contextRef);
	
	  return :ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`;
	}



.. ref-code-block:: cpp

	- (:ref:`cv <doxid-d2/d75/namespacecv>`::Mat)cvMatGrayFromUIImage:(UIImage *)image
	{
	  CGColorSpaceRef colorSpace = CGImageGetColorSpace(image.CGImage);
	  CGFloat cols = image.size.width;
	  CGFloat rows = image.size.height;
	
	  :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` :ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`(rows, cols, :ref:`CV_8UC1 <doxid-d1/d1b/group__core__hal__interface_1ga81df635441b21f532fdace401e04f588>`); // 8 bits per component, 1 channels
	
	  CGContextRef contextRef = CGBitmapContextCreate(:ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`.:ref:`data <doxid-d6/dda/struct_cv_mat_1ac7caba321cf1d2512b0d11ccc6bd3df4>`,                 // Pointer to data
	                                                 cols,                       // Width of bitmap
	                                                 rows,                       // Height of bitmap
	                                                 8,                          // Bits per component
	                                                 :ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`.:ref:`step <doxid-d6/dda/struct_cv_mat_1a79ac05ef6fed1529e6d4b444c7c5234c>`[0],              // Bytes per row
	                                                 colorSpace,                 // Colorspace
	                                                 kCGImageAlphaNoneSkipLast |
	                                                 kCGBitmapByteOrderDefault); // Bitmap info flags
	
	  CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage);
	  CGContextRelease(contextRef);
	
	  return :ref:`cvMat <doxid-d2/df8/group__core__c_1ga079f05560fccce67a652486159e74eed>`;
	 }

After the processing we need to convert it back to UIImage. The code below can handle both gray-scale and color image conversions (determined by the number of channels in the *if* statement).

.. ref-code-block:: cpp

	:ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` greyMat;
	:ref:`cv::cvtColor <doxid-d7/d1b/group__imgproc__misc_1ga397ae87e1288a81d2363b61574eb8cab>`(inputMat, greyMat, :ref:`COLOR_BGR2GRAY <doxid-d7/d1b/group__imgproc__misc_1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea>`);

After the processing we need to convert it back to UIImage.

.. ref-code-block:: cpp

	-(UIImage *)UIImageFromCVMat:(:ref:`cv <doxid-d2/d75/namespacecv>`::Mat)cvMat
	{
	  NSData *data = [NSData dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];
	  CGColorSpaceRef colorSpace;
	
	  if (cvMat.elemSize() == 1) {
	      colorSpace = CGColorSpaceCreateDeviceGray();
	  } else {
	      colorSpace = CGColorSpaceCreateDeviceRGB();
	  }
	
	  CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);
	
	  // Creating CGImage from cv::Mat
	  CGImageRef imageRef = CGImageCreate(cvMat.cols,                                 //width
	                                     cvMat.rows,                                 //height
	                                     8,                                          //bits per component
	                                     8 * cvMat.elemSize(),                       //bits per pixel
	                                     cvMat.step[0],                            //bytesPerRow
	                                     colorSpace,                                 //colorspace
	                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,// bitmap info
	                                     provider,                                   //CGDataProviderRef
	                                     NULL,                                       //decode
	                                     false,                                      //should interpolate
	                                     kCGRenderingIntentDefault                   //intent
	                                     );
	
	
	  // Getting UIImage from CGImage
	  UIImage *finalImage = [UIImage imageWithCGImage:imageRef];
	  CGImageRelease(imageRef);
	  CGDataProviderRelease(provider);
	  CGColorSpaceRelease(colorSpace);
	
	  return finalImage;
	 }

.. rubric:: Output

.. image:: output.jpg

Check out an instance of running code with more Image Effects on `YouTube <http://www.youtube.com/watch?v=Ko3K_xdhJ1I>`__.

