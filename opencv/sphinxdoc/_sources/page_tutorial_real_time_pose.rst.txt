.. index:: pair: page; Real Time pose estimation of a textured object
.. _doxid-dc/d2c/tutorial_real_time_pose:

Real Time pose estimation of a textured object
==============================================

Nowadays, augmented reality is one of the top research topic in computer vision and robotics fields. The most elemental problem in augmented reality is the estimation of the camera pose respect of an object in the case of computer vision area to do later some 3D rendering or in the case of robotics obtain an object pose in order to grasp it and do some manipulation. However, this is not a trivial problem to solve due to the fact that the most common issue in image processing is the computational cost of applying a lot of algorithms or mathematical operations for solving a problem which is basic and immediateley for humans.

.. rubric:: Goal

In this tutorial is explained how to build a real time application to estimate the camera pose in order to track a textured object with six degrees of freedom given a 2D image and its 3D textured model.

The application will have the followings parts:

* Read 3D textured object model and object mesh.

* Take input from Camera or Video.

* Extract ORB features and descriptors from the scene.

* Match scene descriptors with model descriptors using Flann matcher.

* Pose estimation using PnP + Ransac.

* Linear Kalman Filter for bad poses rejection.

.. rubric:: Theory

In computer vision estimate the camera pose from *n* 3D-to-2D point correspondences is a fundamental and well understood problem. The most general version of the problem requires estimating the six degrees of freedom of the pose and five calibration parameters: focal length, principal point, aspect ratio and skew. It could be established with a minimum of 6 correspondences, using the well known Direct Linear Transform (DLT) algorithm. There are, though, several simplifications to the problem which turn into an extensive list of different algorithms that improve the accuracy of the DLT.

The most common simplification is to assume known calibration parameters which is the so-called Perspective-\*n\*-Point problem:

.. image:: pnp.jpg

**Problem Formulation:** Given a set of correspondences between 3D points :math:`p_i` expressed in a world reference frame, and their 2D projections :math:`u_i` onto the image, we seek to retrieve the pose (:math:`R` and :math:`t`) of the camera w.r.t. the world and the focal length :math:`f`.

OpenCV provides four different approaches to solve the Perspective-\*n\*-Point problem which return :math:`R` and :math:`t`. Then, using the following formula it's possible to project 3D points into the image plane:

.. math::

	s\ \left [ \begin{matrix} u \\ v \\ 1 \end{matrix} \right ] = \left [ \begin{matrix} f_x & 0 & c_x \\ 0 & f_y & c_y \\ 0 & 0 & 1 \end{matrix} \right ] \left [ \begin{matrix} r_{11} & r_{12} & r_{13} & t_1 \\ r_{21} & r_{22} & r_{23} & t_2 \\ r_{31} & r_{32} & r_{33} & t_3 \end{matrix} \right ] \left [ \begin{matrix} X \\ Y \\ Z\\ 1 \end{matrix} \right ]

The complete documentation of how to manage with this equations is in :ref:`Camera Calibration and 3D Reconstruction <doxid-d9/d0c/group__calib3d>`.

.. rubric:: Source code

You can find the source code of this tutorial in the ``samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/`` folder of the OpenCV source library.

The tutorial consists of two main programs:

#. **Model registration**
   
   This applicaton is exclusive to whom don't have a 3D textured model of the object to be detected. You can use this program to create your own textured 3D model. This program only works for planar objects, then if you want to model an object with complex shape you should use a sophisticated software to create it.
   
   The application needs an input image of the object to be registered and its 3D mesh. We have also to provide the intrinsic parameters of the camera with which the input image was taken. All the files need to be specified using the absolute path or the relative one from your application’s working directory. If none files are specified the program will try to open the provided default parameters.
   
   The application starts up extracting the ORB features and descriptors from the input image and then uses the mesh along with the `Möller–Trumbore intersection algorithm <http://http://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm/>`__ to compute the 3D coordinates of the found features. Finally, the 3D points and the descriptors are stored in different lists in a file with YAML format which each row is a different point. The technical background on how to store the files can be found in the :ref:`File Input and Output using XML and YAML files <doxid-dd/d74/tutorial_file_input_output_with_xml_yml>` tutorial.
   
   .. image:: registration.png

#. **Model detection**
   
   The aim of this application is estimate in real time the object pose given its 3D textured model.
   
   The application starts up loading the 3D textured model in YAML file format with the same structure explained in the model registration program. From the scene, the ORB features and descriptors are detected and extracted. Then, is used :ref:`cv::FlannBasedMatcher <doxid-de/d48/classcv_1_1_flann_based_matcher>` with :ref:`cv::flann::GenericIndex <doxid-dd/dde/classcv_1_1flann_1_1_generic_index>` to do the matching between the scene descriptors and the model descriptors. Using the found matches along with :ref:`cv::solvePnPRansac <doxid-d9/d0c/group__calib3d_1ga50620f0e26e02caa2e9adc07b5fbf24e>` function the ``R`` and ``t`` of the camera are computed. Finally, a KalmanFilter is applied in order to reject bad poses.
   
   In the case that you compiled OpenCV with the samples, you can find it in opencv/build/bin/cpp-tutorial-pnp_detection`. Then you can run the application and change some parameters:
   
   .. ref-code-block:: cpp
   
   	This program shows how to detect an object given its 3D textured model. You can choose to use a recorded video or the webcam.
   	Usage:
   	  ./cpp-tutorial-pnp_detection -help
   	Keys:
   	  'esc' - to quit.
   	--------------------------------------------------------------------------
   	
   	Usage: cpp-tutorial-pnp_detection [params]
   	
   	  -c, --confidence (value:0.95)
   	      :ref:`RANSAC <doxid-d9/d0c/group__calib3d_1gga96ccbb3198badce31862120414bc0d2da724159df258a5d7e29410a6a2f4e6c87>` confidence
   	  -e, --:ref:`error <doxid-db/de0/group__core__utils_1gacbd081fdb20423a63cf731569ba70b2b>` (value:2.0)
   	      :ref:`RANSAC <doxid-d9/d0c/group__calib3d_1gga96ccbb3198badce31862120414bc0d2da724159df258a5d7e29410a6a2f4e6c87>` reprojection errror
   	  -f, --fast (value:true)
   	      use of robust fast match
   	  -h, --help (value:true)
   	      print this message
   	  --in, --inliers (value:30)
   	      minimum inliers for Kalman update
   	  --it, --iterations (value:500)
   	      :ref:`RANSAC <doxid-d9/d0c/group__calib3d_1gga96ccbb3198badce31862120414bc0d2da724159df258a5d7e29410a6a2f4e6c87>` maximum iterations count
   	  -k, --keypoints (value:2000)
   	      number of keypoints to detect
   	  --mesh
   	      path to ply mesh
   	  --method, --pnp (value:0)
   	      PnP method: (0) ITERATIVE - (1) EPNP - (2) P3P - (3) DLS
   	  --model
   	      path to yml model
   	  -r, --ratio (value:0.7)
   	      :ref:`threshold <doxid-d7/d1b/group__imgproc__misc_1gae8a4a146d1ca78c626a53577199e9c57>` for ratio test
   	  -v, --video
   	      path to recorded video
   
   For example, you can run the application changing the pnp method:
   
   .. ref-code-block:: cpp
   
   	./cpp-tutorial-pnp_detection --method=2

.. rubric:: Explanation

Here is explained in detail the code for the real time application:

#. **Read 3D textured object model and object mesh.**
   
   In order to load the textured model I implemented the *class* **Model** which has the function *load()* that opens a YAML file and take the stored 3D points with its corresponding descriptors. You can find an example of a 3D textured model in ``samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/Data/cookies_ORB.yml``.
   
   .. ref-code-block:: cpp
   
   	/* Load a YAML file using OpenCV */
   	void Model::load(const std::string path)
   	{
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` points3d_mat;
   	
   	    :ref:`cv::FileStorage <doxid-d9/df9/classcv_1_1_file_storage>` storage(path, :ref:`cv::FileStorage::READ <doxid-d9/df9/classcv_1_1_file_storage_1a973e41cb75ef6230412a567723b7482daa0dcc459c4d100c35ccfa9a643827bed>`);
   	    storage["points_3d"] >> points3d_mat;
   	    storage["descriptors"] >> descriptors_;
   	
   	    points3d_mat.:ref:`copyTo <doxid-db/de6/classcv_1_1_mat_1a33fd5d125b4c302b0c9aa86980791a77>`(list_points3d_in_);
   	
   	    storage.release();
   	
   	}
   
   In the main program the model is loaded as follows:
   
   .. ref-code-block:: cpp
   
   	Model model;               // instantiate Model object
   	model.load(yml_read_path); // load a 3D textured object model
   
   In order to read the model mesh I implemented a *class* **Mesh** which has a function *load()* that opens a :math:`*`.ply file and store the 3D points of the object and also the composed triangles. You can find an example of a model mesh in ``samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/Data/box.ply``.
   
   .. ref-code-block:: cpp
   
   	/* Load a CSV with *.ply format */
   	void Mesh::load(const std::string path)
   	{
   	
   	    // Create the reader
   	    CsvReader csvReader(path);
   	
   	    // Clear previous data
   	    list_vertex_.clear();
   	    list_triangles_.clear();
   	
   	    // Read from .ply file
   	    csvReader.readPLY(list_vertex_, list_triangles_);
   	
   	    // Update mesh attributes
   	    num_vertexs_ = list_vertex_.size();
   	    num_triangles_ = list_triangles_.size();
   	
   	}
   
   In the main program the mesh is loaded as follows:
   
   .. ref-code-block:: cpp
   
   	Mesh mesh;                // instantiate Mesh object
   	mesh.load(ply_read_path); // load an object mesh
   
   You can also load different model and mesh:
   
   .. ref-code-block:: cpp
   
   	./cpp-tutorial-pnp_detection --mesh=/absolute_path_to_your_mesh.ply --model=/absolute_path_to_your_model.yml

#. **Take input from Camera or Video**
   
   To detect is necessary capture video. It's done loading a recorded video by passing the absolute path where it is located in your machine. In order to test the application you can find a recorded video in ``samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/Data/box.mp4``.
   
   .. ref-code-block:: cpp
   
   	:ref:`cv::VideoCapture <doxid-df/dcb/classcv_1_1_video_capture>` cap;                // instantiate VideoCapture
   	cap.:ref:`open <doxid-df/dcb/classcv_1_1_video_capture_1ab5b7391cd5ec50e7237e575a758f6f05>`(video_read_path);           // open a recorded video
   	
   	if(!cap.:ref:`isOpened <doxid-df/dcb/classcv_1_1_video_capture_1a9d2ca36789e7fcfe7a7be3b328038585>`())                  // check if we succeeded
   	{
   	   std::cout << "Could not open the camera device" << std::endl;
   	   return -1;
   	}
   
   Then the algorithm is computed frame per frame:
   
   .. ref-code-block:: cpp
   
   	:ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` frame, frame_vis;
   	
   	while(cap.:ref:`read <doxid-df/dcb/classcv_1_1_video_capture_1a473055e77dd7faa4d26d686226b292c1>`(frame) && :ref:`cv::waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(30) != 27)    // capture frame until ESC is pressed
   	{
   	
   	    frame_vis = frame.:ref:`clone <doxid-db/de6/classcv_1_1_mat_1ad1c9cc37d66c4e5bd05fae36f62d1cb4>`();                     // refresh visualisation frame
   	
   	    // MAIN ALGORITHM
   	
   	}
   
   You can also load different recorded video:
   
   .. ref-code-block:: cpp
   
   	./cpp-tutorial-pnp_detection --video=/absolute_path_to_your_video.mp4

#. **Extract ORB features and descriptors from the scene**
   
   The next step is to detect the scene features and extract it descriptors. For this task I implemented a *class* **RobustMatcher** which has a function for keypoints detection and features extraction. You can find it in ``samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/src/RobusMatcher.cpp``. In your *RobusMatch* object you can use any of the 2D features detectors of OpenCV. In this case I used :ref:`cv::ORB <doxid-dc/dca/classcv_1_1_o_r_b>` features because is based on :ref:`cv::FAST <doxid-d5/d51/group__features2d__main_1ga816d870cbdca71c6790c71bdf17df099>` to detect the keypoints and cv::xfeatures2d::BriefDescriptorExtractor to extract the descriptors which means that is fast and robust to rotations. You can find more detailed information about *ORB* in the documentation.
   
   The following code is how to instantiate and set the features detector and the descriptors extractor:
   
   .. ref-code-block:: cpp
   
   	RobustMatcher rmatcher;                                                          // instantiate RobustMatcher
   	
   	:ref:`cv::FeatureDetector <doxid-d9/d9f/classcv_1_1_feature2_d>` * detector = new cv::OrbFeatureDetector(numKeyPoints);       // instatiate ORB feature detector
   	:ref:`cv::DescriptorExtractor <doxid-d9/d9f/classcv_1_1_feature2_d>` * extractor = new cv::OrbDescriptorExtractor();          // instatiate ORB descriptor extractor
   	
   	rmatcher.setFeatureDetector(detector);                                           // set feature detector
   	rmatcher.setDescriptorExtractor(extractor);                                      // set descriptor extractor
   
   The features and descriptors will be computed by the *RobustMatcher* inside the matching function.

#. **Match scene descriptors with model descriptors using Flann matcher**
   
   It is the first step in our detection algorithm. The main idea is to match the scene descriptors with our model descriptors in order to know the 3D coordinates of the found features into the current scene.
   
   Firstly, we have to set which matcher we want to use. In this case is used :ref:`cv::FlannBasedMatcher <doxid-de/d48/classcv_1_1_flann_based_matcher>` matcher which in terms of computational cost is faster than the :ref:`cv::BFMatcher <doxid-d9/d49/classcv_1_1_b_f_matcher>` matcher as we increase the trained collectction of features. Then, for FlannBased matcher the index created is *Multi-Probe LSH: Efficient Indexing for High-Dimensional Similarity Search* due to *ORB* descriptors are binary.
   
   You can tune the *LSH* and search parameters to improve the matching efficiency:
   
   .. ref-code-block:: cpp
   
   	:ref:`cv::Ptr\<cv::flann::IndexParams> <doxid-d2/d56/structcv_1_1_ptr>` indexParams = cv::makePtr<cv::flann::LshIndexParams>(6, 12, 1); // instantiate LSH index parameters
   	:ref:`cv::Ptr\<cv::flann::SearchParams> <doxid-d2/d56/structcv_1_1_ptr>` searchParams = cv::makePtr<cv::flann::SearchParams>(50);       // instantiate flann search parameters
   	
   	:ref:`cv::DescriptorMatcher <doxid-d4/d64/classcv_1_1_descriptor_matcher>` * matcher = new :ref:`cv::FlannBasedMatcher <doxid-de/d48/classcv_1_1_flann_based_matcher>`(indexParams, searchParams);         // instantiate FlannBased matcher
   	rmatcher.setDescriptorMatcher(matcher);                                                         // set matcher
   
   Secondly, we have to call the matcher by using *robustMatch()* or *fastRobustMatch()* function. The difference of using this two functions is its computational cost. The first method is slower but more robust at filtering good matches because uses two ratio test and a symmetry test. In contrast, the second method is faster but less robust because only applies a single ratio test to the matches.
   
   The following code is to get the model 3D points and its descriptors and then call the matcher in the main program:
   
   .. ref-code-block:: cpp
   
   	// Get the MODEL INFO
   	
   	std::vector<cv::Point3f> list_points3d_model = model.get_points3d();  // list with model 3D coordinates
   	:ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` descriptors_model = model.get_descriptors();                  // list with descriptors of each 3D coordinate
   
   
   
   .. ref-code-block:: cpp
   
   	// -- Step 1: Robust matching between model descriptors and scene descriptors
   	
   	std::vector<cv::DMatch> good_matches;       // to obtain the model 3D points  in the scene
   	std::vector<cv::KeyPoint> keypoints_scene;  // to obtain the 2D points of the scene
   	
   	if(fast_match)
   	{
   	    rmatcher.fastRobustMatch(frame, good_matches, keypoints_scene, descriptors_model);
   	}
   	else
   	{
   	    rmatcher.robustMatch(frame, good_matches, keypoints_scene, descriptors_model);
   	}
   
   The following code corresponds to the *robustMatch()* function which belongs to the *RobustMatcher* class. This function uses the given image to detect the keypoints and extract the descriptors, match using *two Nearest Neighbour* the extracted descriptors with the given model descriptors and vice versa. Then, a ratio test is applied to the two direction matches in order to remove these matches which its distance ratio between the first and second best match is larger than a given threshold. Finally, a symmetry test is applied in order the remove non symmetrical matches.
   
   .. ref-code-block:: cpp
   
   	void RobustMatcher::robustMatch( const :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>`& frame, std::vector<cv::DMatch>& good_matches,
   	                                 std::vector<cv::KeyPoint>& keypoints_frame,
   	                                 const std::vector<cv::KeyPoint>& keypoints_model, const :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>`& descriptors_model )
   	{
   	
   	    // 1a. Detection of the ORB features
   	    this->computeKeyPoints(frame, keypoints_frame);
   	
   	    // 1b. Extraction of the ORB descriptors
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` descriptors_frame;
   	    this->computeDescriptors(frame, keypoints_frame, descriptors_frame);
   	
   	    // 2. Match the two image descriptors
   	    std::vector<std::vector<cv::DMatch> > matches12, matches21;
   	
   	    // 2a. From image 1 to image 2
   	    matcher_->knnMatch(descriptors_frame, descriptors_model, matches12, 2); // return 2 nearest neighbours
   	
   	    // 2b. From image 2 to image 1
   	    matcher_->knnMatch(descriptors_model, descriptors_frame, matches21, 2); // return 2 nearest neighbours
   	
   	    // 3. Remove matches for which NN ratio is > than threshold
   	    // clean image 1 -> image 2 matches
   	    int removed1 = ratioTest(matches12);
   	    // clean image 2 -> image 1 matches
   	    int removed2 = ratioTest(matches21);
   	
   	    // 4. Remove non-symmetrical matches
   	    symmetryTest(matches12, matches21, good_matches);
   	
   	}
   
   After the matches filtering we have to subtract the 2D and 3D correspondences from the found scene keypoints and our 3D model using the obtained *DMatches* vector. For more information about :ref:`cv::DMatch <doxid-d9/db0/classcv_1_1_d_match>` check the documentation.
   
   .. ref-code-block:: cpp
   
   	// -- Step 2: Find out the 2D/3D correspondences
   	
   	std::vector<cv::Point3f> list_points3d_model_match;    // container for the model 3D coordinates found in the scene
   	std::vector<cv::Point2f> list_points2d_scene_match;    // container for the model 2D coordinates found in the scene
   	
   	for(unsigned int match_index = 0; match_index < good_matches.size(); ++match_index)
   	{
   	    :ref:`cv::Point3f <doxid-d4/d29/classcv_1_1_point3__>` point3d_model = list_points3d_model[ good_matches[match_index].trainIdx ];   // 3D point from model
   	    :ref:`cv::Point2f <doxid-d9/d87/classcv_1_1_point__>` point2d_scene = keypoints_scene[ good_matches[match_index].queryIdx ].pt;    // 2D point from the scene
   	    list_points3d_model_match.push_back(point3d_model);                                      // add 3D point
   	    list_points2d_scene_match.push_back(point2d_scene);                                      // add 2D point
   	}
   
   You can also change the ratio test threshold, the number of keypoints to detect as well as use or not the robust matcher:
   
   .. ref-code-block:: cpp
   
   	./cpp-tutorial-pnp_detection --ratio=0.8 --keypoints=1000 --fast=false

#. **Pose estimation using PnP + Ransac**
   
   Once with the 2D and 3D correspondences we have to apply a PnP algorithm in order to estimate the camera pose. The reason why we have to use :ref:`cv::solvePnPRansac <doxid-d9/d0c/group__calib3d_1ga50620f0e26e02caa2e9adc07b5fbf24e>` instead of :ref:`cv::solvePnP <doxid-d9/d0c/group__calib3d_1ga549c2075fac14829ff4a58bc931c033d>` is due to the fact that after the matching not all the found correspondences are correct and, as like as not, there are false correspondences or also called *outliers*. The `Random Sample Consensus <http://en.wikipedia.org/wiki/RANSAC>`__ or *Ransac* is a non-deterministic iterative method which estimate parameters of a mathematical model from observed data producing an aproximate result as the number of iterations increase. After appyling *Ransac* all the *outliers* will be eliminated to then estimate the camera pose with a certain probability to obtain a good solution.
   
   For the camera pose estimation I have implemented a *class* **PnPProblem**. This *class* has 4 atributes: a given calibration matrix, the rotation matrix, the translation matrix and the rotation-translation matrix. The intrinsic calibration parameters of the camera which you are using to estimate the pose are necessary. In order to obtain the parameters you can check :ref:`Camera calibration with square chessboard <doxid-dc/d43/tutorial_camera_calibration_square_chess>` and :ref:`Camera calibration With OpenCV <doxid-d4/d94/tutorial_camera_calibration>` tutorials.
   
   The following code is how to declare the *PnPProblem class* in the main program:
   
   .. ref-code-block:: cpp
   
   	// Intrinsic camera parameters: UVC WEBCAM
   	
   	double f = 55;                           // focal length in mm
   	double sx = 22.3, sy = 14.9;             // sensor size
   	double width = 640, height = 480;        // image size
   	
   	double params_WEBCAM[] = { width*f/sx,   // fx
   	                           height*f/sy,  // fy
   	                           width/2,      // cx
   	                           height/2};    // cy
   	
   	PnPProblem pnp_detection(params_WEBCAM); // instantiate PnPProblem class
   
   The following code is how the *PnPProblem class* initialises its atributes:
   
   .. ref-code-block:: cpp
   
   	// Custom constructor given the intrinsic camera parameters
   	
   	PnPProblem::PnPProblem(const double params[])
   	{
   	  _A_matrix = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(3, 3, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);   // intrinsic camera parameters
   	  _A_matrix.at<double>(0, 0) = params[0];       //      [ fx   0  cx ]
   	  _A_matrix.at<double>(1, 1) = params[1];       //      [  0  fy  cy ]
   	  _A_matrix.at<double>(0, 2) = params[2];       //      [  0   0   1 ]
   	  _A_matrix.at<double>(1, 2) = params[3];
   	  _A_matrix.at<double>(2, 2) = 1;
   	  _R_matrix = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(3, 3, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);   // rotation matrix
   	  _t_matrix = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(3, 1, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);   // translation matrix
   	  _P_matrix = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(3, 4, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);   // rotation-translation matrix
   	
   	}
   
   OpenCV provides four PnP methods: ITERATIVE, EPNP, P3P and DLS. Depending on the application type, the estimation method will be different. In the case that we want to make a real time application, the more suitable methods are EPNP and P3P due to that are faster than ITERATIVE and DLS at finding an optimal solution. However, EPNP and P3P are not especially robust in front of planar surfaces and sometimes the pose estimation seems to have a mirror effect. Therefore, in this this tutorial is used ITERATIVE method due to the object to be detected has planar surfaces.
   
   The OpenCV Ransac implementation wants you to provide three parameters: the maximum number of iterations until stop the algorithm, the maximum allowed distance between the observed and computed point projections to consider it an inlier and the confidence to obtain a good result. You can tune these paramaters in order to improve your algorithm performance. Increasing the number of iterations you will have a more accurate solution, but will take more time to find a solution. Increasing the reprojection error will reduce the computation time, but your solution will be unaccurate. Decreasing the confidence your arlgorithm will be faster, but the obtained solution will be unaccurate.
   
   The following parameters work for this application:
   
   .. ref-code-block:: cpp
   
   	// RANSAC parameters
   	
   	int iterationsCount = 500;        // number of Ransac iterations.
   	float reprojectionError = 2.0;    // maximum allowed distance to consider it an inlier.
   	float confidence = 0.95;          // ransac successful confidence.
   
   The following code corresponds to the *estimatePoseRANSAC()* function which belongs to the *PnPProblem class*. This function estimates the rotation and translation matrix given a set of 2D/3D correspondences, the desired PnP method to use, the output inliers container and the Ransac parameters:
   
   .. ref-code-block:: cpp
   
   	// Estimate the pose given a list of 2D/3D correspondences with RANSAC and the method to use
   	
   	void PnPProblem::estimatePoseRANSAC( const std::vector<cv::Point3f> &list_points3d,        // list with model 3D coordinates
   	                                     const std::vector<cv::Point2f> &list_points2d,        // list with scene 2D coordinates
   	                                     int flags, :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &inliers, int iterationsCount,     // PnP method; inliers container
   	                                     float reprojectionError, float confidence )           // Ransac parameters
   	{
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` distCoeffs = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(4, 1, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);    // vector of distortion coefficients
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` rvec = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(3, 1, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);          // output rotation vector
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` tvec = :ref:`cv::Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`(3, 1, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);          // output translation vector
   	
   	    bool useExtrinsicGuess = false;   // if true the function uses the provided rvec and tvec values as
   	                                      // initial approximations of the rotation and translation vectors
   	
   	    :ref:`cv::solvePnPRansac <doxid-d9/d0c/group__calib3d_1ga50620f0e26e02caa2e9adc07b5fbf24e>`( list_points3d, list_points2d, _A_matrix, distCoeffs, rvec, tvec,
   	                        useExtrinsicGuess, iterationsCount, reprojectionError, confidence,
   	                        inliers, flags );
   	
   	    :ref:`Rodrigues <doxid-d9/d0c/group__calib3d_1ga61585db663d9da06b68e70cfbf6a1eac>`(rvec,_R_matrix);                   // converts Rotation Vector to Matrix
   	    _t_matrix = tvec;                            // set translation matrix
   	
   	    this->set_P_matrix(_R_matrix, _t_matrix);    // set rotation-translation matrix
   	
   	}
   
   In the following code are the 3th and 4th steps of the main algorithm. The first, calling the above function and the second taking the output inliers vector from Ransac to get the 2D scene points for drawing purpose. As seen in the code we must be sure to apply Ransac if we have matches, in the other case, the function :ref:`cv::solvePnPRansac <doxid-d9/d0c/group__calib3d_1ga50620f0e26e02caa2e9adc07b5fbf24e>` crashes due to any OpenCV *bug*.
   
   .. ref-code-block:: cpp
   
   	if(good_matches.size() > 0) // None matches, then RANSAC crashes
   	{
   	
   	    // -- Step 3: Estimate the pose using RANSAC approach
   	    pnp_detection.estimatePoseRANSAC( list_points3d_model_match, list_points2d_scene_match,
   	                                      pnpMethod, inliers_idx, iterationsCount, reprojectionError, confidence );
   	
   	
   	    // -- Step 4: Catch the inliers keypoints to draw
   	    for(int inliers_index = 0; inliers_index < inliers_idx.rows; ++inliers_index)
   	    {
   	    int n = inliers_idx.at<int>(inliers_index);         // i-inlier
   	    :ref:`cv::Point2f <doxid-d9/d87/classcv_1_1_point__>` point2d = list_points2d_scene_match[n]; // i-inlier point 2D
   	    list_points2d_inliers.push_back(point2d);           // add i-inlier to list
   	}
   
   Finally, once the camera pose has been estimated we can use the :math:`R` and :math:`t` in order to compute the 2D projection onto the image of a given 3D point expressed in a world reference frame using the showed formula on *Theory*.
   
   The following code corresponds to the *backproject3DPoint()* function which belongs to the *PnPProblem class*. The function backproject a given 3D point expressed in a world reference frame onto a 2D image:
   
   .. ref-code-block:: cpp
   
   	// Backproject a 3D point to 2D using the estimated pose parameters
   	
   	:ref:`cv::Point2f <doxid-d9/d87/classcv_1_1_point__>` PnPProblem::backproject3DPoint(const :ref:`cv::Point3f <doxid-d4/d29/classcv_1_1_point3__>` &point3d)
   	{
   	    // 3D point vector [x y z 1]'
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` point3d_vec = :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>`(4, 1, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);
   	    point3d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0) = point3d.:ref:`x <doxid-d4/d29/classcv_1_1_point3___1a363a0ec9e4ebce7209438cb14c29ab47>`;
   	    point3d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1) = point3d.:ref:`y <doxid-d4/d29/classcv_1_1_point3___1aa332b734e658368c647744adb9065810>`;
   	    point3d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2) = point3d.:ref:`z <doxid-d4/d29/classcv_1_1_point3___1a1af9c182772a3c082e505f50eb5d2ee1>`;
   	    point3d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(3) = 1;
   	
   	    // 2D point vector [u v 1]'
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` point2d_vec = :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>`(4, 1, :ref:`CV_64FC1 <doxid-d1/d1b/group__core__hal__interface_1ga3b256d68c6002b6afd60ab9538d717a8>`);
   	    point2d_vec = _A_matrix * _P_matrix * point3d_vec;
   	
   	    // Normalization of [u v]'
   	    :ref:`cv::Point2f <doxid-d9/d87/classcv_1_1_point__>` point2d;
   	    point2d.:ref:`x <doxid-d9/d87/classcv_1_1_point___1a4c96fa7bdbfe390be5ed356edb274ff3>` = point2d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0) / point2d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2);
   	    point2d.:ref:`y <doxid-d9/d87/classcv_1_1_point___1a157337197338ff199e5df1a393022f15>` = point2d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1) / point2d_vec.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2);
   	
   	    return point2d;
   	}
   
   The above function is used to compute all the 3D points of the object *Mesh* to show the pose of the object.
   
   You can also change RANSAC parameters and PnP method:
   
   .. ref-code-block:: cpp
   
   	./cpp-tutorial-pnp_detection --:ref:`error <doxid-db/de0/group__core__utils_1gacbd081fdb20423a63cf731569ba70b2b>`=0.25 --confidence=0.90 --iterations=250 --method=3

#. **Linear Kalman Filter for bad poses rejection**
   
   Is it common in computer vision or robotics fields that after applying detection or tracking techniques, bad results are obtained due to some sensor errors. In order to avoid these bad detections in this tutorial is explained how to implement a Linear Kalman Filter. The Kalman Filter will be applied after detected a given number of inliers.
   
   You can find more information about what `Kalman Filter <http://en.wikipedia.org/wiki/Kalman_filter>`__ is. In this tutorial it's used the OpenCV implementation of the :ref:`cv::KalmanFilter <doxid-d3/dfb/classcv_1_1_kalman_filter>` based on `Linear Kalman Filter for position and orientation tracking <http://campar.in.tum.de/Chair/KalmanFilter>`__ to set the dynamics and measurement models.
   
   Firstly, we have to define our state vector which will have 18 states: the positional data (x,y,z) with its first and second derivatives (velocity and acceleration), then rotation is added in form of three euler angles (roll, pitch, jaw) together with their first and second derivatives (angular velocity and acceleration)
   
   .. math::
   
   	X = (x,y,z,\dot x,\dot y,\dot z,\ddot x,\ddot y,\ddot z,\psi,\theta,\phi,\dot \psi,\dot \theta,\dot \phi,\ddot \psi,\ddot \theta,\ddot \phi)^T
   
   Secondly, we have to define the number of measuremnts which will be 6: from :math:`R` and :math:`t` we can extract :math:`(x,y,z)` and :math:`(\psi,\theta,\phi)`. In addition, we have to define the number of control actions to apply to the system which in this case will be *zero*. Finally, we have to define the differential time between measurements which in this case is :math:`1/T`, where *T* is the frame rate of the video.
   
   .. ref-code-block:: cpp
   
   	:ref:`cv::KalmanFilter <doxid-d3/dfb/classcv_1_1_kalman_filter>` KF;         // instantiate Kalman Filter
   	
   	int nStates = 18;            // the number of states
   	int nMeasurements = 6;       // the number of measured states
   	int nInputs = 0;             // the number of action control
   	
   	double dt = 0.125;           // time between measurements (1/FPS)
   	
   	initKalmanFilter(KF, nStates, nMeasurements, nInputs, dt);    // init function
   
   The following code corresponds to the *Kalman Filter* initialisation. Firstly, is set the process noise, the measurement noise and the error covariance matrix. Secondly, are set the transition matrix which is the dynamic model and finally the measurement matrix, which is the measurement model.
   
   You can tune the process and measurement noise to improve the *Kalman Filter* performance. As the measurement noise is reduced the faster will converge doing the algorithm sensitive in front of bad measurements.
   
   .. ref-code-block:: cpp
   
   	void initKalmanFilter(:ref:`cv::KalmanFilter <doxid-d3/dfb/classcv_1_1_kalman_filter>` &KF, int nStates, int nMeasurements, int nInputs, double dt)
   	{
   	
   	  KF.:ref:`init <doxid-d3/dfb/classcv_1_1_kalman_filter_1a4f136c39c016d3530c7c5801dd1ddb3b>`(nStates, nMeasurements, nInputs, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);                 // init Kalman Filter
   	
   	  :ref:`cv::setIdentity <doxid-d2/de8/group__core__array_1ga388d7575224a4a277ceb98ccaa327c99>`(KF.:ref:`processNoiseCov <doxid-d3/dfb/classcv_1_1_kalman_filter_1af19be9c0630d0f658bdbaea409a35cda>`, :ref:`cv::Scalar::all <doxid-d7/d13/classcv_1_1_scalar___1ac1509a4b8454fe7fe29db069e13a2e6f>`(1e-5));       // set process noise
   	  :ref:`cv::setIdentity <doxid-d2/de8/group__core__array_1ga388d7575224a4a277ceb98ccaa327c99>`(KF.:ref:`measurementNoiseCov <doxid-d3/dfb/classcv_1_1_kalman_filter_1a828d051035ba807966ad65edf288a08e>`, :ref:`cv::Scalar::all <doxid-d7/d13/classcv_1_1_scalar___1ac1509a4b8454fe7fe29db069e13a2e6f>`(1e-4));   // set measurement noise
   	  :ref:`cv::setIdentity <doxid-d2/de8/group__core__array_1ga388d7575224a4a277ceb98ccaa327c99>`(KF.:ref:`errorCovPost <doxid-d3/dfb/classcv_1_1_kalman_filter_1a446d8e9a0105b0aa35cd66119c529803>`, :ref:`cv::Scalar::all <doxid-d7/d13/classcv_1_1_scalar___1ac1509a4b8454fe7fe29db069e13a2e6f>`(1));             // error covariance
   	
   	
   	                 /* DYNAMIC MODEL */
   	
   	  //  [1 0 0 dt  0  0 dt2   0   0 0 0 0  0  0  0   0   0   0]
   	  //  [0 1 0  0 dt  0   0 dt2   0 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 1  0  0 dt   0   0 dt2 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  1  0  0  dt   0   0 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  0  1  0   0  dt   0 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  0  0  1   0   0  dt 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  0  0  0   1   0   0 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  0  0  0   0   1   0 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  0  0  0   0   0   1 0 0 0  0  0  0   0   0   0]
   	  //  [0 0 0  0  0  0   0   0   0 1 0 0 dt  0  0 dt2   0   0]
   	  //  [0 0 0  0  0  0   0   0   0 0 1 0  0 dt  0   0 dt2   0]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 1  0  0 dt   0   0 dt2]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 0  1  0  0  dt   0   0]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 0  0  1  0   0  dt   0]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 0  0  0  1   0   0  dt]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 0  0  0  0   1   0   0]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 0  0  0  0   0   1   0]
   	  //  [0 0 0  0  0  0   0   0   0 0 0 0  0  0  0   0   0   1]
   	
   	  // position
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0,3) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1,4) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2,5) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(3,6) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(4,7) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(5,8) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0,6) = 0.5*:ref:`pow <doxid-d2/d75/namespacecv_1a8bc36646a43b82baa15f151a973fb0c5>`(dt,2);
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1,7) = 0.5*:ref:`pow <doxid-d2/d75/namespacecv_1a8bc36646a43b82baa15f151a973fb0c5>`(dt,2);
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2,8) = 0.5*:ref:`pow <doxid-d2/d75/namespacecv_1a8bc36646a43b82baa15f151a973fb0c5>`(dt,2);
   	
   	  // orientation
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(9,12) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(10,13) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(11,14) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(12,15) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(13,16) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(14,17) = dt;
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(9,15) = 0.5*:ref:`pow <doxid-d2/d75/namespacecv_1a8bc36646a43b82baa15f151a973fb0c5>`(dt,2);
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(10,16) = 0.5*:ref:`pow <doxid-d2/d75/namespacecv_1a8bc36646a43b82baa15f151a973fb0c5>`(dt,2);
   	  KF.:ref:`transitionMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0657173e411acbf40d2d3c6b46e03b19>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(11,17) = 0.5*:ref:`pow <doxid-d2/d75/namespacecv_1a8bc36646a43b82baa15f151a973fb0c5>`(dt,2);
   	
   	
   	       /* MEASUREMENT MODEL */
   	
   	  //  [1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
   	  //  [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
   	  //  [0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
   	  //  [0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0]
   	  //  [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]
   	  //  [0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]
   	
   	  KF.:ref:`measurementMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0f60b78726d8eccf74a1f2479c2d1f97>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0,0) = 1;  // x
   	  KF.:ref:`measurementMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0f60b78726d8eccf74a1f2479c2d1f97>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1,1) = 1;  // y
   	  KF.:ref:`measurementMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0f60b78726d8eccf74a1f2479c2d1f97>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2,2) = 1;  // z
   	  KF.:ref:`measurementMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0f60b78726d8eccf74a1f2479c2d1f97>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(3,9) = 1;  // roll
   	  KF.:ref:`measurementMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0f60b78726d8eccf74a1f2479c2d1f97>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(4,10) = 1; // pitch
   	  KF.:ref:`measurementMatrix <doxid-d3/dfb/classcv_1_1_kalman_filter_1a0f60b78726d8eccf74a1f2479c2d1f97>`.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(5,11) = 1; // yaw
   	
   	}
   
   In the following code is the 5th step of the main algorithm. When the obtained number of inliers after *Ransac* is over the threshold, the measurements matrix is filled and then the *Kalman Filter* is updated:
   
   .. ref-code-block:: cpp
   
   	// -- Step 5: Kalman Filter
   	
   	// GOOD MEASUREMENT
   	if( inliers_idx.rows >= minInliersKalman )
   	{
   	
   	    // Get the measured translation
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` translation_measured(3, 1, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);
   	    translation_measured = pnp_detection.get_t_matrix();
   	
   	    // Get the measured rotation
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` rotation_measured(3, 3, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);
   	    rotation_measured = pnp_detection.get_R_matrix();
   	
   	    // fill the measurements vector
   	    fillMeasurements(measurements, translation_measured, rotation_measured);
   	
   	}
   	
   	// Instantiate estimated translation and rotation
   	:ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` translation_estimated(3, 1, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);
   	:ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` rotation_estimated(3, 3, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);
   	
   	// update the Kalman filter with good measurements
   	updateKalmanFilter( KF, measurements,
   	              translation_estimated, rotation_estimated);
   
   The following code corresponds to the *fillMeasurements()* function which converts the measured `Rotation Matrix to Eulers angles <http://euclideanspace.com/maths/geometry/rotations/conversions/matrixToEuler/index.htm>`__ and fill the measurements matrix along with the measured translation vector:
   
   .. ref-code-block:: cpp
   
   	void fillMeasurements( :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &measurements,
   	                   const :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &translation_measured, const :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &rotation_measured)
   	{
   	    // Convert rotation matrix to euler angles
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` measured_eulers(3, 1, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);
   	    measured_eulers = rot2euler(rotation_measured);
   	
   	    // Set measurement to predict
   	    measurements.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0) = translation_measured.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0); // x
   	    measurements.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1) = translation_measured.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1); // y
   	    measurements.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2) = translation_measured.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2); // z
   	    measurements.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(3) = measured_eulers.at<double>(0);      // roll
   	    measurements.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(4) = measured_eulers.at<double>(1);      // pitch
   	    measurements.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(5) = measured_eulers.at<double>(2);      // yaw
   	}
   
   The following code corresponds to the *updateKalmanFilter()* function which update the Kalman Filter and set the estimated Rotation Matrix and translation vector. The estimated Rotation Matrix comes from the estimated `Euler angles to Rotation Matrix <http://euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/index.htm>`__.
   
   .. ref-code-block:: cpp
   
   	void updateKalmanFilter( :ref:`cv::KalmanFilter <doxid-d3/dfb/classcv_1_1_kalman_filter>` &KF, :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &measurement,
   	                     :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &translation_estimated, :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` &rotation_estimated )
   	{
   	
   	    // First predict, to update the internal statePre variable
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` prediction = KF.:ref:`predict <doxid-d3/dfb/classcv_1_1_kalman_filter_1aa710d2255566bec8d6ce608d103d4fa7>`();
   	
   	    // The "correct" phase that is going to use the predicted value and our measurement
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` estimated = KF.:ref:`correct <doxid-d3/dfb/classcv_1_1_kalman_filter_1a60eb7feb569222ad0657ef1875884b5e>`(measurement);
   	
   	    // Estimated translation
   	    translation_estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0) = estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(0);
   	    translation_estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1) = estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(1);
   	    translation_estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2) = estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(2);
   	
   	    // Estimated euler angles
   	    :ref:`cv::Mat <doxid-db/de6/classcv_1_1_mat>` eulers_estimated(3, 1, :ref:`CV_64F <doxid-d1/d1b/group__core__hal__interface_1ga30a562691cc5987bc88eb7bb7a8faf2b>`);
   	    eulers_estimated.at<double>(0) = estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(9);
   	    eulers_estimated.at<double>(1) = estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(10);
   	    eulers_estimated.at<double>(2) = estimated.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<double>(11);
   	
   	    // Convert estimated quaternion to rotation matrix
   	    rotation_estimated = euler2rot(eulers_estimated);
   	
   	}
   
   The 6th step is set the estimated rotation-translation matrix:
   
   .. ref-code-block:: cpp
   
   	// -- Step 6: Set estimated projection matrix
   	pnp_detection_est.set_P_matrix(rotation_estimated, translation_estimated);
   
   The last and optional step is draw the found pose. To do it I implemented a function to draw all the mesh 3D points and an extra reference axis:
   
   .. ref-code-block:: cpp
   
   	// -- Step X: Draw pose
   	
   	drawObjectMesh(frame_vis, &mesh, &pnp_detection, green);                // draw current pose
   	drawObjectMesh(frame_vis, &mesh, &pnp_detection_est, yellow);           // draw estimated pose
   	
   	double l = 5;
   	std::vector<cv::Point2f> pose_points2d;
   	pose_points2d.push_back(pnp_detection_est.backproject3DPoint(:ref:`cv::Point3f <doxid-d4/d29/classcv_1_1_point3__>`(0,0,0)));    // axis center
   	pose_points2d.push_back(pnp_detection_est.backproject3DPoint(:ref:`cv::Point3f <doxid-d4/d29/classcv_1_1_point3__>`(l,0,0)));    // axis x
   	pose_points2d.push_back(pnp_detection_est.backproject3DPoint(:ref:`cv::Point3f <doxid-d4/d29/classcv_1_1_point3__>`(0,l,0)));    // axis y
   	pose_points2d.push_back(pnp_detection_est.backproject3DPoint(:ref:`cv::Point3f <doxid-d4/d29/classcv_1_1_point3__>`(0,0,l)));    // axis z
   	draw3DCoordinateAxes(frame_vis, pose_points2d);                                       // draw axes
   
   You can also modify the minimum inliers to update Kalman Filter:
   
   .. ref-code-block:: cpp
   
   	./cpp-tutorial-pnp_detection --inliers=20

.. rubric:: Results

The following videos are the results of pose estimation in real time using the explained detection algorithm using the following parameters:

.. ref-code-block:: cpp

	// Robust Matcher parameters
	
	int numKeyPoints = 2000;      // number of detected keypoints
	float ratio = 0.70f;          // ratio test
	bool fast_match = true;       // fastRobustMatch() or robustMatch()
	
	
	// RANSAC parameters
	
	int iterationsCount = 500;    // number of Ransac iterations.
	int reprojectionError = 2.0;  // maximum allowed distance to consider it an inlier.
	float confidence = 0.95;      // ransac successful confidence.
	
	
	// Kalman Filter parameters
	
	int minInliersKalman = 30;    // Kalman threshold updating

You can watch the real time pose estimation on the `YouTube here <http://www.youtube.com/user/opencvdev/videos>`__.

