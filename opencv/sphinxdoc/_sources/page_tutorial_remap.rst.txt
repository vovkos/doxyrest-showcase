.. index:: pair: page; Remapping
.. _doxid-d1/da0/tutorial_remap:

Remapping
=========

.. rubric:: Goal

In this tutorial you will learn how to:

a. Use the OpenCV function :ref:`cv::remap <doxid-da/d54/group__imgproc__transform_1gab75ef31ce5cdfb5c44b6da5f3b908ea4>` to implement simple remapping routines.

.. rubric:: Theory

.. rubric:: What is remapping?

* It is the process of taking pixels from one place in the image and locating them in another position in a new image.

* To accomplish the mapping process, it might be necessary to do some interpolation for non-integer pixel locations, since there will not always be a one-to-one-pixel correspondence between source and destination images.

* We can express the remap for every pixel location :math:`(x,y)` as:
  
  .. math::
  
  	g(x,y) = f ( h(x,y) )
  
  where :math:`g()` is the remapped image, :math:`f()` the source image and :math:`h(x,y)` is the mapping function that operates on :math:`(x,y)`.

* Let's think in a quick example. Imagine that we have an image :math:`I` and, say, we want to do a remap such that:
  
  .. math::
  
  	h(x,y) = (I.cols - x, y )
  
  What would happen? It is easily seen that the image would flip in the :math:`x` direction. For instance, consider the input image:
  
  .. image:: Remap_Tutorial_Theory_0.jpg
  
  observe how the red circle changes positions with respect to x (considering :math:`x` the horizontal direction):
  
  .. image:: Remap_Tutorial_Theory_1.jpg

* In OpenCV, the function :ref:`cv::remap <doxid-da/d54/group__imgproc__transform_1gab75ef31ce5cdfb5c44b6da5f3b908ea4>` offers a simple remapping implementation.

.. rubric:: Code

#. **What does this program do?**
   
   * Loads an image
   
   * Each second, apply 1 of 4 different remapping processes to the image and display them indefinitely in a window.
   
   * Wait for the user to exit the program

#. The tutorial code's is shown lines below. You can also download it from `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/ImgTrans/Remap_Demo.cpp>`__
   
   .. ref-code-block:: cpp
   
   	
   	#include "opencv2/imgcodecs.hpp"
   	#include "opencv2/highgui.hpp"
   	#include "opencv2/imgproc.hpp"
   	#include <iostream>
   	
   	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
   	
   	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, dst;
   	:ref:`Mat <doxid-db/de6/classcv_1_1_mat>` map_x, map_y;
   	const char* remap_window = "Remap demo";
   	int ind = 0;
   	
   	void update_map( void );
   	
   	int main( int, char** argv )
   	{
   	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` );
   	
   	  dst.:ref:`create <doxid-db/de6/classcv_1_1_mat_1a55ced2c8d844d683ea9a725c60037ad0>`( src.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`(), src.:ref:`type <doxid-db/de6/classcv_1_1_mat_1af2d2652e552d7de635988f18a84b53e5>`() );
   	  map_x.:ref:`create <doxid-db/de6/classcv_1_1_mat_1a55ced2c8d844d683ea9a725c60037ad0>`( src.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`(), :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	  map_y.:ref:`create <doxid-db/de6/classcv_1_1_mat_1a55ced2c8d844d683ea9a725c60037ad0>`( src.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`(), :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	
   	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( remap_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	
   	  for(;;)
   	  {
   	    char c = (char):ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`( 1000 );
   	
   	    if( c == 27 )
   	      { break; }
   	
   	    update_map();
   	    :ref:`remap <doxid-da/d54/group__imgproc__transform_1gab75ef31ce5cdfb5c44b6da5f3b908ea4>`( src, dst, map_x, map_y, :ref:`INTER_LINEAR <doxid-da/d54/group__imgproc__transform_1gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb>`, :ref:`BORDER_CONSTANT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838>`, :ref:`Scalar <doxid-dc/d84/group__core__basic_1ga599fe92e910c027be274233eccad7beb>`(0, 0, 0) );
   	
   	    // Display results
   	    :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( remap_window, dst );
   	  }
   	  return 0;
   	}
   	
   	void update_map( void )
   	{
   	  ind = ind%4;
   	
   	  for( int j = 0; j < src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`; j++ )
   	    { for( int i = 0; i < src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`; i++ )
   	     {
   	           switch( ind )
   	         {
   	         case 0:
   	           if( i > src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`*0.25 && i < src.cols*0.75 && j > src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`*0.25 && j < src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`*0.75 )
   	                 {
   	               map_x.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = 2*( i - src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`*0.25f ) + 0.5f ;
   	               map_y.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = 2*( j - src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`*0.25f ) + 0.5f ;
   	              }
   	           else
   	         { map_x.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = 0 ;
   	               map_y.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = 0 ;
   	                 }
   	                   break;
   	         case 1:
   	               map_x.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = (float)i ;
   	               map_y.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = (float)(src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>` - j) ;
   	           break;
   	             case 2:
   	               map_x.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = (float)(src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>` - i) ;
   	               map_y.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = (float)j ;
   	           break;
   	             case 3:
   	               map_x.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = (float)(src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>` - i) ;
   	               map_y.:ref:`at <doxid-db/de6/classcv_1_1_mat_1aa5d20fc86d41d59e4d71ae93daee9726>`<float>(j,i) = (float)(src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>` - j) ;
   	           break;
   	             } // end of switch
   	     }
   	    }
   	  ind++;
   	}

.. rubric:: Explanation

#. Create some variables we will use:
   
   .. ref-code-block:: cpp
   
   	Mat src, dst;
   	Mat map_x, map_y;
   	char* remap_window = "Remap demo";
   	int ind = 0;

#. Load an image:
   
   .. ref-code-block:: cpp
   
   	src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], 1 );

#. Create the destination image and the two mapping matrices (for x and y )
   
   .. ref-code-block:: cpp
   
   	dst.create( src.size(), src.type() );
   	map_x.create( src.size(), :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	map_y.create( src.size(), :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );

#. Create a window to display results
   
   .. ref-code-block:: cpp
   
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( remap_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );

#. Establish a loop. Each 1000 ms we update our mapping matrices (*mat_x* and *mat_y*) and apply them to our source image:
   
   .. ref-code-block:: cpp
   
   	while( true )
   	{
   	  char c = (char):ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`( 1000 );
   	
   	  if( c == 27 )
   	    { break; }
   	
   	  update_map();
   	  :ref:`remap <doxid-da/d54/group__imgproc__transform_1gab75ef31ce5cdfb5c44b6da5f3b908ea4>`( src, dst, map_x, map_y, :ref:`INTER_LINEAR <doxid-da/d54/group__imgproc__transform_1gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb>`, :ref:`BORDER_CONSTANT <doxid-d2/de8/group__core__array_1gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838>`, :ref:`Scalar <doxid-dc/d84/group__core__basic_1ga599fe92e910c027be274233eccad7beb>`(0,0, 0) );
   	
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( remap_window, dst );
   	}
   
   The function that applies the remapping is :ref:`cv::remap <doxid-da/d54/group__imgproc__transform_1gab75ef31ce5cdfb5c44b6da5f3b908ea4>`. We give the following arguments:
   
   * **src** : Source image
   
   * **dst** : Destination image of same size as *src*
   
   * **map_x** : The mapping function in the x direction. It is equivalent to the first component of :math:`h(i,j)`
   
   * **map_y** : Same as above, but in y direction. Note that *map_y* and *map_x* are both of the same size as *src*
   
   * **INTER_LINEAR** : The type of interpolation to use for non-integer pixels. This is by default.
   
   * **BORDER_CONSTANT** : Default
   
   How do we update our mapping matrices *mat_x* and *mat_y*? Go on reading:

#. **Updating the mapping matrices:** We are going to perform 4 different mappings:
   
   #. Reduce the picture to half its size and will display it in the middle:
      
      .. math::
      
      	h(i,j) = ( 2*i - src.cols/2 + 0.5, 2*j - src.rows/2 + 0.5)
      
      for all pairs :math:`(i,j)` such that: :math:`\dfrac{src.cols}{4}<i<\dfrac{3 \cdot src.cols}{4}` and :math:`\dfrac{src.rows}{4}<j<\dfrac{3 \cdot src.rows}{4}`
   
   #. Turn the image upside down: :math:`h( i, j ) = (i, src.rows - j)`
   
   #. Reflect the image from left to right: :math:`h(i,j) = ( src.cols - i, j )`
   
   #. Combination of b and c: :math:`h(i,j) = ( src.cols - i, src.rows - j )`

This is expressed in the following snippet. Here, *map_x* represents the first coordinate of *h(i,j)* and *map_y* the second coordinate.

.. ref-code-block:: cpp

	for( int j = 0; j < src.rows; j++ )
	{ for( int i = 0; i < src.cols; i++ )
	{
	      switch( ind )
	  {
	    case 0:
	      if( i > src.cols*0.25 && i < src.cols*0.75 && j > src.rows*0.25 && j < src.rows*0.75 )
	            {
	          map_x.at<float>(j,i) = 2*( i - src.cols*0.25 ) + 0.5 ;
	          map_y.at<float>(j,i) = 2*( j - src.rows*0.25 ) + 0.5 ;
	         }
	      else
	    { map_x.at<float>(j,i) = 0 ;
	          map_y.at<float>(j,i) = 0 ;
	            }
	              break;
	    case 1:
	          map_x.at<float>(j,i) = i ;
	          map_y.at<float>(j,i) = src.rows - j ;
	      break;
	        case 2:
	          map_x.at<float>(j,i) = src.cols - i ;
	          map_y.at<float>(j,i) = j ;
	      break;
	        case 3:
	          map_x.at<float>(j,i) = src.cols - i ;
	          map_y.at<float>(j,i) = src.rows - j ;
	      break;
	      } // end of switch
	}
	  }
	 ind++;
	}

.. rubric:: Result

#. After compiling the code above, you can execute it giving as argument an image path. For instance, by using the following image:
   
   .. image:: Remap_Tutorial_Original_Image.jpg

#. This is the result of reducing it to half the size and centering it:
   
   .. image:: Remap_Tutorial_Result_0.jpg

#. Turning it upside down:
   
   .. image:: Remap_Tutorial_Result_1.jpg

#. Reflecting it in the x direction:
   
   .. image:: Remap_Tutorial_Result_2.jpg

#. Reflecting it in both directions:
   
   .. image:: Remap_Tutorial_Result_3.jpg

