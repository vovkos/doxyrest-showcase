.. index:: pair: page; Affine Transformations
.. _doxid-d4/d61/tutorial_warp_affine:

Affine Transformations
======================

.. rubric:: Goal

In this tutorial you will learn how to:

* Use the OpenCV function :ref:`cv::warpAffine <doxid-da/d54/group__imgproc__transform_1ga0203d9ee5fcd28d40dbc4a1ea4451983>` to implement simple remapping routines.

* Use the OpenCV function :ref:`cv::getRotationMatrix2D <doxid-da/d54/group__imgproc__transform_1gafbbc470ce83812914a70abfb604f4326>` to obtain a :math:`2 \times 3` rotation matrix

.. rubric:: Theory

.. rubric:: What is an Affine Transformation?

#. A transformation that can be expressed in the form of a *matrix multiplication* (linear transformation) followed by a *vector addition* (translation).

#. From the above, we can use an Affine Transformation to express:
   
   #. Rotations (linear transformation)
   
   #. Translations (vector addition)
   
   #. Scale operations (linear transformation)
   
   you can see that, in essence, an Affine Transformation represents a **relation** between two images.

#. The usual way to represent an Affine Transformation is by using a :math:`2 \times 3` matrix.
   
   .. math::
   
   	A = \begin{bmatrix} a_{00} & a_{01} \\ a_{10} & a_{11} \end{bmatrix}_{2 \times 2} B = \begin{bmatrix} b_{00} \\ b_{10} \end{bmatrix}_{2 \times 1}
   
   
   
   .. math::
   
   	M = \begin{bmatrix} A & B \end{bmatrix} = \begin{bmatrix} a_{00} & a_{01} & b_{00} \\ a_{10} & a_{11} & b_{10} \end{bmatrix}_{2 \times 3}
   
   Considering that we want to transform a 2D vector :math:`X = \begin{bmatrix}x \\ y\end{bmatrix}` by using :math:`A` and :math:`B`, we can do the same with:
   
   :math:`T = A \cdot \begin{bmatrix}x \\ y\end{bmatrix} + B` or :math:`T = M \cdot [x, y, 1]^{T}`
   
   .. math::
   
   	T = \begin{bmatrix} a_{00}x + a_{01}y + b_{00} \\ a_{10}x + a_{11}y + b_{10} \end{bmatrix}

.. rubric:: How do we get an Affine Transformation?

#. We mentioned that an Affine Transformation is basically a **relation** between two images. The information about this relation can come, roughly, in two ways:
   
   #. We know both :math:`X` and T and we also know that they are related. Then our task is to find :math:`M`
   
   #. We know :math:`M` and :math:`X`. To obtain :math:`T` we only need to apply :math:`T = M \cdot X`. Our information for :math:`M` may be explicit (i.e. have the 2-by-3 matrix) or it can come as a geometric relation between points.

#. Let's explain this in a better way (b). Since :math:`M` relates 2 images, we can analyze the simplest case in which it relates three points in both images. Look at the figure below:
   
   .. image:: Warp_Affine_Tutorial_Theory_0.jpg
   
   the points 1, 2 and 3 (forming a triangle in image 1) are mapped into image 2, still forming a triangle, but now they have changed notoriously. If we find the Affine Transformation with these 3 points (you can choose them as you like), then we can apply this found relation to all the pixels in an image.

.. rubric:: Code

#. **What does this program do?**
   
   * Loads an image
   
   * Applies an Affine Transform to the image. This transform is obtained from the relation between three points. We use the function :ref:`cv::warpAffine <doxid-da/d54/group__imgproc__transform_1ga0203d9ee5fcd28d40dbc4a1ea4451983>` for that purpose.
   
   * Applies a Rotation to the image after being transformed. This rotation is with respect to the image center
   
   * Waits until the user exits the program

#. The tutorial's code is shown below. You can also download it here `here <https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/ImgTrans/Geometric_Transforms_Demo.cpp>`__
   
   .. ref-code-block:: cpp
   
   	
   	#include "opencv2/imgcodecs.hpp"
   	#include "opencv2/highgui.hpp"
   	#include "opencv2/imgproc.hpp"
   	#include <iostream>
   	
   	using namespace :ref:`cv <doxid-d2/d75/namespacecv>`;
   	using namespace :ref:`std <doxid-d8/dcc/namespacestd>`;
   	
   	const char* source_window = "Source image";
   	const char* warp_window = "Warp";
   	const char* warp_rotate_window = "Warp + Rotate";
   	
   	int main( int, char** argv )
   	{
   	  Point2f srcTri[3];
   	  Point2f dstTri[3];
   	
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` rot_mat( 2, 3, :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` warp_mat( 2, 3, :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	  :ref:`Mat <doxid-db/de6/classcv_1_1_mat>` src, warp_dst, warp_rotate_dst;
   	
   	  src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], :ref:`IMREAD_COLOR <doxid-d4/da8/group__imgcodecs_1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822>` );
   	
   	  warp_dst = :ref:`Mat::zeros <doxid-db/de6/classcv_1_1_mat_1a0b57b6a326c8876d944d188a46e0f556>`( src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`, src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`, src.:ref:`type <doxid-db/de6/classcv_1_1_mat_1af2d2652e552d7de635988f18a84b53e5>`() );
   	
   	  srcTri[0] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( 0,0 );
   	  srcTri[1] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>` - 1.f, 0 );
   	  srcTri[2] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( 0, src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>` - 1.f );
   	
   	  dstTri[0] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`*0.0f, src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`*0.33f );
   	  dstTri[1] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`*0.85f, src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`*0.25f );
   	  dstTri[2] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`*0.15f, src.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`*0.7f );
   	
   	  warp_mat = :ref:`getAffineTransform <doxid-da/d54/group__imgproc__transform_1ga8f6d378f9f8eebb5cb55cd3ae295a999>`( srcTri, dstTri );
   	
   	  :ref:`warpAffine <doxid-da/d54/group__imgproc__transform_1ga0203d9ee5fcd28d40dbc4a1ea4451983>`( src, warp_dst, warp_mat, warp_dst.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`() );
   	
   	  Point center = :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( warp_dst.:ref:`cols <doxid-db/de6/classcv_1_1_mat_1aa3e5a47585c9ef6a0842556739155e3e>`/2, warp_dst.:ref:`rows <doxid-db/de6/classcv_1_1_mat_1abed816466c45234254d25bc59c31245e>`/2 );
   	  double angle = -50.0;
   	  double scale = 0.6;
   	
   	  rot_mat = :ref:`getRotationMatrix2D <doxid-da/d54/group__imgproc__transform_1gafbbc470ce83812914a70abfb604f4326>`( center, angle, scale );
   	
   	  :ref:`warpAffine <doxid-da/d54/group__imgproc__transform_1ga0203d9ee5fcd28d40dbc4a1ea4451983>`( warp_dst, warp_rotate_dst, rot_mat, warp_dst.:ref:`size <doxid-db/de6/classcv_1_1_mat_1a146f8e8dda07d1365a575ab83d9828d1>`() );
   	
   	
   	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( source_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( source_window, src );
   	
   	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( warp_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( warp_window, warp_dst );
   	
   	  :ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( warp_rotate_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	  :ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( warp_rotate_window, warp_rotate_dst );
   	
   	  :ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);
   	
   	  return 0;
   	}

.. rubric:: Explanation

#. Declare some variables we will use, such as the matrices to store our results and 2 arrays of points to store the 2D points that define our Affine Transform.
   
   .. ref-code-block:: cpp
   
   	Point2f srcTri[3];
   	Point2f dstTri[3];
   	
   	Mat rot_mat( 2, 3, :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	Mat warp_mat( 2, 3, :ref:`CV_32FC1 <doxid-d1/d1b/group__core__hal__interface_1ga32ec76240e43e4c9c7b2e2785180a7e6>` );
   	Mat src, warp_dst, warp_rotate_dst;

#. Load an image:
   
   .. ref-code-block:: cpp
   
   	src = :ref:`imread <doxid-d4/da8/group__imgcodecs_1ga288b8b3da0892bd651fce07b3bbd3a56>`( argv[1], 1 );

#. Initialize the destination image as having the same size and type as the source:
   
   .. ref-code-block:: cpp
   
   	warp_dst = Mat::zeros( src.rows, src.cols, src.type() );

#. **Affine Transform:** As we explained in lines above, we need two sets of 3 points to derive the affine transform relation. Have a look:
   
   .. ref-code-block:: cpp
   
   	srcTri[0] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( 0, 0 );
   	srcTri[1] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.cols - 1, 0 );
   	srcTri[2] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( 0, src.rows - 1 );
   	
   	dstTri[0] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.cols*0.0, src.rows*0.33 );
   	dstTri[1] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.cols*0.85, src.rows*0.25 );
   	dstTri[2] = :ref:`Point2f <doxid-dc/d84/group__core__basic_1ga7d080aa40de011e4410bca63385ffe2a>`( src.cols*0.15, src.rows*0.7 );
   
   You may want to draw these points to get a better idea on how they change. Their locations are approximately the same as the ones depicted in the example figure (in the Theory section). You may note that the size and orientation of the triangle defined by the 3 points change.

#. Armed with both sets of points, we calculate the Affine Transform by using OpenCV function :ref:`cv::getAffineTransform <doxid-da/d54/group__imgproc__transform_1ga8f6d378f9f8eebb5cb55cd3ae295a999>` :
   
   .. ref-code-block:: cpp
   
   	warp_mat = :ref:`getAffineTransform <doxid-da/d54/group__imgproc__transform_1ga8f6d378f9f8eebb5cb55cd3ae295a999>`( srcTri, dstTri );
   
   We get a :math:`2 \times 3` matrix as an output (in this case **warp_mat**)

#. We then apply the Affine Transform just found to the src image
   
   .. ref-code-block:: cpp
   
   	:ref:`warpAffine <doxid-d5/df1/group__imgproc__hal__functions_1ga8a534cca6fb845c9ac77f10c35f67c0c>`( src, warp_dst, warp_mat, warp_dst.size() );
   
   with the following arguments:
   
   * **src** : Input image
   
   * **warp_dst** : Output image
   
   * **warp_mat** : Affine transform
   
   * **warp_dst.size()** : The desired size of the output image
   
   We just got our first transformed image! We will display it in one bit. Before that, we also want to rotate it...

#. **Rotate:** To rotate an image, we need to know two things:
   
   #. The center with respect to which the image will rotate
   
   #. The angle to be rotated. In OpenCV a positive angle is counter-clockwise
   
   #. *Optional:* A scale factor
   
   We define these parameters with the following snippet:
   
   .. ref-code-block:: cpp
   
   	Point center = :ref:`Point <doxid-dc/d84/group__core__basic_1ga1e83eafb2d26b3c93f09e8338bcab192>`( warp_dst.cols/2, warp_dst.rows/2 );
   	double angle = -50.0;
   	double scale = 0.6;

#. We generate the rotation matrix with the OpenCV function :ref:`cv::getRotationMatrix2D <doxid-da/d54/group__imgproc__transform_1gafbbc470ce83812914a70abfb604f4326>`, which returns a :math:`2 \times 3` matrix (in this case *rot_mat*)
   
   .. ref-code-block:: cpp
   
   	rot_mat = :ref:`getRotationMatrix2D <doxid-da/d54/group__imgproc__transform_1gafbbc470ce83812914a70abfb604f4326>`( center, angle, scale );

#. We now apply the found rotation to the output of our previous Transformation.
   
   .. ref-code-block:: cpp
   
   	:ref:`warpAffine <doxid-d5/df1/group__imgproc__hal__functions_1ga8a534cca6fb845c9ac77f10c35f67c0c>`( warp_dst, warp_rotate_dst, rot_mat, warp_dst.size() );

#. Finally, we display our results in two windows plus the original image for good measure:
   
   .. ref-code-block:: cpp
   
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( source_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( source_window, src );
   	
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( warp_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( warp_window, warp_dst );
   	
   	:ref:`namedWindow <doxid-d7/dfc/group__highgui_1ga5afdf8410934fd099df85c75b2e0888b>`( warp_rotate_window, :ref:`WINDOW_AUTOSIZE <doxid-d7/dfc/group__highgui_1ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f>` );
   	:ref:`imshow <doxid-d7/dfc/group__highgui_1ga453d42fe4cb60e5723281a89973ee563>`( warp_rotate_window, warp_rotate_dst );

#. We just have to wait until the user exits the program
   
   .. ref-code-block:: cpp
   
   	:ref:`waitKey <doxid-d7/dfc/group__highgui_1ga5628525ad33f52eab17feebcfba38bd7>`(0);

.. rubric:: Result

#. After compiling the code above, we can give it the path of an image as argument. For instance, for a picture like:
   
   .. image:: Warp_Affine_Tutorial_Original_Image.jpg
   
   after applying the first Affine Transform we obtain:
   
   .. image:: Warp_Affine_Tutorial_Result_Warp.jpg
   
   and finally, after applying a negative rotation (remember negative means clockwise) and a scale factor, we get:
   
   .. image:: Warp_Affine_Tutorial_Result_Warp_Rotate.jpg

