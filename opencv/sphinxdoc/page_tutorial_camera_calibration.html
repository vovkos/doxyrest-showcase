
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Camera calibration With OpenCV &#8212; OpenCV Documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-sphinxdoc.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/target-highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Camera calibration with square chessboard" href="page_tutorial_camera_calibration_square_chess.html" />
    <link rel="prev" title="Camera calibration and 3D reconstruction (calib3d module)" href="page_tutorial_table_of_content_calib3d.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="page_tutorial_camera_calibration_square_chess.html" title="Camera calibration with square chessboard"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="page_tutorial_table_of_content_calib3d.html" title="Camera calibration and 3D reconstruction (calib3d module)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenCV Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="page_tutorial_root.html" >OpenCV Tutorials</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="page_tutorial_table_of_content_calib3d.html" accesskey="U">Camera calibration and 3D reconstruction (calib3d module)</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="page_tutorial_table_of_content_calib3d.html"
                        title="previous chapter">Camera calibration and 3D reconstruction (calib3d module)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="page_tutorial_camera_calibration_square_chess.html"
                        title="next chapter">Camera calibration with square chessboard</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="camera-calibration-with-opencv">
<span id="doxid-d4-d94-tutorial-camera-calibration"></span><span id="index-0"></span><h1>Camera calibration With OpenCV</h1>
<p>Cameras have been around for a long-long time. However, with the introduction of the cheap <em>pinhole</em> cameras in the late 20th century, they became a common occurrence in our everyday life. Unfortunately, this cheapness comes with its price: significant distortion. Luckily, these are constants and with a calibration and some remapping we can correct this. Furthermore, with calibration you may also determine the relation between the camera’s natural units (pixels) and the real world units (for example millimeters).</p>
<p class="rubric">Theory</p>
<p>For the distortion OpenCV takes into account the radial and tangential factors. For the radial factor one uses the following formula:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \\ y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)\end{split}\]</div>
<p>So for an undistorted pixel point at <span class="math notranslate nohighlight">\((x,y)\)</span> coordinates, its position on the distorted image will be <span class="math notranslate nohighlight">\((x_{distorted} y_{distorted})\)</span>. The presence of the radial distortion manifests in form of the “barrel” or “fish-eye” effect.</p>
<p>Tangential distortion occurs because the image taking lenses are not perfectly parallel to the imaging plane. It can be represented via the formulas:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x_{distorted} = x + [ 2p_1xy + p_2(r^2+2x^2)] \\ y_{distorted} = y + [ p_1(r^2+ 2y^2)+ 2p_2xy]\end{split}\]</div>
<p>So we have five distortion parameters which in OpenCV are presented as one row matrix with 5 columns:</p>
<div class="math notranslate nohighlight">
\[distortion\_coefficients=(k_1 \hspace{10pt} k_2 \hspace{10pt} p_1 \hspace{10pt} p_2 \hspace{10pt} k_3)\]</div>
<p>Now for the unit conversion we use the following formula:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left [ \begin{matrix} x \\ y \\ w \end{matrix} \right ] = \left [ \begin{matrix} f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{matrix} \right ] \left [ \begin{matrix} X \\ Y \\ Z \end{matrix} \right ]\end{split}\]</div>
<p>Here the presence of <span class="math notranslate nohighlight">\(w\)</span> is explained by the use of homography coordinate system (and <span class="math notranslate nohighlight">\(w=Z\)</span>). The unknown parameters are <span class="math notranslate nohighlight">\(f_x\)</span> and <span class="math notranslate nohighlight">\(f_y\)</span> (camera focal lengths) and <span class="math notranslate nohighlight">\((c_x, c_y)\)</span> which are the optical centers expressed in pixels coordinates. If for both axes a common focal length is used with a given <span class="math notranslate nohighlight">\(a\)</span> aspect ratio (usually 1), then <span class="math notranslate nohighlight">\(f_y=f_x*a\)</span> and in the upper formula we will have a single focal length <span class="math notranslate nohighlight">\(f\)</span>. The matrix containing these four parameters is referred to as the <em>camera matrix</em>. While the distortion coefficients are the same regardless of the camera resolutions used, these should be scaled along with the current resolution from the calibrated resolution.</p>
<p>The process of determining these two matrices is the calibration. Calculation of these parameters is done through basic geometrical equations. The equations used depend on the chosen calibrating objects. Currently OpenCV supports three types of objects for calibration:</p>
<ul class="simple">
<li>Classical black-white chessboard</li>
<li>Symmetrical circle pattern</li>
<li>Asymmetrical circle pattern</li>
</ul>
<p>Basically, you need to take snapshots of these patterns with your camera and let OpenCV find them. Each found pattern results in a new equation. To solve the equation you need at least a predetermined number of pattern snapshots to form a well-posed equation system. This number is higher for the chessboard pattern and less for the circle ones. For example, in theory the chessboard pattern requires at least two snapshots. However, in practice we have a good amount of noise present in our input images, so for good results you will probably need at least 10 good snapshots of the input pattern in different positions.</p>
<p class="rubric">Goal</p>
<p>The sample application will:</p>
<ul class="simple">
<li>Determine the distortion matrix</li>
<li>Determine the camera matrix</li>
<li>Take input from Camera, Video and Image file list</li>
<li>Read configuration from XML/YAML file</li>
<li>Save the results into XML/YAML file</li>
<li>Calculate re-projection error</li>
</ul>
<p class="rubric">Source code</p>
<p>You may also find the source code in the <code class="docutils literal notranslate"><span class="pre">samples/cpp/tutorial_code/calib3d/camera_calibration/</span></code> folder of the OpenCV source library or <a class="reference external" href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp">download it from here</a>. The program has a single argument: the name of its configuration file. If none is given then it will try to open the one named “default.xml”. <a class="reference external" href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/calib3d/camera_calibration/in_VID5.xml">Here’s a sample configuration file</a> in XML format. In the configuration file you may choose to use camera as an input, a video file or an image list. If you opt for the last one, you will need to create a configuration file where you enumerate the images to use. Here’s <a class="reference external" href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/calib3d/camera_calibration/VID5.xml">an example of this</a>. The important part to remember is that the images need to be specified using the absolute path or the relative one from your application’s working directory. You may find all this in the samples directory mentioned above.</p>
<p>The application starts up with reading the settings from the configuration file. Although, this is an important part of it, it has nothing to do with the subject of this tutorial: <em>camera calibration</em>. Therefore, I’ve chosen not to post the code for that part here. Technical background on how to do this you can find in the <a class="reference internal" href="page_tutorial_file_input_output_with_xml_yml.html#doxid-dd-d74-tutorial-file-input-output-with-xml-yml"><span class="std std-ref">File Input and Output using XML and YAML files</span></a> tutorial.</p>
<p class="rubric">Explanation</p>
<ol class="arabic">
<li><p class="first"><strong>Read the settings</strong></p>
<pre class="highlight literal-block">
<span></span><span class="n">Settings</span> <span class="n">s</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="n">inputSettingsFile</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="s">&quot;default.xml&quot;</span><span class="p">;</span>
<span class="n">FileStorage</span> <span class="nf">fs</span><span class="p">(</span><span class="n">inputSettingsFile</span><span class="p">,</span> <span class="n">FileStorage</span><span class="o">::</span><span class="n">READ</span><span class="p">);</span> <span class="c1">// Read the settings</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fs</span><span class="p">.</span><span class="n">isOpened</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Could not open the configuration file: </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">inputSettingsFile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fs</span><span class="p">[</span><span class="s">&quot;Settings&quot;</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>                                         <span class="c1">// close Settings file</span>
</pre>
<p>For this I’ve used simple OpenCV class input operation. After reading the file I’ve an additional post-processing function that checks validity of the input. Only if all inputs are good then <em>goodInput</em> variable will be true.</p>
</li>
<li><p class="first"><strong>Get next input, if it fails or we have enough of them - calibrate</strong></p>
<p>After this we have a big loop where we do the following operations: get the next image from the image list, camera or video file. If this fails or we have enough images then we run the calibration process. In case of image we step out of the loop and otherwise the remaining frames will be undistorted (if the option is set) via changing from <em>DETECTION</em> mode to the <em>CALIBRATED</em> one.</p>
<pre class="highlight literal-block">
<span></span><span class="k">for</span><span class="p">(;;)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">view</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">blinkOutput</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">view</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">nextImage</span><span class="p">();</span>

    <span class="c1">//-----  If no more image, or got enough, then stop calibration and show result -------------</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">CAPTURING</span> <span class="o">&amp;&amp;</span> <span class="n">imagePoints</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="p">(</span><a class="reference internal" href="global.html#doxid-da-d06-autogenerated-2opencl-core-8hpp-1a6ff403ead16f7faa1f7228274eb6b01d"><span class="std std-ref">size_t</span></a><span></span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">nrFrames</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">runCalibrationAndSave</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span>  <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">imagePoints</span><span class="p">))</span>
          <span class="n">mode</span> <span class="o">=</span> <span class="n">CALIBRATED</span><span class="p">;</span>
      <span class="k">else</span>
          <span class="n">mode</span> <span class="o">=</span> <span class="n">DETECTION</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>          <span class="c1">// If there are no more images stop the loop</span>
    <span class="p">{</span>
        <span class="c1">// if calibration threshold was not reached yet, calibrate now</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">CALIBRATED</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">imagePoints</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">runCalibrationAndSave</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span>  <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">imagePoints</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</pre>
<p>For some cameras we may need to flip the input image. Here we do this too.</p>
</li>
<li><p class="first"><strong>Find the pattern in the current input</strong></p>
<p>The formation of the equations I mentioned above aims to finding major patterns in the input: in case of the chessboard this are corners of the squares and for the circles, well, the circles themselves. The position of these will form the result which will be written into the <em>pointBuf</em> vector.</p>
<pre class="highlight literal-block">
<span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">pointBuf</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">found</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">chessBoardFlags</span> <span class="o">=</span> <a class="reference internal" href="namespace_cv.html#doxid-d9-d0c-group-calib3d-1gga80a507de0875ee8ac3028ee60071f64ba9e296b20df217b62e581c56ad9359db5"><span class="std std-ref">CALIB_CB_ADAPTIVE_THRESH</span></a><span></span> <span class="o">|</span> <a class="reference internal" href="namespace_cv.html#doxid-d9-d0c-group-calib3d-1gga80a507de0875ee8ac3028ee60071f64baf54c37b53d4375f95e9b1a3d9846c97a"><span class="std std-ref">CALIB_CB_NORMALIZE_IMAGE</span></a><span></span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">useFisheye</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// fast check erroneously fails with high distortions like fisheye</span>
    <span class="n">chessBoardFlags</span> <span class="o">|=</span> <a class="reference internal" href="namespace_cv.html#doxid-d9-d0c-group-calib3d-1gga80a507de0875ee8ac3028ee60071f64ba5b5ef5178c5c5d50cc15719aecc5fd25"><span class="std std-ref">CALIB_CB_FAST_CHECK</span></a><span></span><span class="p">;</span>
<span class="p">}</span>

<span class="k">switch</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">calibrationPattern</span> <span class="p">)</span> <span class="c1">// Find feature points on the input format</span>
<span class="p">{</span>
<span class="k">case</span> <span class="n">Settings</span><span class="o">::</span><span class="nl">CHESSBOARD</span><span class="p">:</span>
    <span class="n">found</span> <span class="o">=</span> <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga93efa9b0aa890de240ca32b11253dd4a"><span class="std std-ref">findChessboardCorners</span></a><span></span><span class="p">(</span> <span class="n">view</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">boardSize</span><span class="p">,</span> <span class="n">pointBuf</span><span class="p">,</span> <span class="n">chessBoardFlags</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">Settings</span><span class="o">::</span><span class="nl">CIRCLES_GRID</span><span class="p">:</span>
    <span class="n">found</span> <span class="o">=</span> <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1gad1205c4b803a21597c7d6035f5efd775"><span class="std std-ref">findCirclesGrid</span></a><span></span><span class="p">(</span> <span class="n">view</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">boardSize</span><span class="p">,</span> <span class="n">pointBuf</span> <span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">Settings</span><span class="o">::</span><span class="nl">ASYMMETRIC_CIRCLES_GRID</span><span class="p">:</span>
    <span class="n">found</span> <span class="o">=</span> <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1gad1205c4b803a21597c7d6035f5efd775"><span class="std std-ref">findCirclesGrid</span></a><span></span><span class="p">(</span> <span class="n">view</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">boardSize</span><span class="p">,</span> <span class="n">pointBuf</span><span class="p">,</span> <a class="reference internal" href="namespace_cv.html#doxid-d9-d0c-group-calib3d-1gga7041b2a9c8f9f8ee93a2796981bc5546a2ef9eceaffccf6a70aea8cd9006bd235"><span class="std std-ref">CALIB_CB_ASYMMETRIC_GRID</span></a><span></span> <span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">default</span><span class="o">:</span>
    <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Depending on the type of the input pattern you use either the <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga93efa9b0aa890de240ca32b11253dd4a"><span class="std std-ref">cv::findChessboardCorners</span></a> or the <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1gad1205c4b803a21597c7d6035f5efd775"><span class="std std-ref">cv::findCirclesGrid</span></a> function. For both of them you pass the current image and the size of the board and you’ll get the positions of the patterns. Furthermore, they return a boolean variable which states if the pattern was found in the input (we only need to take into account those images where this is true!).</p>
<p>Then again in case of cameras we only take camera images when an input delay time is passed. This is done in order to allow user moving the chessboard around and getting different images. Similar images result in similar equations, and similar equations at the calibration step will form an ill-posed problem, so the calibration will fail. For square images the positions of the corners are only approximate. We may improve this by calling the <a class="reference internal" href="group_imgproc_feature.html#doxid-dd-d1a-group-imgproc-feature-1ga354e0d7c86d0d9da75de9b9701a9a87e"><span class="std std-ref">cv::cornerSubPix</span></a> function. It will produce better calibration result. After this we add a valid inputs result to the <em>imagePoints</em> vector to collect all of the equations into a single container. Finally, for visualization feedback purposes we will draw the found points on the input image using <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga93efa9b0aa890de240ca32b11253dd4a"><span class="std std-ref">cv::findChessboardCorners</span></a> function.</p>
<pre class="highlight literal-block">
<span></span><span class="k">if</span> <span class="p">(</span> <span class="n">found</span><span class="p">)</span>                <span class="c1">// If done with success,</span>
<span class="p">{</span>
      <span class="c1">// improve the found corners&#39; coordinate accuracy for chessboard</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">calibrationPattern</span> <span class="o">==</span> <span class="n">Settings</span><span class="o">::</span><span class="n">CHESSBOARD</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Mat</span> <span class="n">viewGray</span><span class="p">;</span>
            <a class="reference internal" href="group_imgproc_misc.html#doxid-d7-d1b-group-imgproc-misc-1ga397ae87e1288a81d2363b61574eb8cab"><span class="std std-ref">cvtColor</span></a><span></span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">viewGray</span><span class="p">,</span> <a class="reference internal" href="enum_cv_ColorConversionCodes.html#doxid-d7-d1b-group-imgproc-misc-1gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><span class="std std-ref">COLOR_BGR2GRAY</span></a><span></span><span class="p">);</span>
            <a class="reference internal" href="group_imgproc_feature.html#doxid-dd-d1a-group-imgproc-feature-1ga354e0d7c86d0d9da75de9b9701a9a87e"><span class="std std-ref">cornerSubPix</span></a><span></span><span class="p">(</span> <span class="n">viewGray</span><span class="p">,</span> <span class="n">pointBuf</span><span class="p">,</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span>
                <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga346f563897249351a34549137c8532a0"><span class="std std-ref">Size</span></a><span></span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">TermCriteria</span><span class="p">(</span> <span class="n">TermCriteria</span><span class="o">::</span><span class="n">EPS</span><span class="o">+</span><span class="n">TermCriteria</span><span class="o">::</span><span class="n">COUNT</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">0.1</span> <span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">CAPTURING</span> <span class="o">&amp;&amp;</span>  <span class="c1">// For camera only take new samples after delay time</span>
            <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">inputCapture</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()</span> <span class="o">||</span> <span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">prevTimestamp</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">delay</span><span class="o">*</span><span class="mf">1e-3</span><span class="o">*</span><span class="n">CLOCKS_PER_SEC</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">imagePoints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pointBuf</span><span class="p">);</span>
            <span class="n">prevTimestamp</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="n">blinkOutput</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">inputCapture</span><span class="p">.</span><span class="n">isOpened</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// Draw the corners.</span>
        <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga6a10b0bb120c4907e5eabbcd22319022"><span class="std std-ref">drawChessboardCorners</span></a><span></span><span class="p">(</span> <span class="n">view</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">boardSize</span><span class="p">,</span> <span class="n">Mat</span><span class="p">(</span><span class="n">pointBuf</span><span class="p">),</span> <span class="n">found</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
</li>
<li><p class="first"><strong>Show state and result to the user, plus command line control of the application</strong></p>
<p>This part shows text output on the image.</p>
<pre class="highlight literal-block">
<span></span><span class="n">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CAPTURING</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;100/100&quot;</span> <span class="o">:</span>
              <span class="n">mode</span> <span class="o">==</span> <span class="n">CALIBRATED</span> <span class="o">?</span> <span class="s">&quot;Calibrated&quot;</span> <span class="o">:</span> <span class="s">&quot;Press &#39;g&#39; to start&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">baseLine</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Size</span> <span class="n">textSize</span> <span class="o">=</span> <a class="reference internal" href="group_imgproc_draw.html#doxid-d6-d6e-group-imgproc-draw-1ga3d2abfcb995fd2db908c8288199dba82"><span class="std std-ref">getTextSize</span></a><span></span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baseLine</span><span class="p">);</span>
<span class="n">Point</span> <span class="nf">textOrigin</span><span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">textSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">baseLine</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">CAPTURING</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">showUndistorsed</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <a class="reference internal" href="group_core_utils.html#doxid-db-de0-group-core-utils-1ga0cccdb2f73859309b0611cf70b1b9409"><span class="std std-ref">format</span></a><span></span><span class="p">(</span> <span class="s">&quot;%d/%d Undist&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">imagePoints</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">nrFrames</span> <span class="p">);</span>
    <span class="k">else</span>
        <span class="n">msg</span> <span class="o">=</span> <a class="reference internal" href="group_core_utils.html#doxid-db-de0-group-core-utils-1ga0cccdb2f73859309b0611cf70b1b9409"><span class="std std-ref">format</span></a><span></span><span class="p">(</span> <span class="s">&quot;%d/%d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">imagePoints</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">nrFrames</span> <span class="p">);</span>
<span class="p">}</span>

<a class="reference internal" href="group_imgproc_draw.html#doxid-d6-d6e-group-imgproc-draw-1ga5126f47f883d730f633d74f07456c576"><span class="std std-ref">putText</span></a><span></span><span class="p">(</span> <span class="n">view</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">textOrigin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">CALIBRATED</span> <span class="o">?</span>  <span class="nl">GREEN</span> <span class="p">:</span> <span class="n">RED</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">blinkOutput</span> <span class="p">)</span>
    <a class="reference internal" href="group_core_array.html#doxid-d2-de8-group-core-array-1ga0002cf8b418479f4cb49a75442baee2f"><span class="std std-ref">bitwise_not</span></a><span></span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">view</span><span class="p">);</span>
</pre>
<p>If we ran calibration and got camera’s matrix with the distortion coefficients we may want to correct the image using <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga69f2545a8b62a6b0fc2ee060dc30559d"><span class="std std-ref">cv::undistort</span></a> function:</p>
<pre class="highlight literal-block">
<span></span><span class="k">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">CALIBRATED</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">showUndistorsed</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">useFisheye</span><span class="p">)</span>
      <a class="reference internal" href="group_calib3d_fisheye.html#doxid-db-d58-group-calib3d-fisheye-1ga167df4b00a6fd55287ba829fbf9913b9"><span class="std std-ref">cv::fisheye::undistortImage</span></a><span></span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">);</span>
    <span class="k">else</span>
      <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga69f2545a8b62a6b0fc2ee060dc30559d"><span class="std std-ref">undistort</span></a><span></span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Then we show the image and wait for an input key and if this is <em>u</em> we toggle the distortion removal, if it is <em>g</em> we start again the detection process, and finally for the <em>ESC</em> key we quit the application:</p>
<pre class="highlight literal-block">
<a class="reference internal" href="group_highgui.html#doxid-d7-dfc-group-highgui-1ga453d42fe4cb60e5723281a89973ee563"><span class="std std-ref">imshow</span></a><span></span><span class="p">(</span><span class="s">&quot;Image View&quot;</span><span class="p">,</span> <span class="n">view</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><a class="reference internal" href="group_highgui.html#doxid-d7-dfc-group-highgui-1ga5628525ad33f52eab17feebcfba38bd7"><span class="std std-ref">waitKey</span></a><span></span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">inputCapture</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()</span> <span class="o">?</span> <span class="mi">50</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">delay</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">key</span>  <span class="o">==</span> <span class="n">ESC_KEY</span> <span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="n">key</span> <span class="o">==</span> <span class="sc">&#39;u&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">CALIBRATED</span> <span class="p">)</span>
   <span class="n">s</span><span class="p">.</span><span class="n">showUndistorsed</span> <span class="o">=</span> <span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">showUndistorsed</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">inputCapture</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">==</span> <span class="sc">&#39;g&#39;</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">CAPTURING</span><span class="p">;</span>
    <span class="n">imagePoints</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>
</pre>
</li>
<li><p class="first"><strong>Show the distortion removal for the images too</strong></p>
<p>When you work with an image list it is not possible to remove the distortion inside the loop. Therefore, you must do this after the loop. Taking advantage of this now I’ll expand the <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga69f2545a8b62a6b0fc2ee060dc30559d"><span class="std std-ref">cv::undistort</span></a> function, which is in fact first calls <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga7dfb72c9cf9780a347fbe3d1c47e5d5a"><span class="std std-ref">cv::initUndistortRectifyMap</span></a> to find transformation matrices and then performs transformation using <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1gab75ef31ce5cdfb5c44b6da5f3b908ea4"><span class="std std-ref">cv::remap</span></a> function. Because, after successful calibration map calculation needs to be done only once, by using this expanded form you may speed up your application:</p>
<pre class="highlight literal-block">
<span></span><span class="k">if</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">inputType</span> <span class="o">==</span> <span class="n">Settings</span><span class="o">::</span><span class="n">IMAGE_LIST</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">showUndistorsed</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">view</span><span class="p">,</span> <span class="n">rview</span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">useFisheye</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Mat</span> <span class="n">newCamMat</span><span class="p">;</span>
        <a class="reference internal" href="group_calib3d_fisheye.html#doxid-db-d58-group-calib3d-fisheye-1ga384940fdf04c03e362e94b6eb9b673c9"><span class="std std-ref">fisheye::estimateNewCameraMatrixForUndistortRectify</span></a><span></span><span class="p">(</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span>
                                                            <span class="n">Matx33d</span><span class="o">::</span><span class="n">eye</span><span class="p">(),</span> <span class="n">newCamMat</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga7dfb72c9cf9780a347fbe3d1c47e5d5a"><span class="std std-ref">fisheye::initUndistortRectifyMap</span></a><span></span><span class="p">(</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">Matx33d</span><span class="o">::</span><span class="n">eye</span><span class="p">(),</span> <span class="n">newCamMat</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span>
                                         <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga50ed0965d0ae7fcd8ee04ec170551ce1"><span class="std std-ref">CV_16SC2</span></a><span></span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga7dfb72c9cf9780a347fbe3d1c47e5d5a"><span class="std std-ref">initUndistortRectifyMap</span></a><span></span><span class="p">(</span>
            <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">Mat</span><span class="p">(),</span>
            <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga7a6c4e032c97f03ba747966e6ad862b1"><span class="std std-ref">getOptimalNewCameraMatrix</span></a><span></span><span class="p">(</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">imageSize</span><span class="p">,</span>
            <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga50ed0965d0ae7fcd8ee04ec170551ce1"><span class="std std-ref">CV_16SC2</span></a><span></span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">imageList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">view</span> <span class="o">=</span> <a class="reference internal" href="group_imgcodecs.html#doxid-d4-da8-group-imgcodecs-1ga288b8b3da0892bd651fce07b3bbd3a56"><span class="std std-ref">imread</span></a><span></span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">imageList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <a class="reference internal" href="enum_cv_ImreadModes.html#doxid-d4-da8-group-imgcodecs-1gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822"><span class="std std-ref">IMREAD_COLOR</span></a><span></span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="k">continue</span><span class="p">;</span>
        <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1gab75ef31ce5cdfb5c44b6da5f3b908ea4"><span class="std std-ref">remap</span></a><span></span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">rview</span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <a class="reference internal" href="enum_cv_InterpolationFlags.html#doxid-da-d54-group-imgproc-transform-1gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb"><span class="std std-ref">INTER_LINEAR</span></a><span></span><span class="p">);</span>
        <a class="reference internal" href="group_highgui.html#doxid-d7-dfc-group-highgui-1ga453d42fe4cb60e5723281a89973ee563"><span class="std std-ref">imshow</span></a><span></span><span class="p">(</span><span class="s">&quot;Image View&quot;</span><span class="p">,</span> <span class="n">rview</span><span class="p">);</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><a class="reference internal" href="group_highgui.html#doxid-d7-dfc-group-highgui-1ga5628525ad33f52eab17feebcfba38bd7"><span class="std std-ref">waitKey</span></a><span></span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">c</span>  <span class="o">==</span> <span class="n">ESC_KEY</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;q&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;Q&#39;</span> <span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<p class="rubric">The calibration and save</p>
</li>
</ol>
<p>Because the calibration needs to be done only once per camera, it makes sense to save it after a successful calibration. This way later on you can just load these values into your program. Due to this we first make the calibration, and if it succeeds we save the result into an OpenCV style XML or YAML file, depending on the extension you give in the configuration file.</p>
<p>Therefore in the first function we just split up these two processes. Because we want to save many of the calibration variables we’ll create these variables here and pass on both of them to the calibration and saving function. Again, I’ll not show the saving part as that has little in common with the calibration. Explore the source file in order to find out how and what:</p>
<pre class="highlight literal-block">
<span></span><span class="kt">bool</span> <span class="nf">runCalibrationAndSave</span><span class="p">(</span><span class="n">Settings</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">Size</span> <span class="n">imageSize</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">distCoeffs</span><span class="p">,</span>
                           <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">imagePoints</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">reprojErrs</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">totalAvgErr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">runCalibration</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">imagePoints</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">,</span> <span class="n">reprojErrs</span><span class="p">,</span>
                             <span class="n">totalAvgErr</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ok</span> <span class="o">?</span> <span class="s">&quot;Calibration succeeded&quot;</span> <span class="o">:</span> <span class="s">&quot;Calibration failed&quot;</span><span class="p">)</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;. avg re projection error = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">totalAvgErr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">)</span>
        <span class="n">saveCameraParams</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">,</span> <span class="n">reprojErrs</span><span class="p">,</span> <span class="n">imagePoints</span><span class="p">,</span>
                         <span class="n">totalAvgErr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>We do the calibration with the help of the <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga3207604e4b1a1758aa66acb6ed5aa65d"><span class="std std-ref">cv::calibrateCamera</span></a> function. It has the following parameters:</p>
<ul>
<li><p class="first">The object points. This is a vector of <em>Point3f</em> vector that for each input image describes how should the pattern look. If we have a planar pattern (like a chessboard) then we can simply set all Z coordinates to zero. This is a collection of the points where these important points are present. Because, we use a single pattern for all the input images we can calculate this just once and multiply it for all the other input views. We calculate the corner points with the <em>calcBoardCornerPositions</em> function as:</p>
<pre class="highlight literal-block">
<span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">calcBoardCornerPositions</span><span class="p">(</span><span class="n">Size</span> <span class="n">boardSize</span><span class="p">,</span> <span class="kt">float</span> <span class="n">squareSize</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3f</span><span class="o">&gt;&amp;</span> <span class="n">corners</span><span class="p">,</span>
                                     <span class="n">Settings</span><span class="o">::</span><span class="n">Pattern</span> <span class="n">patternType</span> <span class="cm">/*= Settings::CHESSBOARD*/</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">corners</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">patternType</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">Settings</span><span class="o">::</span><span class="nl">CHESSBOARD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Settings</span><span class="o">::</span><span class="nl">CIRCLES_GRID</span><span class="p">:</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">boardSize</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">boardSize</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span>
                <span class="n">corners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point3f</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">squareSize</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">squareSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">Settings</span><span class="o">::</span><span class="nl">ASYMMETRIC_CIRCLES_GRID</span><span class="p">:</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">boardSize</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">boardSize</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
                <span class="n">corners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point3f</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">squareSize</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">squareSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>And then multiply it as:</p>
<pre class="highlight literal-block">
<span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3f</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">objectPoints</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">calcBoardCornerPositions</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">boardSize</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">squareSize</span><span class="p">,</span> <span class="n">objectPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">.</span><span class="n">calibrationPattern</span><span class="p">);</span>
<span class="n">objectPoints</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">imagePoints</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">objectPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre>
</li>
<li><p class="first">The image points. This is a vector of <em>Point2f</em> vector which for each input image contains coordinates of the important points (corners for chessboard and centers of the circles for the circle pattern). We have already collected this from <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga93efa9b0aa890de240ca32b11253dd4a"><span class="std std-ref">cv::findChessboardCorners</span></a> or <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1gad1205c4b803a21597c7d6035f5efd775"><span class="std std-ref">cv::findCirclesGrid</span></a> function. We just need to pass it on.</p>
</li>
<li><p class="first">The size of the image acquired from the camera, video file or the images.</p>
</li>
<li><p class="first">The camera matrix. If we used the fixed aspect ratio option we need to set <span class="math notranslate nohighlight">\(f_x\)</span> :</p>
<pre class="highlight literal-block">
<span></span><span class="n">cameraMatrix</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga30a562691cc5987bc88eb7bb7a8faf2b"><span class="std std-ref">CV_64F</span></a><span></span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <a class="reference internal" href="namespace_cv.html#doxid-d9-d0c-group-calib3d-1gga46db002545a3b6c1904b7a0a8694b66aa131c3576ad5c96991adea3a133b6ce65"><span class="std std-ref">CALIB_FIX_ASPECT_RATIO</span></a><span></span> <span class="p">)</span>
    <span class="n">cameraMatrix</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">aspectRatio</span><span class="p">;</span>
</pre>
</li>
<li><p class="first">The distortion coefficient matrix. Initialize with zero.</p>
<pre class="highlight literal-block">
<span></span><span class="n">distCoeffs</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <a class="reference internal" href="group_core_hal_interface.html#doxid-d1-d1b-group-core-hal-interface-1ga30a562691cc5987bc88eb7bb7a8faf2b"><span class="std std-ref">CV_64F</span></a><span></span><span class="p">);</span>
</pre>
</li>
<li><p class="first">For all the views the function will calculate rotation and translation vectors which transform the object points (given in the model coordinate space) to the image points (given in the world coordinate space). The 7-th and 8-th parameters are the output vector of matrices containing in the i-th position the rotation and translation vector for the i-th object point to the i-th image point.</p>
</li>
<li><p class="first">The final argument is the flag. You need to specify here options like fix the aspect ratio for the focal length, assume zero tangential distortion or to fix the principal point.</p>
<pre class="highlight literal-block">
<span></span><span class="kt">double</span> <span class="n">rms</span> <span class="o">=</span> <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga3207604e4b1a1758aa66acb6ed5aa65d"><span class="std std-ref">calibrateCamera</span></a><span></span><span class="p">(</span><span class="n">objectPoints</span><span class="p">,</span> <span class="n">imagePoints</span><span class="p">,</span> <span class="n">imageSize</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="p">,</span>
                            <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">flag</span><span class="o">|</span><a class="reference internal" href="group_calib3d_c.html#doxid-d5-db8-group-calib3d-c-1ga39d224b0ce447b4f3dd360a2d9aae906"><span class="std std-ref">CV_CALIB_FIX_K4</span></a><span></span><span class="o">|</span><a class="reference internal" href="group_calib3d_c.html#doxid-d5-db8-group-calib3d-c-1gaca023f78c814739894b85446847df06a"><span class="std std-ref">CV_CALIB_FIX_K5</span></a><span></span><span class="p">);</span>
</pre>
</li>
<li><p class="first">The function returns the average re-projection error. This number gives a good estimation of precision of the found parameters. This should be as close to zero as possible. Given the intrinsic, distortion, rotation and translation matrices we may calculate the error for one view by using the <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga1019495a2c8d1743ed5cc23fa0daff8c"><span class="std std-ref">cv::projectPoints</span></a> to first transform the object point to image point. Then we calculate the absolute norm between what we got with our transformation and the corner/circle finding algorithm. To find the average error we calculate the arithmetical mean of the errors calculated for all the calibration images.</p>
<pre class="highlight literal-block">
<span></span><span class="k">static</span> <span class="kt">double</span> <span class="nf">computeReprojectionErrors</span><span class="p">(</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3f</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">objectPoints</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">imagePoints</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&amp;</span> <span class="n">rvecs</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&amp;</span> <span class="n">tvecs</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">cameraMatrix</span> <span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">distCoeffs</span><span class="p">,</span>
                                         <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">perViewErrors</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">fisheye</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">imagePoints2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">totalPoints</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">totalErr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">perViewErrors</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">objectPoints</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objectPoints</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fisheye</span><span class="p">)</span>
        <span class="p">{</span>
            <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga1019495a2c8d1743ed5cc23fa0daff8c"><span class="std std-ref">fisheye::projectPoints</span></a><span></span><span class="p">(</span><span class="n">objectPoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">imagePoints2</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cameraMatrix</span><span class="p">,</span>
                                   <span class="n">distCoeffs</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <a class="reference internal" href="group_calib3d.html#doxid-d9-d0c-group-calib3d-1ga1019495a2c8d1743ed5cc23fa0daff8c"><span class="std std-ref">projectPoints</span></a><span></span><span class="p">(</span><span class="n">objectPoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tvecs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">imagePoints2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">err</span> <span class="o">=</span> <a class="reference internal" href="namespace_cv.html#doxid-dc-d84-group-core-basic-1ga4e556cb8ad35a643a1ea66e035711bb9"><span class="std std-ref">norm</span></a><span></span><span class="p">(</span><span class="n">imagePoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">imagePoints2</span><span class="p">,</span> <a class="reference internal" href="enum_cv_NormTypes.html#doxid-d2-de8-group-core-array-1ggad12cefbcb5291cf958a85b4b67b6149fa7bacbe84d400336a8f26297d8e80e3a2"><span class="std std-ref">NORM_L2</span></a><span></span><span class="p">);</span>

        <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">objectPoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="n">perViewErrors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <a class="reference internal" href="namespace_cv.html#doxid-d2-d75-namespacecv-1a682082a1892db64a2856403ec17ba297"><span class="std std-ref">std::sqrt</span></a><span></span><span class="p">(</span><span class="n">err</span><span class="o">*</span><span class="n">err</span><span class="o">/</span><span class="n">n</span><span class="p">);</span>
        <span class="n">totalErr</span>        <span class="o">+=</span> <span class="n">err</span><span class="o">*</span><span class="n">err</span><span class="p">;</span>
        <span class="n">totalPoints</span>     <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <a class="reference internal" href="namespace_cv.html#doxid-d2-d75-namespacecv-1a682082a1892db64a2856403ec17ba297"><span class="std std-ref">std::sqrt</span></a><span></span><span class="p">(</span><span class="n">totalErr</span><span class="o">/</span><span class="n">totalPoints</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p class="rubric">Results</p>
</li>
</ul>
<p>Let there be <a class="reference external" href="pattern.png">this input chessboard pattern</a> which has a size of 9 X 6. I’ve used an AXIS IP camera to create a couple of snapshots of the board and saved it into VID5 directory. I’ve put this inside the <code class="docutils literal notranslate"><span class="pre">images/CameraCalibration</span></code> folder of my working directory and created the following <code class="docutils literal notranslate"><span class="pre">VID5.XML</span></code> file that describes which images to use:</p>
<pre class="highlight literal-block">
<span></span><span class="o">&lt;?</span><span class="n">xml</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="o">?&gt;</span>
<span class="o">&lt;</span><span class="n">opencv_storage</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">images</span><span class="o">&gt;</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx1</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx2</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx3</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx4</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx5</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx6</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx7</span><span class="p">.</span><span class="n">jpg</span>
<span class="n">images</span><span class="o">/</span><span class="n">CameraCalibration</span><span class="o">/</span><span class="n">VID5</span><span class="o">/</span><span class="n">xx8</span><span class="p">.</span><span class="n">jpg</span>
<span class="o">&lt;/</span><span class="n">images</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">opencv_storage</span><span class="o">&gt;</span>
</pre>
<p>Then passed <code class="docutils literal notranslate"><span class="pre">images/CameraCalibration/VID5/VID5.XML</span></code> as an input in the configuration file. Here’s a chessboard pattern found during the runtime of the application:</p>
<img alt="_images/fileListImage.jpg" src="_images/fileListImage.jpg" />
<p>After applying the distortion removal we get:</p>
<img alt="_images/fileListImageUnDist.jpg" src="_images/fileListImageUnDist.jpg" />
<p>The same works for <a class="reference external" href="acircles_pattern.png">this asymmetrical circle pattern</a> by setting the input width to 4 and height to 11. This time I’ve used a live camera feed by specifying its ID (“1”) for the input. Here’s, how a detected pattern should look:</p>
<img alt="_images/asymetricalPattern.jpg" src="_images/asymetricalPattern.jpg" />
<p>In both cases in the specified output XML/YAML file you’ll find the camera and distortion coefficients matrices:</p>
<pre class="highlight literal-block">
<span></span><span class="o">&lt;</span><span class="n">camera_matrix</span> <span class="n">type_id</span><span class="o">=</span><span class="s">&quot;opencv-matrix&quot;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">rows</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">&lt;/</span><span class="n">rows</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">cols</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">&lt;/</span><span class="n">cols</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">d</span><span class="o">&lt;/</span><span class="n">dt</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">data</span><span class="o">&gt;</span>
 <span class="mf">6.5746697944293521e+002</span> <span class="mf">0.</span> <span class="mf">3.1950000000000000e+002</span> <span class="mf">0.</span>
 <span class="mf">6.5746697944293521e+002</span> <span class="mf">2.3950000000000000e+002</span> <span class="mf">0.</span> <span class="mf">0.</span> <span class="mf">1.</span><span class="o">&lt;/</span><span class="n">data</span><span class="o">&gt;&lt;/</span><span class="n">camera_matrix</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">distortion_coefficients</span> <span class="n">type_id</span><span class="o">=</span><span class="s">&quot;opencv-matrix&quot;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">rows</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">rows</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">cols</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">cols</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">d</span><span class="o">&lt;/</span><span class="n">dt</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">data</span><span class="o">&gt;</span>
 <span class="o">-</span><span class="mf">4.1802327176423804e-001</span> <span class="mf">5.0715244063187526e-001</span> <span class="mf">0.</span> <span class="mf">0.</span>
 <span class="o">-</span><span class="mf">5.7843597214487474e-001</span><span class="o">&lt;/</span><span class="n">data</span><span class="o">&gt;&lt;/</span><span class="n">distortion_coefficients</span><span class="o">&gt;</span>
</pre>
<p>Add these values as constants to your program, call the <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1ga7dfb72c9cf9780a347fbe3d1c47e5d5a"><span class="std std-ref">cv::initUndistortRectifyMap</span></a> and the <a class="reference internal" href="group_imgproc_transform.html#doxid-da-d54-group-imgproc-transform-1gab75ef31ce5cdfb5c44b6da5f3b908ea4"><span class="std std-ref">cv::remap</span></a> function to remove distortion and enjoy distortion free inputs for cheap and low quality cameras.</p>
<p>You may observe a runtime instance of this on the <a class="reference external" href="https://www.youtube.com/watch?v=ViPN810E0SU">YouTube here</a>.</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="page_tutorial_camera_calibration_square_chess.html" title="Camera calibration with square chessboard"
             >next</a> |</li>
        <li class="right" >
          <a href="page_tutorial_table_of_content_calib3d.html" title="Camera calibration and 3D reconstruction (calib3d module)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenCV Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="page_tutorial_root.html" >OpenCV Tutorials</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="page_tutorial_table_of_content_calib3d.html" >Camera calibration and 3D reconstruction (calib3d module)</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1999-2017, OpenCV Maintainers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>