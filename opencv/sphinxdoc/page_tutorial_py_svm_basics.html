
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Understanding SVM &#8212; OpenCV Documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-sphinxdoc.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/target-highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Object Detection" href="page_tutorial_py_table_of_contents_objdetect.html" />
    <link rel="prev" title="OCR of Hand-written Data using SVM" href="page_tutorial_py_svm_opencv.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="page_tutorial_py_table_of_contents_objdetect.html" title="Object Detection"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="page_tutorial_py_svm_opencv.html" title="OCR of Hand-written Data using SVM"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenCV Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="page_tutorial_py_root.html" >OpenCV-Python Tutorials</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="page_tutorial_py_table_of_contents_ml.html" >Machine Learning</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="page_tutorial_py_svm_index.html" accesskey="U">Support Vector Machines (SVM)</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="page_tutorial_py_svm_opencv.html"
                        title="previous chapter">OCR of Hand-written Data using SVM</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="page_tutorial_py_table_of_contents_objdetect.html"
                        title="next chapter">Object Detection</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="understanding-svm">
<span id="doxid-d4-db1-tutorial-py-svm-basics"></span><span id="index-0"></span><h1>Understanding SVM</h1>
<p class="rubric">Goal</p>
<p>In this chapter</p>
<ul class="simple">
<li>We will see an intuitive understanding of SVM</li>
</ul>
<p class="rubric">Theory</p>
<p class="rubric">Linearly Separable Data</p>
<p>Consider the image below which has two types of data, red and blue. In kNN, for a test data, we used to measure its distance to all the training samples and take the one with minimum distance. It takes plenty of time to measure all the distances and plenty of memory to store all the training-samples. But considering the data given in image, should we need that much?</p>
<img alt="image" src="_images/svm_basics1.png" />
<p>Consider another idea. We find a line, <span class="math notranslate nohighlight">\(f(x)=ax_1+bx_2+c\)</span> which divides both the data to two regions. When we get a new test_data <span class="math notranslate nohighlight">\(X\)</span>, just substitute it in <span class="math notranslate nohighlight">\(f(x)\)</span>. If <span class="math notranslate nohighlight">\(f(X) &gt; 0\)</span>, it belongs to blue group, else it belongs to red group. We can call this line as <strong>Decision Boundary</strong>. It is very simple and memory-efficient. Such data which can be divided into two with a straight line (or hyperplanes in higher dimensions) is called <strong>Linear Separable</strong>.</p>
<p>So in above image, you can see plenty of such lines are possible. Which one we will take? Very intuitively we can say that the line should be passing as far as possible from all the points. Why? Because there can be noise in the incoming data. This data should not affect the classification accuracy. So taking a farthest line will provide more immunity against noise. So what SVM does is to find a straight line (or hyperplane) with largest minimum distance to the training samples. See the bold line in below image passing through the center.</p>
<img alt="image" src="_images/svm_basics2.png" />
<p>So to find this Decision Boundary, you need training data. Do you need all? NO. Just the ones which are close to the opposite group are sufficient. In our image, they are the one blue filled circle and two red filled squares. We can call them <strong>Support Vectors</strong> and the lines passing through them are called <strong>Support Planes</strong>. They are adequate for finding our decision boundary. We need not worry about all the data. It helps in data reduction.</p>
<p>What happened is, first two hyperplanes are found which best represents the data. For eg, blue data is represented by <span class="math notranslate nohighlight">\(w^Tx+b_0 &gt; 1\)</span> while red data is represented by <span class="math notranslate nohighlight">\(w^Tx+b_0 &lt; -1\)</span> where <span class="math notranslate nohighlight">\(w\)</span> is <strong>weight vector</strong> (<span class="math notranslate nohighlight">\(w=[w_1, w_2,..., w_n]\)</span>) and <span class="math notranslate nohighlight">\(x\)</span> is the feature vector (<span class="math notranslate nohighlight">\(x = [x_1,x_2,..., x_n]\)</span>). <span class="math notranslate nohighlight">\(b_0\)</span> is the <strong>bias</strong>. Weight vector decides the orientation of decision boundary while bias point decides its location. Now decision boundary is defined to be midway between these hyperplanes, so expressed as <span class="math notranslate nohighlight">\(w^Tx+b_0 = 0\)</span>. The minimum distance from support vector to the decision boundary is given by, <span class="math notranslate nohighlight">\(distance_{support \, vectors}=\frac{1}{||w||}\)</span>. Margin is twice this distance, and we need to maximize this margin. i.e. we need to minimize a new function <span class="math notranslate nohighlight">\(L(w, b_0)\)</span> with some constraints which can expressed below:</p>
<div class="math notranslate nohighlight">
\[\min_{w, b_0} L(w, b_0) = \frac{1}{2}||w||^2 \; \text{subject to} \; t_i(w^Tx+b_0) \geq 1 \; \forall i\]</div>
<p>where <span class="math notranslate nohighlight">\(t_i\)</span> is the label of each class, <span class="math notranslate nohighlight">\(t_i \in [-1,1]\)</span>.</p>
<p class="rubric">Non-Linearly Separable Data</p>
<p>Consider some data which can’t be divided into two with a straight line. For example, consider an one-dimensional data where ‘X’ is at -3 &amp; +3 and ‘O’ is at -1 &amp; +1. Clearly it is not linearly separable. But there are methods to solve these kinds of problems. If we can map this data set with a function, <span class="math notranslate nohighlight">\(f(x) = x^2\)</span>, we get ‘X’ at 9 and ‘O’ at 1 which are linear separable.</p>
<p>Otherwise we can convert this one-dimensional to two-dimensional data. We can use <span class="math notranslate nohighlight">\(f(x)=(x,x^2)\)</span> function to map this data. Then ‘X’ becomes (-3,9) and (3,9) while ‘O’ becomes (-1,1) and (1,1). This is also linear separable. In short, chance is more for a non-linear separable data in lower-dimensional space to become linear separable in higher-dimensional space.</p>
<p>In general, it is possible to map points in a d-dimensional space to some D-dimensional space <span class="math notranslate nohighlight">\((D&gt;d)\)</span> to check the possibility of linear separability. There is an idea which helps to compute the dot product in the high-dimensional (kernel) space by performing computations in the low-dimensional input (feature) space. We can illustrate with following example.</p>
<p>Consider two points in two-dimensional space, <span class="math notranslate nohighlight">\(p=(p_1,p_2)\)</span> and <span class="math notranslate nohighlight">\(q=(q_1,q_2)\)</span>. Let <span class="math notranslate nohighlight">\(\phi\)</span> be a mapping function which maps a two-dimensional point to three-dimensional space as follows:</p>
<div class="math notranslate nohighlight">
\[\phi (p) = (p_{1}^2,p_{2}^2,\sqrt{2} p_1 p_2) \phi (q) = (q_{1}^2,q_{2}^2,\sqrt{2} q_1 q_2)\]</div>
<p>Let us define a kernel function <span class="math notranslate nohighlight">\(K(p,q)\)</span> which does a dot product between two points, shown below:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned} K(p,q) = \phi(p).\phi(q) &amp;= \phi(p)^T \phi(q) \\ &amp;= (p_{1}^2,p_{2}^2,\sqrt{2} p_1 p_2).(q_{1}^2,q_{2}^2,\sqrt{2} q_1 q_2) \\ &amp;= p_1 q_1 + p_2 q_2 + 2 p_1 q_1 p_2 q_2 \\ &amp;= (p_1 q_1 + p_2 q_2)^2 \\ \phi(p).\phi(q) &amp;= (p.q)^2 \end{aligned}\end{split}\]</div>
<p>It means, a dot product in three-dimensional space can be achieved using squared dot product in two-dimensional space. This can be applied to higher dimensional space. So we can calculate higher dimensional features from lower dimensions itself. Once we map them, we get a higher dimensional space.</p>
<p>In addition to all these concepts, there comes the problem of misclassification. So just finding decision boundary with maximum margin is not sufficient. We need to consider the problem of misclassification errors also. Sometimes, it may be possible to find a decision boundary with less margin, but with reduced misclassification. Anyway we need to modify our model such that it should find decision boundary with maximum margin, but with less misclassification. The minimization criteria is modified as:</p>
<div class="math notranslate nohighlight">
\[min \; ||w||^2 + C(distance \; of \; misclassified \; samples \; to \; their \; correct \; regions)\]</div>
<p>Below image shows this concept. For each sample of the training data a new parameter <span class="math notranslate nohighlight">\(\xi_i\)</span> is defined. It is the distance from its corresponding training sample to their correct decision region. For those who are not misclassified, they fall on their corresponding support planes, so their distance is zero.</p>
<img alt="image" src="_images/svm_basics3.png" />
<p>So the new optimization problem is :</p>
<div class="math notranslate nohighlight">
\[\min_{w, b_{0}} L(w,b_0) = ||w||^{2} + C \sum_{i} {\xi_{i}} \text{ subject to } y_{i}(w^{T} x_{i} + b_{0}) \geq 1 - \xi_{i} \text{ and } \xi_{i} \geq 0 \text{ } \forall i\]</div>
<p>How should the parameter C be chosen? It is obvious that the answer to this question depends on how the training data is distributed. Although there is no general answer, it is useful to take into account these rules:</p>
<ul class="simple">
<li>Large values of C give solutions with less misclassification errors but a smaller margin. Consider that in this case it is expensive to make misclassification errors. Since the aim of the optimization is to minimize the argument, few misclassifications errors are allowed.</li>
<li>Small values of C give solutions with bigger margin and more classification errors. In this case the minimization does not consider that much the term of the sum so it focuses more on finding a hyperplane with big margin.</li>
</ul>
<p class="rubric">Additional Resources</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://www.nptel.ac.in/courses/106108057/26">NPTEL notes on Statistical Pattern Recognition, Chapters 25-29</a>.</li>
</ol>
<p class="rubric">Exercises</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="page_tutorial_py_table_of_contents_objdetect.html" title="Object Detection"
             >next</a> |</li>
        <li class="right" >
          <a href="page_tutorial_py_svm_opencv.html" title="OCR of Hand-written Data using SVM"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenCV Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="page_tutorial_py_root.html" >OpenCV-Python Tutorials</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="page_tutorial_py_table_of_contents_ml.html" >Machine Learning</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="page_tutorial_py_svm_index.html" >Support Vector Machines (SVM)</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1999-2017, OpenCV Maintainers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>