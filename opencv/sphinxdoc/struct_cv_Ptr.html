
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>template struct cv::Ptr &#8212; OpenCV Documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-sphinxdoc.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/target-highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="struct cv::UMatData" href="struct_cv_UMatData.html" />
    <link rel="prev" title="template struct cv::ParamType&lt;double&gt;" href="struct_cv_ParamType-11.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="struct_cv_UMatData.html" title="struct cv::UMatData"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="struct_cv_ParamType-11.html" title="template struct cv::ParamType&lt;double&gt;"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenCV Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="group_core.html" >Core functionality</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="group_core_basic.html" accesskey="U">Basic structures</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">template struct cv::Ptr</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#detailed-documentation">Detailed Documentation</a><ul>
<li><a class="reference internal" href="#typedefs">Typedefs</a></li>
<li><a class="reference internal" href="#construction">Construction</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="struct_cv_ParamType-11.html"
                        title="previous chapter">template struct cv::ParamType&lt;double&gt;</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="struct_cv_UMatData.html"
                        title="next chapter">struct cv::UMatData</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="template-struct-cv-ptr">
<span id="doxid-d2-d56-structcv-1-1-ptr"></span><span id="index-0"></span><h1>template struct cv::Ptr</h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h2>Overview</h2>
<p>Template class for smart pointers with shared ownership. <a class="reference internal" href="#details-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Moreâ€¦</span></a></p>
<pre class="highlight doxyrest-overview-code-block literal-block">
<span></span><span class="cp">#include</span> <span class="cpf">&lt;cvstd.hpp&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Ptr</span>
<span class="p">{</span>
    <span class="c1">// typedefs</span>

    <span class="k">typedef</span> <span class="n">T</span> <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a62fe84229cc13c10910507a0b5c5ed8b"><span class="std std-ref">element_type</span></a><span></span><span class="p">;</span>

    <span class="c1">// construction</span>

    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a85cbac0b7613df0999cea5b6250e7851"><span class="std std-ref">Ptr</span></a><span></span><span class="p">();</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1aeb7df1b18cbb91c6ce000ab6ed223a28"><span class="std std-ref">Ptr</span></a><span></span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">Y</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">D</span>
        <span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a051a5da806454bc09695752bd428c4b8"><span class="std std-ref">Ptr</span></a><span></span><span class="p">(</span>
        <span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
        <span class="n">D</span> <span class="n">d</span>
        <span class="p">);</span>

    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a7488a8da83aff1cd90ecd02065abe257"><span class="std std-ref">Ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a8c4c6991a08635f89a787edb3d0b7364"><span class="std std-ref">Ptr</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1ad9f6d4d471cd64a853e275d5bf30907c"><span class="std std-ref">Ptr</span></a><span></span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">,</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span>
        <span class="p">);</span>

    <span class="c1">// methods</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a321bbb47e912dd3f6cf7733a286bb0f4"><span class="std std-ref">constCast</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a141f3b16ca0fa11727d8daee52b6402e"><span class="std std-ref">dynamicCast</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e"><span class="std std-ref">empty</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">T</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1ab77ede1f78274936050b4cfc018c5711"><span class="std std-ref">get</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a020943728a309b2daab5267b3f099c21"><span class="std std-ref">operator T*</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">detail</span><span class="o">::</span><span class="n">RefOrVoid</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a44b9298493960e90c5ae6fc5b4e7e78b"><span class="std std-ref">operator*</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">T</span><span class="o">*</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a9b39661830d8942ce5157b2afee04bba"><span class="std std-ref">operator-&gt;</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Ptr</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a468377d212f11a2501dcb3fab37955cd"><span class="std std-ref">operator=</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&amp;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1af57120cfa2424b2da090081ffaa2ab36"><span class="std std-ref">operator=</span></a><span></span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">);</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a6f39adf60242c644dd7434b0444bbb08"><span class="std std-ref">release</span></a><span></span><span class="p">();</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a8100350b806a4e664cbec3445b8d30a0"><span class="std std-ref">reset</span></a><span></span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">Y</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">D</span>
        <span class="o">&gt;</span>
    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a38d19fbe9a12af272a82ea021d18d97e"><span class="std std-ref">reset</span></a><span></span><span class="p">(</span>
        <span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
        <span class="n">D</span> <span class="n">d</span>
        <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a2b31a5315638c99ab7ba69c2f86b3a8b"><span class="std std-ref">staticCast</span></a><span></span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>
    <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1a4ce9b80e2b7d25daac74fc528228a0f3"><span class="std std-ref">swap</span></a><span></span><span class="p">(</span><span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>
<span class="p">};</span>
</pre>
</div>
<div class="section" id="detailed-documentation">
<span id="details-d2-d56-structcv-1-1-ptr"></span><h2>Detailed Documentation</h2>
<p>Template class for smart pointers with shared ownership.</p>
<p>A <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> &lt;T&gt; pretends to be a pointer to an object of type T. Unlike an ordinary pointer, however, the object will be automatically cleaned up once all <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> instances pointing to it are destroyed.</p>
<p><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> is similar to boost::shared_ptr that is part of the Boost library (<a class="reference external" href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm</a>) and std::shared_ptr from the <a class="reference external" href="http://en.wikipedia.org/wiki/C++11">C++11</a> standard.</p>
<p>This class provides the following advantages:</p>
<ul class="simple">
<li>Default constructor, copy constructor, and assignment operator for an arbitrary C++ class or C structure. For some objects, like files, windows, mutexes, sockets, and others, a copy constructor or an assignment operator are difficult to define. For some other objects, like complex classifiers in OpenCV, copy constructors are absent and not easy to implement. Finally, some of complex OpenCV and your own data structures may be written in C. However, copy constructors and default constructors can simplify programming a lot. Besides, they are often required (for example, by STL containers). By using a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to such an object instead of the object itself, you automatically get all of the necessary constructors and the assignment operator.</li>
<li><em>O(1)</em> complexity of the above-mentioned operations. While some structures, like std::vector, provide a copy constructor and an assignment operator, the operations may take a considerable amount of time if the data structures are large. But if the structures are put into a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a>, the overhead is small and independent of the data size.</li>
<li>Automatic and customizable cleanup, even for C structures. See the example below with FILE*.</li>
<li>Heterogeneous collections of objects. The standard STL and most other C++ and OpenCV containers can store only objects of the same type and the same size. The classical solution to store objects of different types in the same container is to store pointers to the base class (Base*) instead but then you lose the automatic memory management. Again, by using <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> &lt;Base&gt; instead of raw pointers, you can solve the problem.</li>
</ul>
<p>A <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> is said to <em>own</em> a pointer - that is, for each <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> there is a pointer that will be deleted once all <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> instances that own it are destroyed. The owned pointer may be null, in which case nothing is deleted. Each <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> also <em>stores</em> a pointer. The stored pointer is the pointer the <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> pretends to be; that is, the one you get when you use <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1ab77ede1f78274936050b4cfc018c5711"><span class="std std-ref">Ptr::get</span></a> or the conversion to T*. Itâ€™s usually the same as the owned pointer, but if you use casts or the general shared-ownership constructor, the two may diverge: the <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> will still own the original pointer, but will itself point to something else.</p>
<p>The owned pointer is treated as a black box. The only thing <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> needs to know about it is how to delete it. This knowledge is encapsulated in the <em>deleter</em> - an auxiliary object that is associated with the owned pointer and shared between all <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> instances that own it. The default deleter is an instance of DefaultDeleter, which uses the standard C++ delete operator; as such it will work with any pointer allocated with the standard new operator.</p>
<p>However, if the pointer must be deleted in a different way, you must specify a custom deleter upon <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> construction. A deleter is simply a callable object that accepts the pointer as its sole argument. For example, if you want to wrap FILE, you may do so as follows:</p>
<pre class="highlight literal-block">
<span></span><span class="n">Ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">),</span> <span class="n">fclose</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span> <span class="k">throw</span> <span class="p">...;</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">....);</span>
<span class="p">...</span>
<span class="c1">// the file will be closed automatically by f&#39;s destructor.</span>
</pre>
<p>Alternatively, if you want all pointers of a particular type to be deleted the same way, you can specialize DefaultDeleter&lt;T&gt;::operator() for that type, like this:</p>
<pre class="highlight literal-block">
<span></span><span class="k">namespace</span> <span class="n">cv</span> <span class="p">{</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">DefaultDeleter</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="p">()(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre>
<p>For convenience, the following types from the OpenCV C API already have such a specialization that calls the appropriate release function:</p>
<ul>
<li><p class="first">CvCapture</p>
</li>
<li><p class="first">CvFileStorage</p>
</li>
<li><p class="first"><a class="reference internal" href="struct_CvHaarClassifierCascade.html#doxid-d9-dda-struct-cv-haar-classifier-cascade"><span class="std std-ref">CvHaarClassifierCascade</span></a></p>
</li>
<li><p class="first"><a class="reference internal" href="struct_CvMat.html#doxid-d6-dda-struct-cv-mat"><span class="std std-ref">CvMat</span></a></p>
</li>
<li><p class="first"><a class="reference internal" href="struct_CvMatND.html#doxid-d7-d5c-struct-cv-mat-n-d"><span class="std std-ref">CvMatND</span></a></p>
</li>
<li><p class="first"><a class="reference internal" href="struct_CvMemStorage.html#doxid-d7-d51-struct-cv-mem-storage"><span class="std std-ref">CvMemStorage</span></a></p>
</li>
<li><p class="first"><a class="reference internal" href="struct_CvSparseMat.html#doxid-d3-d6a-struct-cv-sparse-mat"><span class="std std-ref">CvSparseMat</span></a></p>
</li>
<li><p class="first">CvVideoWriter</p>
</li>
<li><p class="first"><a class="reference internal" href="struct_IplImage.html#doxid-dd-d51-struct-ipl-image"><span class="std std-ref">IplImage</span></a> The shared ownership mechanism is implemented with reference counting. As such, cyclic ownership (e.g. when object a contains a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to object b, which contains a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to object a) will lead to all involved objects never being cleaned up. Avoid such situations.</p>
<p>It is safe to concurrently read (but not write) a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> instance from multiple threads and therefore it is normally safe to use it in multi-threaded applications. The same is true for <a class="reference internal" href="class_cv_Mat.html#doxid-db-de6-classcv-1-1-mat"><span class="std std-ref">Mat</span></a> and other C++ OpenCV classes that use internal reference counts.</p>
</li>
</ul>
<div class="section" id="typedefs">
<h3>Typedefs</h3>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a62fe84229cc13c10910507a0b5c5ed8b">
<span id="index-1"></span><span></span><span class="k">typedef</span> <span class="n">T</span> <span class="n">element_type</span>
</pre>
<p>Generic programming support.</p>
</div>
<div class="section" id="construction">
<h3>Construction</h3>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a85cbac0b7613df0999cea5b6250e7851">
<span id="index-2"></span><span></span><span class="n">Ptr</span><span class="p">()</span>
</pre>
<p>The default constructor creates a null <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> - one that owns and stores a null pointer.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1aeb7df1b18cbb91c6ce000ab6ed223a28">
<span id="index-3"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
</pre>
<p>If p is null, these are equivalent to the default constructor. Otherwise, these constructors assume ownership of p - that is, the created <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> owns and stores p and assumes it is the sole owner of it. Donâ€™t use them if p is already owned by another <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a>, or else p will get deleted twice. With the first constructor, DefaultDeleter&lt;Y&gt;() becomes the associated deleter (so p will eventually be deleted with the standard delete operator). Y must be a complete type at the point of invocation. With the second constructor, d becomes the associated deleter. Y* must be convertible to T*. It is often easier to use makePtr instead.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>p</td>
<td>Pointer to own.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a051a5da806454bc09695752bd428c4b8">
<span id="index-4"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">Y</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">D</span>
    <span class="o">&gt;</span>
<span class="n">Ptr</span><span class="p">(</span>
    <span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
    <span class="n">D</span> <span class="n">d</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>d</td>
<td>Deleter to use for the owned pointer.</td>
</tr>
<tr class="row-even"><td>p</td>
<td>Pointer to own.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a7488a8da83aff1cd90ecd02065abe257">
<span id="index-5"></span><span></span><span class="n">Ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span>
</pre>
<p>These constructors create a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> that shares ownership with another <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> - that is, own the same pointer as o. With the first two, the same pointer is stored, as well; for the second, Y* must be convertible to T*. With the third, p is stored, and Y may be any type. This constructor allows to have completely unrelated owned and stored pointers, and should be used with care to avoid confusion. A relatively benign use is to create a non-owning <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a>, like this:</p>
<pre class="highlight literal-block">
<span></span><span class="n">ptr</span> <span class="o">=</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">dont_delete_me</span><span class="p">);</span> <span class="c1">// owns nothing; will not delete the pointer.</span>
</pre>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>o</td>
<td><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to share ownership with.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a8c4c6991a08635f89a787edb3d0b7364">
<span id="index-6"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>o</td>
<td><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to share ownership with.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1ad9f6d4d471cd64a853e275d5bf30907c">
<span id="index-7"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">,</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>o</td>
<td><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to share ownership with.</td>
</tr>
<tr class="row-even"><td>p</td>
<td>Pointer to store.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="methods">
<h3>Methods</h3>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a321bbb47e912dd3f6cf7733a286bb0f4">
<span id="index-8"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
<span class="n">constCast</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Ditto for const_cast.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a141f3b16ca0fa11727d8daee52b6402e">
<span id="index-9"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
<span class="n">dynamicCast</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Ditto for dynamic_cast.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e">
<span id="index-10"></span><span></span><span class="kt">bool</span>
<span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>ptr.empty() is equivalent to <code class="docutils literal notranslate"><span class="pre">!ptr.</span><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1ab77ede1f78274936050b4cfc018c5711"><span class="std std-ref"><span class="pre">get()</span></span></a></code>.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1ab77ede1f78274936050b4cfc018c5711">
<span id="index-11"></span><span></span><span class="n">T</span><span class="o">*</span>
<span class="n">get</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns the stored pointer.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a020943728a309b2daab5267b3f099c21">
<span id="index-12"></span><span></span><span class="k">operator</span> <span class="n">T</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Equivalent to <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr-1ab77ede1f78274936050b4cfc018c5711"><span class="std std-ref">get()</span></a>.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a44b9298493960e90c5ae6fc5b4e7e78b">
<span id="index-13"></span><span></span><span class="n">detail</span><span class="o">::</span><span class="n">RefOrVoid</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Ordinary pointer emulation.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a9b39661830d8942ce5157b2afee04bba">
<span id="index-14"></span><span></span><span class="n">T</span><span class="o">*</span>
<span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Ordinary pointer emulation.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a468377d212f11a2501dcb3fab37955cd">
<span id="index-15"></span><span></span><span class="n">Ptr</span><span class="o">&amp;</span>
<span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span>
</pre>
<p>Assignment replaces the current <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> instance with one that owns and stores same pointers as o and then destroys the old instance.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>o</td>
<td><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to share ownership with.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1af57120cfa2424b2da090081ffaa2ab36">
<span id="index-16"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="o">&amp;</span>
<span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a6f39adf60242c644dd7434b0444bbb08">
<span id="index-17"></span><span></span><span class="kt">void</span>
<span class="n">release</span><span class="p">()</span>
</pre>
<p>If no other <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> instance owns the owned pointer, deletes it with the associated deleter. Then sets both the owned and the stored pointers to NULL.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a8100350b806a4e664cbec3445b8d30a0">
<span id="index-18"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">reset</span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
</pre>
<p><code class="docutils literal notranslate"><span class="pre">ptr.reset(...)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">ptr</span> <span class="pre">=</span> <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref"><span class="pre">Ptr</span></span></a><span class="pre">&lt;T&gt;(...)</span></code>.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>p</td>
<td>Pointer to own.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a38d19fbe9a12af272a82ea021d18d97e">
<span id="index-19"></span><span></span><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">Y</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">D</span>
    <span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">reset</span><span class="p">(</span>
    <span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
    <span class="n">D</span> <span class="n">d</span>
    <span class="p">)</span>
</pre>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>d</td>
<td>Deleter to use for the owned pointer.</td>
</tr>
<tr class="row-even"><td>p</td>
<td>Pointer to own.</td>
</tr>
</tbody>
</table>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a2b31a5315638c99ab7ba69c2f86b3a8b">
<span id="index-20"></span><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
<span class="n">staticCast</span><span class="p">()</span> <span class="k">const</span>
</pre>
<p>Returns a <a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> that owns the same pointer as this, and stores the same pointer as this, except converted via static_cast to Y*.</p>
<pre class="highlight doxyrest-title-code-block literal-block" id="doxid-d2-d56-structcv-1-1-ptr-1a4ce9b80e2b7d25daac74fc528228a0f3">
<span id="index-21"></span><span></span><span class="kt">void</span>
<span class="n">swap</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span>
</pre>
<p>Swaps the owned and stored pointers (and deleters, if any) of this and o.</p>
<p class="rubric">Parameters:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>o</td>
<td><a class="reference internal" href="#doxid-d2-d56-structcv-1-1-ptr"><span class="std std-ref">Ptr</span></a> to swap with.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="struct_cv_UMatData.html" title="struct cv::UMatData"
             >next</a> |</li>
        <li class="right" >
          <a href="struct_cv_ParamType-11.html" title="template struct cv::ParamType&lt;double&gt;"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OpenCV Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="group_core.html" >Core functionality</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="group_core_basic.html" >Basic structures</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1999-2017, OpenCV Maintainers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>